diff --git a/assembly/pom.xml b/assembly/pom.xml
index 1bbab03d56a..ab7b2900ef4 100644
--- a/assembly/pom.xml
+++ b/assembly/pom.xml
@@ -74,6 +74,16 @@
       <artifactId>spark-repl_${scala.binary.version}</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>org.apache.spark</groupId>
+      <artifactId>tree_${scala.binary.version}</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.spark</groupId>
+      <artifactId>exp_${scala.binary.version}</artifactId>
+      <version>${project.version}</version>
+    </dependency>
 
     <!--
       Because we don't shade dependencies anymore, we need to restore Guava to compile scope so
diff --git a/dev/make-distribution.sh b/dev/make-distribution.sh
index 948ee19fbac..8223caefb8a 100755
--- a/dev/make-distribution.sh
+++ b/dev/make-distribution.sh
@@ -26,7 +26,7 @@
 
 set -o pipefail
 set -e
-set -x
+# set -x
 
 # Figure out where the Spark framework is installed
 SPARK_HOME="$(cd "`dirname "$0"`/.."; pwd)"
diff --git a/exp/pom.xml b/exp/pom.xml
new file mode 100644
index 00000000000..d94403cc258
--- /dev/null
+++ b/exp/pom.xml
@@ -0,0 +1,318 @@
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the "License"); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~    http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<modelVersion>4.0.0</modelVersion>
+<parent>
+    <groupId>org.apache.spark</groupId>
+    <artifactId>spark-parent_2.12</artifactId>
+    <version>3.4.2-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+</parent>
+
+<artifactId>exp_2.12</artifactId>
+<properties>
+    <sbt.project.name>exp</sbt.project.name>
+    <guava.version>31.0.1-jre</guava.version>
+    <guava.failureaccess.version>1.0.1</guava.failureaccess.version>
+    <io.grpc.version>1.47.0</io.grpc.version>
+    <tomcat.annotations.api.version>6.0.53</tomcat.annotations.api.version>
+</properties>
+<packaging>jar</packaging>
+<name>Spark Exp</name>
+<url>https://spark.apache.org/</url>
+
+<dependencies>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-core_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-sql_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-catalyst_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-hive_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>tree_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>io.delta</groupId>
+        <artifactId>delta-core_2.12</artifactId>
+        <version>2.4.0</version>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.iceberg</groupId>
+        <artifactId>iceberg-spark-runtime-3.4_2.12</artifactId>
+        <version>1.5.2</version>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.commons</groupId>
+        <artifactId>commons-math3</artifactId>
+    </dependency>
+    <dependency>
+        <groupId>org.scalacheck</groupId>
+        <artifactId>scalacheck_${scala.binary.version}</artifactId>
+        <scope>test</scope>
+    </dependency>
+    <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+        <scope>compile</scope>
+    </dependency>
+    <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>failureaccess</artifactId>
+        <version>${guava.failureaccess.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>com.google.protobuf</groupId>
+        <artifactId>protobuf-java</artifactId>
+        <version>${protobuf.version}</version>
+        <scope>compile</scope>
+    </dependency>
+    <dependency>
+        <groupId>com.google.protobuf</groupId>
+        <artifactId>protobuf-java-util</artifactId>
+        <version>${protobuf.version}</version>
+        <scope>compile</scope>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-netty</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-protobuf</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-services</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-stub</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-codec-http2</artifactId>
+        <version>${netty.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-handler-proxy</artifactId>
+        <version>${netty.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-transport-native-unix-common</artifactId>
+        <version>${netty.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency> <!-- necessary for Java 9+ -->
+        <groupId>org.apache.tomcat</groupId>
+        <artifactId>annotations-api</artifactId>
+        <version>${tomcat.annotations.api.version}</version>
+        <scope>provided</scope>
+    </dependency>
+</dependencies>
+
+<build>
+    <outputDirectory>target/scala-${scala.binary.version}/classes</outputDirectory>
+    <testOutputDirectory>target/scala-${scala.binary.version}/test-classes</testOutputDirectory>
+    <plugins>
+        <!-- Shade all GRPC / Guava / Protobuf dependencies of this build -->
+        <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-shade-plugin</artifactId>
+            <configuration>
+                <shadedArtifactAttached>false</shadedArtifactAttached>
+                <artifactSet>
+                    <includes>
+                        <include>com.google.guava:*</include>
+                        <include>io.grpc:*:</include>
+                        <include>com.google.protobuf:*</include>
+
+                        <!--
+                          The dependencies below are not added in SBT because SBT add them all
+                          as assembly build.
+                        -->
+                        <include>com.google.android:annotations</include>
+                        <include>com.google.api.grpc:proto-google-common-protos</include>
+                        <include>io.perfmark:perfmark-api</include>
+                        <include>org.codehaus.mojo:animal-sniffer-annotations</include>
+                        <include>com.google.errorprone:error_prone_annotations</include>
+                        <include>com.google.j2objc:j2objc-annotations</include>
+                        <include>org.checkerframework:checker-qual</include>
+                        <include>com.google.code.gson:gson</include>
+                        <include>org.apache.spark:spark-connect-common_${scala.binary.version}</include>
+                    </includes>
+                </artifactSet>
+                <relocations>
+                    <relocation>
+                        <pattern>com.google.common</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.guava</shadedPattern>
+                        <includes>
+                            <include>com.google.common.**</include>
+                        </includes>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.thirdparty</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.guava</shadedPattern>
+                        <includes>
+                            <include>com.google.thirdparty.**</include>
+                        </includes>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.protobuf</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.protobuf</shadedPattern>
+                        <includes>
+                            <include>com.google.protobuf.**</include>
+                        </includes>
+                    </relocation>
+                    <relocation>
+                        <pattern>io.grpc</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.grpc</shadedPattern>
+                    </relocation>
+
+                    <relocation>
+                        <pattern>android.annotation</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.android_annotation</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>io.perfmark</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.io_perfmark</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>org.codehaus.mojo.animal_sniffer</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.animal_sniffer</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.j2objc.annotations</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.j2objc_annotations</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.errorprone.annotations</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.errorprone_annotations</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>org.checkerframework</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.checkerframework</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.gson</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.gson</shadedPattern>
+                    </relocation>
+
+                    <!--
+                      For `com.google.api.grpc:proto-google-common-protos`, do not directly define pattern
+                      as `common.google`, otherwise, otherwise, the relocation result may be uncertain due
+                      to the change of rule order.
+                    -->
+                    <relocation>
+                        <pattern>com.google.api</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.api</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.cloud</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.cloud</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.geo</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.geo</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.logging</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.logging</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.longrunning</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.longrunning</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.rpc</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.rpc</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.type</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.type</shadedPattern>
+                    </relocation>
+                </relocations>
+                <transformers>
+                    <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/>
+                </transformers>
+            </configuration>
+        </plugin>
+    </plugins>
+
+</build>
+
+</project>
diff --git a/exp/src/main/scala/org/apache/spark/exp/CommitExperiment.scala b/exp/src/main/scala/org/apache/spark/exp/CommitExperiment.scala
new file mode 100644
index 00000000000..3aa11a19a61
--- /dev/null
+++ b/exp/src/main/scala/org/apache/spark/exp/CommitExperiment.scala
@@ -0,0 +1,401 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.exp
+
+import java.io.File
+import java.io.FileWriter
+import java.time.{Duration, Instant}
+import java.util.concurrent.Executors
+import java.util.concurrent.atomic.AtomicBoolean
+
+import scala.collection.mutable.ArrayBuffer
+import scala.concurrent.{Await, ExecutionContext, Future}
+import scala.io.Source
+
+import com.fasterxml.jackson.databind.ObjectMapper
+import org.apache.iceberg.spark.SparkCatalog
+
+import org.apache.spark.sql.connector.catalog.{DelegatingCatalogExtension, Identifier}
+import org.apache.spark.sql.connector.catalog.TableChange.renameColumn
+import org.apache.spark.sql.hive.HiveExternalCatalog
+import org.apache.spark.sql.types.{StructField, StructType}
+import org.apache.spark.tree.TreeExternalCatalog
+import org.apache.spark.tree.grpc.Grpccatalog
+
+
+object CommitExperiment {
+  val misc_config = scala.collection.mutable.Map.empty[String, String]
+  misc_config.put("summaryOutput", "/tmp/commit-summary.json")
+  misc_config.put("latencyOutput", "/tmp/commit-latency.json")
+  misc_config.put("experimentIters", "500")
+  misc_config.put("experimentTime", "00:05:00")
+  misc_config.put("treeAddress", "localhost:9876")
+
+  private def convertToMilliseconds(time : String): Int = {
+    val parts = time.split(":").map(_.toInt)
+    val hours = parts(0)
+    val minutes = parts(1)
+    val seconds = parts(2)
+    (hours * 3600 + minutes * 60 + seconds) * 1000
+  }
+
+  def main(args: Array[String]): Unit = {
+    if (args.size != 2) {
+      print("Usage: spark-class org.apache.spark.exp.CommitExperiment " +
+        "<commitConfig> <catalogType>\n")
+      return
+    }
+
+    val json_parser = new ObjectMapper
+    // read in data config
+    val scan_config_json = json_parser.readTree(Source.fromFile(args(0)).mkString)
+    scan_config_json.get("misc").fields().forEachRemaining { config =>
+      misc_config.put(config.getKey, config.getValue.asText())
+    }
+
+    val summary_output = misc_config("summaryOutput")
+    val latency_output = misc_config("latencyOutput")
+
+    val iters = misc_config("experimentIters").toInt
+    val experiment_time = convertToMilliseconds(misc_config("experimentTime"))
+
+    val tree_address = misc_config("treeAddress")
+
+    val delta_db = scan_config_json.get("delta").asText()
+    val hms_db = scan_config_json.get("hms").asText()
+    val tree_db = scan_config_json.get("tree").asText()
+    val iceberg_db = scan_config_json.get("iceberg").asText()
+    val table_name = scan_config_json.get("tables").get(0).get("name").asText()
+    val col_name = scan_config_json.get("tables").get(0).get("schema").get(0).get("name").asText()
+    val col_name2 = col_name + "2"
+    val col_names = Array(col_name, col_name2)
+
+    val catalog_type = args(1)
+
+    val thread_pool = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(2))
+
+    catalog_type match {
+      case "delta" => testDelta(summary_output, latency_output, iters : Int,
+                              experiment_time, delta_db, table_name,
+                              col_names, thread_pool)
+      case "hms" => testHMS(summary_output, latency_output, iters : Int,
+                                    experiment_time, hms_db, table_name,
+                                    col_names, thread_pool)
+      case "iceberg" => testIceberg(summary_output, latency_output, iters : Int,
+                                    experiment_time, iceberg_db, table_name,
+                                    col_names, thread_pool)
+      case "tree" => testTree(summary_output, latency_output, iters : Int,
+                              experiment_time, tree_db, table_name,
+                              col_names, thread_pool, tree_address)
+      case _ => print("Invalid Catalog Type!!!")
+    }
+
+    thread_pool.shutdown()
+  }
+
+  private def writeOutput(summaryOutput : String, latencyOutput : String,
+                          throughput : Int, times : Seq[Long], catalog : String,
+                          experiment_time : Int): Unit = {
+    val latencyOutputWriter = new FileWriter(new File(latencyOutput), true)
+    times.foreach { time =>
+      latencyOutputWriter.write("{\"catalog\":\"" + catalog + "\", ")
+      latencyOutputWriter.write("\"time\":" + time + "}")
+      latencyOutputWriter.write("\n")
+    }
+    latencyOutputWriter.flush()
+    latencyOutputWriter.close()
+
+    val summaryOutputWriter = new FileWriter(new File(summaryOutput), true)
+    summaryOutputWriter.write("{\"catalog\":\"" + catalog + "\", ")
+    summaryOutputWriter.write("\"experimentTime\":" + experiment_time / 1000 + ", ")
+    summaryOutputWriter.write("\"throughput\":" + throughput + "}")
+    summaryOutputWriter.write("\n")
+    summaryOutputWriter.flush()
+    summaryOutputWriter.close()
+  }
+
+  private def alterDelta(delta : DelegatingCatalogExtension, ident : Identifier,
+                         col_names : Array[String], changed : Boolean) : Boolean = {
+    if (changed) {
+      delta.alterTable(ident, renameColumn(Array(col_names(1)), col_names(0)))
+      false
+    }
+    else {
+      delta.alterTable(ident, renameColumn(Array(col_names(0)), col_names(1)))
+      true
+    }
+  }
+
+  private def testDelta(summaryOutput : String, latencyOutput : String, iters : Int,
+                        experiment_time : Int, db_name : String, table_name : String,
+                        col_names : Array[String], thread_pool : ExecutionContext) : Unit = {
+
+    val delta_util = new DeltaUtil()
+    val ident = Identifier.of(Array(db_name), table_name)
+    val changed = new AtomicBoolean(false)
+    val exec_throughput = new AtomicBoolean(false)
+
+    // dry run
+    for (i <- 0 until 10) {
+      changed.set(alterDelta(delta_util.delta, ident, col_names, changed.get()))
+    }
+
+    // measure throughput
+    exec_throughput.set(true)
+    val future = Future[Int] {
+      var throughput = 0
+      while (exec_throughput.get()) {
+        changed.set(alterDelta(delta_util.delta, ident, col_names, changed.get()))
+        throughput += 1
+      }
+      throughput
+    }(thread_pool)
+
+    Thread.sleep(experiment_time)
+    exec_throughput.set(false)
+
+    // scalastyle:off awaitresult
+    val throughput = Await.result(future, scala.concurrent.duration.Duration.Inf)
+    // scalastyle:on awaitresult
+
+    // measure latency
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val start_time = Instant.now()
+      changed.set(alterDelta(delta_util.delta, ident, col_names, changed.get()))
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(summaryOutput, latencyOutput, throughput, times, "delta", experiment_time)
+  }
+
+  private def alterHMS(hms : HiveExternalCatalog, db_name : String, table_name : String,
+                       col_names : Array[String], changed : Boolean) : Boolean = {
+
+    val old_col_name = if (changed) {
+      col_names(1)
+    }
+    else {
+      col_names(0)
+    }
+
+    val new_col_name = if (changed) {
+      col_names(0)
+    }
+    else {
+      col_names(1)
+    }
+
+    val cur_table = hms.getTable(db_name, table_name)
+    val new_schema = ArrayBuffer[StructField]()
+    cur_table.schema.fields.foreach { struct_field =>
+      if (old_col_name == struct_field.name) {
+        new_schema += struct_field.copy(name = new_col_name)
+      }
+      else {
+        new_schema += struct_field
+      }
+    }
+    val new_table = cur_table.copy(
+      schema = StructType(new_schema))
+    hms.client.alterTable(new_table)
+
+    !changed
+  }
+
+  private def testHMS(summaryOutput : String, latencyOutput : String, iters : Int,
+                        experiment_time : Int, db_name : String, table_name : String,
+                        col_names : Array[String], thread_pool : ExecutionContext) : Unit = {
+    val hms_util = new HMSUtil()
+    val changed = new AtomicBoolean(false)
+    val exec_throughput = new AtomicBoolean(false)
+
+    // dry run
+    for (i <- 0 until 10) {
+      changed.set(alterHMS(hms_util.hms, db_name, table_name, col_names, changed.get()))
+    }
+
+    // measure throughput
+    exec_throughput.set(true)
+    val future = Future[Int] {
+      var throughput = 0
+      while (exec_throughput.get()) {
+        changed.set(alterHMS(hms_util.hms, db_name, table_name, col_names, changed.get()))
+        throughput += 1
+      }
+      throughput
+    }(thread_pool)
+
+    exec_throughput.set(true)
+    Thread.sleep(experiment_time)
+    exec_throughput.set(false)
+
+    // scalastyle:off awaitresult
+    val throughput = Await.result(future, scala.concurrent.duration.Duration.Inf)
+    // scalastyle:on awaitresult
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val start_time = Instant.now()
+      changed.set(alterHMS(hms_util.hms, db_name, table_name, col_names, changed.get()))
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(summaryOutput, latencyOutput, throughput, times, "hms", experiment_time)
+  }
+
+  private def alterTree(tree : TreeExternalCatalog, db_name : String, table_name : String,
+                        col_names : Array[String], changed : Boolean) : Boolean = {
+
+    val old_col_name = if (changed) {
+      col_names(1)
+    }
+    else {
+      col_names(0)
+    }
+
+    val new_col_name = if (changed) {
+      col_names(0)
+    }
+    else {
+      col_names(1)
+    }
+
+    val txn = tree.startTransaction(Grpccatalog.TxnMode.TXN_MODE_READ_WRITE)
+    val cur_table = tree.getTable(db_name, table_name, txn)
+    val new_schema = ArrayBuffer[StructField]()
+    cur_table.schema.fields.foreach { struct_field =>
+      if (old_col_name == struct_field.name) {
+        new_schema += struct_field.copy(name = new_col_name)
+      }
+      else {
+        new_schema += struct_field
+      }
+    }
+    val new_table = cur_table.copy(schema = StructType(new_schema))
+    tree.alterTable(new_table, txn)
+    tree.commit(txn.get)
+
+    !changed
+  }
+
+  private def testTree(summaryOutput : String, latencyOutput : String, iters : Int,
+                      experiment_time : Int, db_name : String, table_name : String,
+                      col_names : Array[String], thread_pool : ExecutionContext,
+                       tree_address : String) : Unit = {
+    val tree_util = new TreeUtil(tree_address)
+    val changed = new AtomicBoolean(false)
+    val exec_throughput = new AtomicBoolean(false)
+
+    // dry run
+    for (i <- 0 until 10) {
+      changed.set(alterTree(tree_util.tree, db_name, table_name, col_names, changed.get()))
+    }
+
+    // measure throughput
+    exec_throughput.set(true)
+    val future = Future[Int] {
+      var throughput = 0
+      while (exec_throughput.get()) {
+        changed.set(alterTree(tree_util.tree, db_name, table_name, col_names, changed.get()))
+        throughput += 1
+      }
+      throughput
+    }(thread_pool)
+
+    exec_throughput.set(true)
+    Thread.sleep(experiment_time)
+    exec_throughput.set(false)
+
+    // scalastyle:off awaitresult
+    val throughput = Await.result(future, scala.concurrent.duration.Duration.Inf)
+    // scalastyle:on awaitresult
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val start_time = Instant.now()
+      changed.set(alterTree(tree_util.tree, db_name, table_name, col_names, changed.get()))
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(summaryOutput, latencyOutput, throughput, times, "tree", experiment_time)
+  }
+
+
+  private def alterIceberg(iceberg : SparkCatalog, ident : Identifier,
+                           col_names : Array[String], changed : Boolean) : Boolean = {
+    if (changed) {
+      iceberg.alterTable(ident, renameColumn(Array(col_names(1)), col_names(0)))
+      false
+    }
+    else {
+      iceberg.alterTable(ident, renameColumn(Array(col_names(0)), col_names(1)))
+      true
+    }
+  }
+
+  private def testIceberg(summaryOutput : String, latencyOutput : String, iters : Int,
+                        experiment_time : Int, db_name : String, table_name : String,
+                        col_names : Array[String], thread_pool : ExecutionContext) : Unit = {
+
+    val iceberg_util = new IcebergUtil()
+    val ident = Identifier.of(Array(db_name), table_name)
+    val changed = new AtomicBoolean(false)
+    val exec_throughput = new AtomicBoolean(false)
+
+    // dry run
+    for (i <- 0 until 10) {
+      changed.set(alterIceberg(iceberg_util.iceberg, ident, col_names, changed.get()))
+    }
+
+    // measure throughput
+    exec_throughput.set(true)
+    val future = Future[Int] {
+      var throughput = 0
+      while (exec_throughput.get()) {
+        changed.set(alterIceberg(iceberg_util.iceberg, ident, col_names, changed.get()))
+        throughput += 1
+      }
+      throughput
+    }(thread_pool)
+
+    Thread.sleep(experiment_time)
+    exec_throughput.set(false)
+
+    // scalastyle:off awaitresult
+    val throughput = Await.result(future, scala.concurrent.duration.Duration.Inf)
+    // scalastyle:on awaitresult
+
+    // measure latency
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val start_time = Instant.now()
+      changed.set(alterIceberg(iceberg_util.iceberg, ident, col_names, changed.get()))
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(summaryOutput, latencyOutput, throughput, times, "iceberg", experiment_time)
+  }
+
+}
diff --git a/exp/src/main/scala/org/apache/spark/exp/ConcurrencyExperiment.scala b/exp/src/main/scala/org/apache/spark/exp/ConcurrencyExperiment.scala
new file mode 100644
index 00000000000..93f0ed5a74b
--- /dev/null
+++ b/exp/src/main/scala/org/apache/spark/exp/ConcurrencyExperiment.scala
@@ -0,0 +1,1109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.exp
+
+import java.io.{File, FileWriter}
+import java.net.URI
+import java.time.Duration
+import java.time.Instant
+import java.time.LocalDate
+import java.time.format.DateTimeFormatter
+import java.util.UUID
+import java.util.concurrent.ThreadLocalRandom
+import java.util.concurrent.atomic.{AtomicBoolean, AtomicLong}
+import java.util.concurrent.locks.ReentrantReadWriteLock
+
+import scala.collection.mutable.ArrayBuffer
+import scala.io.Source
+
+import com.fasterxml.jackson.databind.{JsonNode, ObjectMapper}
+import com.fasterxml.jackson.databind.node.JsonNodeType
+
+import org.apache.spark.sql.catalyst.catalog.{CatalogColumnStat, CatalogStatistics, CatalogStorageFormat, CatalogTable, CatalogTableFile, CatalogTypes}
+import org.apache.spark.sql.catalyst.expressions.Expression
+import org.apache.spark.sql.execution.SparkSqlParser
+import org.apache.spark.sql.types.{DateType, FractionalType, IntegralType, StructField}
+import org.apache.spark.tree.TreeExternalCatalog
+import org.apache.spark.tree.grpc.Grpccatalog.LockMode
+import org.apache.spark.tree.grpc.Grpccatalog.TxnMode
+
+
+sealed trait TableType
+object TableType {
+  case object Fact extends TableType
+  case object Dimension extends TableType
+}
+
+private class AttrConfig(attr_json: JsonNode) {
+  val name : String = attr_json.get("name").asText()
+  val data_type : String = attr_json.get("type").asText()
+  val key : Option[String] = attr_json.get("cardinality").getNodeType match {
+    case JsonNodeType.STRING => Some(attr_json.get("cardinality").asText())
+    case _ => None
+  }
+  val cardinality : Option[Long] = attr_json.get("cardinality").getNodeType match {
+    case JsonNodeType.STRING => None
+    case _ => Some(attr_json.get("cardinality").asLong())
+  }
+  val clustered : Boolean = attr_json.get("clustered").asBoolean()
+}
+
+private class OpData() {
+  var latency : Long = 0
+  var data_sent : Long = 0
+  var data_received : Long = 0
+  var op_type = 0
+  var misc = ""
+  var committed = false
+
+}
+
+private class TableConfig(table_json: JsonNode, scale_factor : String) {
+  val name: String = table_json.get("name").asText()
+  val table_type: TableType = if (table_json.get("type").asText() == "dimension") {
+    TableType.Dimension
+  }
+  else {
+    TableType.Fact
+  }
+  val partition_schema : Array[AttrConfig] = deSerSchema(table_json.get("partitionSchema"))
+  val schema : Array[AttrConfig] = deSerSchema(table_json.get("schema"))
+  val bytes_per_row : Long = 4*(partition_schema.length + schema.length)
+  val num_rows : Long = table_json.get("scaling").get(scale_factor).asLong()
+
+  val business_id : Option[AttrConfig] = schema.find{ attr_config => attr_config.name.
+    endsWith("_id") && attr_config.clustered }
+  val sk : Option[AttrConfig] = schema.find{ attr_config => attr_config.name.
+    endsWith("sk") && attr_config.clustered }
+  private var high_watermark : Long = num_rows
+  private val lock = new ReentrantReadWriteLock()
+
+  def setWatermark(new_watermark: Long): Unit = {
+    lock.writeLock().lock()
+    try {
+      high_watermark = high_watermark.max(new_watermark)
+    } finally {
+      lock.writeLock().unlock()
+    }
+  }
+
+  def getWatermark(): Long = {
+    lock.readLock().lock()
+    try {
+      high_watermark
+    } finally {
+      lock.readLock().unlock()
+    }
+  }
+
+  private def deSerSchema(schema_json : JsonNode) : Array[AttrConfig] = {
+    val schema = ArrayBuffer[AttrConfig]()
+    schema_json.forEach { attr_json =>
+      schema += new AttrConfig(attr_json)
+    }
+    schema.toArray
+  }
+}
+
+private class InsertConfig(insert_config_json: JsonNode) {
+  val insert_ratio : Double = insert_config_json.get("insertRatio").asDouble
+  val fact_tables : ArrayBuffer[String] = ArrayBuffer[String]()
+  val dim_tables : ArrayBuffer[String] = ArrayBuffer[String]()
+  insert_config_json.get("factTables").forEach { table =>
+    fact_tables += table.asText()
+  }
+  insert_config_json.get("dimensionTables").forEach { table =>
+    dim_tables += table.asText()
+  }
+}
+
+private class OptimizeConfig(optimize_config_json: JsonNode) {
+  val threshold : Int = optimize_config_json.get("threshold").asInt()
+  val tables : ArrayBuffer[String] = ArrayBuffer[String]()
+  optimize_config_json.get("tables").forEach{ table =>
+    tables += table.asText()
+  }
+}
+
+private class DeleteConfig(delete_config_json : JsonNode) {
+  val date_range : Int = delete_config_json.get("dateRange").asInt()
+  val tables : ArrayBuffer[Array[String]] = ArrayBuffer[Array[String]]()
+  delete_config_json.get("tables").forEach{ table_list =>
+    val temp_array = ArrayBuffer[String]()
+    table_list.forEach{ table =>
+      temp_array += table.asText()
+    }
+    tables += temp_array.toArray
+  }
+}
+
+private class ReadConfig(read_config_json : JsonNode) {
+  val queries : ArrayBuffer[JsonNode] = ArrayBuffer[JsonNode]()
+  read_config_json.get("queries").forEach { query =>
+    queries += query
+  }
+}
+
+private class TableGenerator(insert_config : InsertConfig, optimize_config : OptimizeConfig,
+                     delete_config : DeleteConfig, read_config : ReadConfig) {
+  def genInsertFactTable(): String = {
+    insert_config.fact_tables(ThreadLocalRandom.current().nextInt(insert_config.fact_tables.length))
+  }
+
+  def genInsertDimTables(): ArrayBuffer[String] = {
+    insert_config.dim_tables
+  }
+
+  def genOptimizeTable() : String = {
+    optimize_config.tables(ThreadLocalRandom.current().nextInt(optimize_config.tables.length))
+  }
+
+  def genDeleteTable() : Array[String] = {
+    delete_config.tables(ThreadLocalRandom.current().nextInt(delete_config.tables.length))
+  }
+
+  def genReadQuery() : (JsonNode, Int) = {
+    val query_idx = ThreadLocalRandom.current().nextInt(read_config.queries.length)
+    (read_config.queries(query_idx), query_idx)
+  }
+
+}
+
+private class OpGenerator(workload_ratio : String) {
+  private val cumulative_weights: List[(Int, Int)] = workload_ratio.split(":").map(_.toInt)
+    .toList.zipWithIndex.map { case (value, index) => (index, value) }.scanLeft((0, 0)) {
+      case ((_, cumulative), (index, weight)) => (index, cumulative + weight)
+    }.tail
+
+  private val total_weight = cumulative_weights.last._2
+
+  def genOp() : Int = {
+    val random_val = ThreadLocalRandom.current().nextInt(total_weight)
+    cumulative_weights.find {
+      case (_, cumulative) => random_val < cumulative
+    }.map(_._1).get
+  }
+}
+
+//  class TableGenerator(fact_weights : Map[String, Int], dimension_weights : Map[String, Int]) {
+//    val cumulative_fact_weights: List[(String, Int)] = fact_weights.toList.scanLeft(("", 0)) {
+//      case ((_, cumulative), (string, weight)) => (string, cumulative + weight)
+//    }.tail
+//
+//    private val total_fact_weight = cumulative_fact_weights.last._2
+//
+//    val cumulative_dimension_weights: List[(String, Int)] = dimension_weights.toList
+//    .scanLeft(("", 0))
+//    {
+//      case ((_, cumulative), (string, weight)) => (string, cumulative + weight)
+//    }.tail
+//
+//    private val total_dimension_weight = cumulative_dimension_weights.last._2
+//
+//    def genFactTable() : String = {
+//      val random_val = ThreadLocalRandom.current().nextInt(total_fact_weight)
+//      cumulative_fact_weights.find {
+//        case (_, cumulative) => random_val < cumulative
+//      }.map(_._1).get
+//    }
+//
+//    def genDimensionTable() : String = {
+//      val random_val = ThreadLocalRandom.current().nextInt(total_dimension_weight)
+//      cumulative_dimension_weights.find {
+//        case (_, cumulative) => random_val < cumulative
+//      }.map(_._1).get
+//    }
+//
+//  }
+
+
+object ConcurrencyExperiment {
+  val misc_config = scala.collection.mutable.Map.empty[String, String]
+  misc_config.put("summaryOutput", "/tmp/concurrency-summary.json")
+  misc_config.put("opOutput", "/tmp/concurrency-op.json")
+  misc_config.put("dryRunTime", "00:00:30")
+  misc_config.put("experimentTime", "00:05:00")
+  misc_config.put("numThreads", "10")
+  misc_config.put("totalNumThreads", "30")
+  misc_config.put("version", "1")
+  // Ratio is optimize:insertfact:insertdim:delete:read operations in order
+  misc_config.put("workloadRatio", "2:288:24:1:315")
+  misc_config.put("scaleFactor", "100T")
+  misc_config.put("treeAddress", "localhost:9876")
+  misc_config.put("startDate", "1998-01-01")
+  misc_config.put("endDate", "2003-12-31")
+
+  def main(args: Array[String]): Unit = {
+    if (args.size != 2) {
+      print("Usage: spark-class org.apache.spark.exp.ConcurrencyExperiment " +
+        "<dataConfig> <workloadConfig>\n")
+      return
+    }
+
+    val json_parser = new ObjectMapper
+    // read in data config
+    val data_config_json = json_parser.readTree(Source.fromFile(args(0)).mkString)
+    // read in workload config
+    val workload_config_json = json_parser.readTree(Source.fromFile(args(1)).mkString)
+    val database_name = data_config_json.get("databaseNames").get(0).asText()
+    // initialize misc config map
+    workload_config_json.get("misc").fields().forEachRemaining { config =>
+      misc_config.put(config.getKey, config.getValue.asText())
+    }
+
+    val optimize_config = new OptimizeConfig(workload_config_json.get("optimize"))
+    val insert_config = new InsertConfig(workload_config_json.get("insert"))
+    val delete_config = new DeleteConfig(workload_config_json.get("delete"))
+    val read_config = new ReadConfig(workload_config_json.get("read"))
+
+    val table_configs = scala.collection.mutable.HashMap[String, TableConfig]()
+    data_config_json.get("tables").forEach { table_json =>
+      table_configs.put(table_json.get("name").asText(), new TableConfig(table_json,
+        misc_config("scaleFactor")))
+    }
+
+    // initialize the dates
+    val date_formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
+    val start_date = LocalDate.parse(misc_config("startDate"), date_formatter)
+    val end_date = LocalDate.parse(misc_config("endDate"), date_formatter)
+    val dates: Array[String] = Iterator.iterate(start_date)(_ plusDays 1) // Generate dates
+      .takeWhile(!_.isAfter(end_date)) // Stop when exceeding the end date
+      .map(_.format(date_formatter)) // Convert to formatted strings
+      .toArray
+
+    // Initialize the table generator. Probabilities are weighed equally for now
+    val table_generator = new TableGenerator(insert_config, optimize_config,
+      delete_config, read_config)
+    val op_generator = new OpGenerator(misc_config("workloadRatio"))
+
+    val exec_dry_run = new AtomicBoolean(false)
+    val exec_experiment = new AtomicBoolean(false)
+    val total_num_commits = new AtomicLong(0)
+    val total_num_aborts = new AtomicLong(0)
+    val dry_run_time = convertToMilliseconds(misc_config("dryRunTime"))
+    val experiment_time = convertToMilliseconds(misc_config("experimentTime"))
+    val total_op_data = ArrayBuffer[ArrayBuffer[OpData]]()
+    val threads = ArrayBuffer[Thread]()
+
+    for (i <- 0 until misc_config("numThreads").toInt) {
+      val op_data_array = ArrayBuffer[OpData]()
+      total_op_data.append(op_data_array)
+      threads.append(new Thread(new threadOps(database_name, misc_config.toMap, optimize_config,
+        insert_config, delete_config, read_config, table_configs.toMap, dates,
+        table_generator, op_generator, exec_dry_run, exec_experiment, total_num_commits,
+        total_num_aborts, op_data_array)))
+    }
+
+    // execute the dry run
+    exec_dry_run.set(true)
+    threads.foreach { thread =>
+      thread.start()
+    }
+    Thread.sleep(dry_run_time)
+
+    // execute the main experiment
+    exec_experiment.set(true)
+    exec_dry_run.set(false)
+    Thread.sleep(experiment_time)
+    exec_experiment.set(false)
+
+    threads.foreach { thread =>
+      thread.join()
+    }
+
+    // print the results
+    val summaryWriter = new FileWriter(new File(misc_config("summaryOutput")), true)
+    summaryWriter.write("{\"workloadRatio\":\"" + misc_config("workloadRatio") + "\", ")
+    summaryWriter.write("\"totalNumThreads\":" + misc_config("totalNumThreads") + ", ")
+    summaryWriter.write("\"version\":" + misc_config("version") + ", ")
+    summaryWriter.write("\"numCommits\":" + total_num_commits + ", ")
+    summaryWriter.write("\"numAborts\":" + total_num_aborts + ", ")
+    summaryWriter.write("\"throughput\":" +
+      (total_num_commits.get().toDouble * 1000) / experiment_time + ", ")
+    summaryWriter.write("\"dryRunTime\":" + dry_run_time / 1000 + ", ")
+    summaryWriter.write("\"experimentTime\":" + experiment_time / 1000 + ", ")
+    summaryWriter.write("\"numThreads\":" + misc_config("numThreads") + "}")
+    summaryWriter.write("\n")
+    summaryWriter.flush()
+    summaryWriter.close()
+
+    val opWriter = new FileWriter(new File(misc_config("opOutput")), true)
+    total_op_data.flatten.foreach { op_data : OpData =>
+      opWriter.write("{\"workloadRatio\":\"" + misc_config("workloadRatio") + "\", ")
+      opWriter.write("\"totalNumThreads\":" + misc_config("totalNumThreads") + ", ")
+      opWriter.write("\"version\":" + misc_config("version") + ", ")
+      opWriter.write("\"latency\":" + op_data.latency + ", ")
+      opWriter.write("\"dataSent\":" + op_data.data_sent + ", ")
+      opWriter.write("\"dataReceived\":" + op_data.data_received + ", ")
+      opWriter.write("\"opType\":" + op_data.op_type + ", ")
+      opWriter.write("\"misc\":\"" + op_data.misc + "\", ")
+      opWriter.write("\"committed\":" + op_data.committed + "}")
+      opWriter.write("\n")
+    }
+    opWriter.flush()
+    opWriter.close()
+
+  }
+
+  private class threadOps(database_name: String, misc_config: Map[String, String],
+                          optimize_config : OptimizeConfig, insert_config: InsertConfig,
+                          delete_config : DeleteConfig, read_config: ReadConfig,
+                          table_configs: Map[String, TableConfig],
+                          dates: Array[String], table_generator: TableGenerator, op_generator:
+                          OpGenerator, exec_dry_run: AtomicBoolean, exec_experiment: AtomicBoolean,
+                          total_num_commits: AtomicLong, total_num_aborts: AtomicLong,
+                          op_data_array : ArrayBuffer[OpData])
+    extends Runnable {
+
+    private val tree_address = misc_config("treeAddress")
+
+    private val tree_cat = new TreeExternalCatalog(tree_address)
+
+    private val sqlParser = new SparkSqlParser()
+
+    private var num_commits = 0
+    private var num_aborts = 0
+
+    override def run(): Unit = {
+      while (exec_dry_run.get()) {
+        runCycle(None)
+      }
+
+      while (exec_experiment.get()) {
+        val op_data = new OpData
+        op_data_array.append(op_data)
+        runCycle(Some(op_data))
+      }
+
+      total_num_commits.addAndGet(num_commits)
+      total_num_aborts.addAndGet(num_aborts)
+
+    }
+
+    // helper function for running a single cycle
+    private def runCycle(op_data : Option[OpData]): Unit = {
+      val op = op_generator.genOp()
+
+      val startTime = Instant.now()
+      val success = op match {
+        case 0 => optimizeOp(op_data)
+        case 1 => insertFact(op_data)
+        case 2 => insertDim(op_data)
+        case 3 => deleteOp(op_data)
+        case _ => readOp(op_data)
+      }
+      val endTime = Instant.now()
+
+      // if not dry run, collect the results
+      if (op_data.isDefined) {
+        op_data.get.committed = success
+        op_data.get.op_type = op
+        op_data.get.latency = Duration.between(startTime, endTime).toNanos()
+        if (success) {
+          num_commits += 1
+        }
+        else {
+          num_aborts += 1
+        }
+      }
+    }
+
+    private def dummyOp(): Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      tree_cat.commit(txn.get)
+    }
+
+    private def optimizeOp(op_data : Option[OpData]): Boolean = {
+      val read_txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_ONLY)
+      val write_txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+
+      val target_table_name = table_generator.genOptimizeTable()
+      val target_table_config = table_configs(target_table_name)
+      // get the target fact table. Is part of read-write txn as schema etc. should not change.
+      val target_table = tree_cat.getTable(database_name, target_table_config.name, write_txn,
+        Some(LockMode.LOCK_MODE_X))
+      // get the list of files to compact. Use read txn to avoid unnecessary conflicts
+      val old_files = tree_cat.listFilesToCompact(target_table, optimize_config.threshold.toLong,
+        read_txn)
+
+      val partition_groups = scala.collection.mutable.HashMap[CatalogTypes.TablePartitionSpec,
+        ArrayBuffer[CatalogTableFile]]()
+      // categorize the older files to appropriate partition groups
+      old_files.foreach { old_file =>
+        val partition_group = partition_groups.get(old_file.partitionValues)
+        if (partition_group.isDefined) {
+          partition_group.get += old_file
+        }
+        else {
+          val new_partition_group = ArrayBuffer[CatalogTableFile]()
+          new_partition_group += old_file
+          partition_groups.put(old_file.partitionValues, new_partition_group)
+        }
+      }
+
+      val merged_files = ArrayBuffer[CatalogTableFile]()
+      val new_files = ArrayBuffer[CatalogTableFile]()
+      for (partition_group <- partition_groups.values) {
+        if (partition_group.length > 1) {
+          var new_file = switchUUID(partition_group(0), UUID.randomUUID())
+          merged_files += partition_group(0)
+          for (i <- 1 until partition_group.length) {
+            if (new_file.size < optimize_config.threshold) {
+              new_file = mergeFiles(target_table, new_file, partition_group(i))
+            }
+            else {
+              new_files += new_file
+              new_file = switchUUID(partition_group(i), UUID.randomUUID())
+            }
+            merged_files += partition_group(i)
+          }
+          new_files += new_file
+        }
+      }
+
+      if (write_txn.get.isOK()) {
+        tree_cat.removeFiles(target_table, merged_files, write_txn)
+        tree_cat.addFiles(target_table, new_files, write_txn)
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += read_txn.get.data_sent
+        op_data.get.data_received += read_txn.get.data_received
+        op_data.get.data_sent += write_txn.get.data_sent
+        op_data.get.data_received += write_txn.get.data_received
+      }
+
+      tree_cat.commit(write_txn.get)
+
+    }
+
+    private def insertFact(op_data : Option[OpData]) : Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      // randomly choose a fact table, using the table generator
+      val dest_fact_table_name = table_generator.genInsertFactTable()
+      val dest_fact_table_config = table_configs(dest_fact_table_name)
+      // get the target fact table in IX mode
+      val dest_fact_table = tree_cat.getTable(database_name, dest_fact_table_config.name, txn,
+        Some(LockMode.LOCK_MODE_IX))
+      // column statistics
+      val col_stats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+      dest_fact_table_config.schema.foreach { attr_config =>
+        if (attr_config.key.isDefined) {
+          val dim_table_config = table_configs(attr_config.key.get)
+          val cardinality = dim_table_config.getWatermark().toInt
+          var min_sk = ThreadLocalRandom.current().nextInt(cardinality)
+          var max_sk = min_sk
+          val rand_sk = ThreadLocalRandom.current().nextInt(cardinality)
+          if (rand_sk < min_sk) {
+            min_sk = rand_sk
+          }
+          if (rand_sk > max_sk) {
+            max_sk = rand_sk
+          }
+
+          if (dim_table_config.business_id.isDefined && txn.get.isOK()) {
+            val filters = ArrayBuffer[Expression]()
+            val min_id = skToId(16, min_sk)
+            val max_id = skToId(16, max_sk)
+            val pred = f"${dim_table_config.business_id.get.name} >= '$min_id' and " +
+              f"${dim_table_config.business_id.get.name} <= '$max_id'"
+            filters.append(sqlParser.parseExpression(pred))
+            // get the dimension table
+            val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+              Some(LockMode.LOCK_MODE_IS))
+            // get the list of files from the dimension table
+            if (txn.get.isOK()) {
+              tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_S))
+            }
+          }
+          else if (txn.get.isOK()) {
+            // just get all the files of the dimension table
+            val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+              Some(LockMode.LOCK_MODE_IS))
+            // get the list of files from the dimension table
+            if (txn.get.isOK()) {
+              tree_cat.listFiles(table, txn, Some(LockMode.LOCK_MODE_S))
+            }
+          }
+
+          val col_stat = CatalogColumnStat(None, Some(min_sk.toString), Some(max_sk.toString),
+            Some(BigInt(0)), None, None, None, 1)
+          col_stats.put(attr_config.name, col_stat)
+
+        }
+        // for other attributes, generate random values and fill in the column statistics
+        else {
+          var min = ""
+          var max = ""
+          // generate random min and max string/int
+          attr_config.data_type match {
+            case "VARCHAR" =>
+              min = genRandomVarChar(attr_config.cardinality.get)
+              val temp = genRandomVarChar(attr_config.cardinality.get)
+              if (temp < min) {
+                max = min
+                min = temp
+              }
+              else {
+                max = temp
+              }
+            case "DATE" =>
+              min = dates(ThreadLocalRandom.current().nextInt(dates.length))
+              val temp = dates(ThreadLocalRandom.current().nextInt(dates.length))
+              if (temp < min) {
+                max = min
+                min = temp
+              }
+              else {
+                max = temp
+              }
+            case "DECIMAL" =>
+              val min_decimal = genRandomDecimal(attr_config.cardinality.get)
+              val temp_decimal = genRandomDecimal(attr_config.cardinality.get)
+              if (temp_decimal < min_decimal) {
+                max = min_decimal.toString
+                min = temp_decimal.toString
+              }
+              else {
+                min = min_decimal.toString
+                max = temp_decimal.toString
+              }
+            case "INT" =>
+              min = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get.toInt).toString
+              val temp = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get.toInt)
+                .toString
+              if (temp < min) {
+                max = min
+                min = temp
+              }
+              else {
+                max = temp
+              }
+          }
+          val col_stat = CatalogColumnStat(None, Some(min), Some(max),
+            Some(BigInt(0)), None, None, None, 1)
+          col_stats.put(attr_config.name, col_stat)
+
+        }
+
+      }
+      // Now, insert to fact table a single file with appropriate number of rows, file stats etc.
+      val row_count = (insert_config.insert_ratio * dest_fact_table_config.num_rows).toInt
+      val size_in_bytes = row_count * dest_fact_table_config.bytes_per_row
+      val file_stats = CatalogStatistics(size_in_bytes, Some(BigInt(row_count)), col_stats.toMap)
+
+      val dest_part_spec = scala.collection.mutable.Map[String, String]()
+      dest_fact_table.partitionSchema.indices.foreach { i =>
+        val partition_col = dest_fact_table.partitionSchema(i)
+        // partition col follows uniform distribution for now
+        if (partition_col.dataType.isInstanceOf[IntegralType]) {
+          dest_part_spec.put(partition_col.name,
+            ThreadLocalRandom.current().nextInt(dates.length).toString)
+        }
+        // partition col follows uniform distribution for now
+        if (partition_col.dataType == DateType) {
+          dest_part_spec.put(partition_col.name,
+            dates(ThreadLocalRandom.current().nextInt(dates.length)))
+        }
+      }
+
+      val immutable_dest_part_spec = dest_part_spec.toMap
+      val fact_table_files = ArrayBuffer[CatalogTableFile]()
+      val file_path = dest_fact_table.location.getPath + "/" + UUID.randomUUID()
+      val storage = CatalogStorageFormat(Some(new URI(file_path)),
+        dest_fact_table.storage.inputFormat, dest_fact_table.storage.outputFormat,
+        dest_fact_table.storage.serde, false, dest_fact_table.properties)
+      fact_table_files.append(CatalogTableFile(storage, immutable_dest_part_spec,
+        file_stats.sizeInBytes.toLong, stats = Some(file_stats)))
+      // if the fact table is partitioned, get the corresponding partition
+      if (dest_fact_table.partitionColumnNames.nonEmpty && txn.get.isOK()) {
+        val partition = tree_cat.getPartition(dest_fact_table, immutable_dest_part_spec, txn,
+          Some(LockMode.LOCK_MODE_X))
+      }
+
+      // finally add the file to the chosen partition
+      if (txn.get.isOK()) {
+        tree_cat.addFiles(dest_fact_table, fact_table_files, txn)
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      tree_cat.commit(txn.get)
+    }
+
+    private def insertDim(op_data : Option[OpData]) : Boolean = {
+      // generate dimension tables
+      val dest_dim_table_names = table_generator.genInsertDimTables()
+      // increment the identity sk as an independent transaction first
+      val min_id_sk = scala.collection.mutable.Map[String, Long]()
+      val max_id_sk = scala.collection.mutable.Map[String, Long]()
+      dest_dim_table_names.foreach { dest_dim_table_name =>
+        val dest_dim_table_config = table_configs(dest_dim_table_name)
+        val num_new_dim_records = (insert_config.insert_ratio * dest_dim_table_config
+          .num_rows).toLong
+        val min_sk = tree_cat.fetchAddAttr(database_name, dest_dim_table_config.name,
+          dest_dim_table_config.sk.get.name, num_new_dim_records).get.toInt + 1
+        val max_sk = min_sk + num_new_dim_records
+        min_id_sk(dest_dim_table_name) = min_sk
+        max_id_sk(dest_dim_table_name) = max_sk
+      }
+
+      // start of insert operation
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+
+      dest_dim_table_names.foreach { dest_dim_table_name =>
+        val dest_dim_table_config = table_configs(dest_dim_table_name)
+        if (txn.get.isOK()) {
+          // get the target dim table
+          val dest_dim_table = tree_cat.getTable(database_name, dest_dim_table_config.name, txn,
+            Some(LockMode.LOCK_MODE_X))
+          if (txn.get.isOK()) {
+            val dest_table_new_files = ArrayBuffer[CatalogTableFile]()
+            // column statistics
+            val col_stats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+            dest_dim_table_config.schema.foreach { attr_config =>
+              if (attr_config.key.isDefined) {
+                val dim_table_config = table_configs(attr_config.key.get)
+                val cardinality = dim_table_config.getWatermark().toInt
+                // range of sk that are written out
+                var min_sk = ThreadLocalRandom.current().nextInt(cardinality)
+                var max_sk = min_sk
+
+                // increment the watermark only once, for the surrogate key
+                if (dest_dim_table_name == attr_config.key.get) {
+                  if (attr_config.name.endsWith("_sk")) {
+                    // for destination dimension table, write range is precisely
+                    // the newly allocated range of sks
+                    min_sk = min_id_sk(dest_dim_table_name).toInt
+                    max_sk = max_id_sk(dest_dim_table_name).toInt
+                  }
+                }
+                else {
+                  val rand_sk = ThreadLocalRandom.current().nextInt(cardinality)
+                  if (rand_sk < min_sk) {
+                    min_sk = rand_sk
+                  }
+                  if (rand_sk > max_sk) {
+                    max_sk = rand_sk
+                  }
+
+                }
+
+                if (attr_config.data_type == "DATE") {
+                  // adjust the date range according to the cardinality
+                  min_sk = min_sk * dates.length / cardinality
+                  max_sk = max_sk * dates.length / cardinality
+                  val col_stat = CatalogColumnStat(None, Some(dates(min_sk)),
+                    Some(dates(max_sk)),
+                    Some(BigInt(0)), None, None, None, 1)
+                  col_stats.put(attr_config.name, col_stat)
+                }
+                else if (dim_table_config.business_id.isDefined) {
+                  val filters = ArrayBuffer[Expression]()
+                  val min_id = skToId(16, min_sk)
+                  val max_id = skToId(16, max_sk)
+                  val pred = f"${dim_table_config.business_id.get.name} >= '$min_id' and " +
+                    f"${dim_table_config.business_id.get.name} <= '$max_id'"
+                  filters.append(sqlParser.parseExpression(pred))
+
+                  if (dest_dim_table_name == attr_config.key.get) {
+                    if (attr_config.name.endsWith("_sk") && txn.get.isOK()) {
+                      // get the dimension table
+                      val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+                        Some(LockMode.LOCK_MODE_IS))
+                      if (txn.get.isOK()) {
+                        tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_X))
+                        // populate column statistics for both surrogate key and business id
+                        val col_stat = CatalogColumnStat(None, Some(min_sk.toString),
+                          Some(max_sk.toString), Some(BigInt(0)), None, None, None, 1)
+                        col_stats.put(attr_config.name, col_stat)
+                        val id_col_stat = CatalogColumnStat(None, Some(min_id),
+                          Some(max_id), Some(BigInt(0)), None, None, None, 1)
+                        col_stats.put(attr_config.name.stripSuffix("_sk") + "_id", id_col_stat)
+                      }
+                    }
+                  }
+                  else if (txn.get.isOK()) {
+                    // get the dimension table
+                    val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+                      Some(LockMode.LOCK_MODE_IS))
+                    if (txn.get.isOK()) {
+                      // get the list of files from the dimension table
+                      tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_S))
+                      val col_stat = CatalogColumnStat(None, Some(min_sk.toString),
+                        Some(max_sk.toString), Some(BigInt(0)), None, None, None, 1)
+                      col_stats.put(attr_config.name, col_stat)
+                    }
+                  }
+                }
+                else if (txn.get.isOK()) {
+                  val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+                    Some(LockMode.LOCK_MODE_IS))
+                  if (txn.get.isOK()) {
+                    // just get all the files of the dimension table
+                    tree_cat.listFiles(table, txn, Some(LockMode.LOCK_MODE_S))
+                    val col_stat = CatalogColumnStat(None, Some(min_sk.toString),
+                      Some(max_sk.toString), Some(BigInt(0)), None, None, None, 1)
+                    col_stats.put(attr_config.name, col_stat)
+                  }
+                }
+              }
+              // for other attributes, generate random values and fill in the column statistics
+              else {
+                var min = ""
+                var max = ""
+                // generate random min and max string/int
+                attr_config.data_type match {
+                  case "VARCHAR" =>
+                    min = genRandomVarChar(attr_config.cardinality.get)
+                    val temp = genRandomVarChar(attr_config.cardinality.get)
+                    if (temp < min) {
+                      max = min
+                      min = temp
+                    }
+                    else {
+                      max = temp
+                    }
+                  case "DATE" =>
+                    min = dates(ThreadLocalRandom.current().nextInt(dates.length))
+                    val temp = dates(ThreadLocalRandom.current().nextInt(dates.length))
+                    if (temp < min) {
+                      max = min
+                      min = temp
+                    }
+                    else {
+                      max = temp
+                    }
+                  case "DECIMAL" =>
+                    val min_decimal = genRandomDecimal(attr_config.cardinality.get)
+                    val temp_decimal = genRandomDecimal(attr_config.cardinality.get)
+                    if (temp_decimal < min_decimal) {
+                      max = min_decimal.toString
+                      min = temp_decimal.toString
+                    }
+                    else {
+                      min = min_decimal.toString
+                      max = temp_decimal.toString
+                    }
+                  case "INT" =>
+                    min = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get.toInt)
+                      .toString
+                    val temp = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get
+                      .toInt).toString
+                    if (temp < min) {
+                      max = min
+                      min = temp
+                    }
+                    else {
+                      max = temp
+                    }
+
+                }
+
+                val col_stat = CatalogColumnStat(None, Some(min), Some(max),
+                  Some(BigInt(0)), None, None, None, 1)
+                col_stats.put(attr_config.name, col_stat)
+
+              }
+            }
+
+            if (txn.get.isOK()) {
+              // Now, insert to dim table a single file with appropriate number of rows, file stats
+              // etc.
+              val row_count = (insert_config.insert_ratio * dest_dim_table_config.num_rows).toInt
+              val size_in_bytes = row_count * dest_dim_table_config.bytes_per_row
+              val file_stats = CatalogStatistics(size_in_bytes, Some(BigInt(row_count)),
+                col_stats.toMap)
+
+              val dest_part_spec = scala.collection.mutable.Map[String, String]()
+              dest_dim_table.partitionSchema.indices.foreach { i =>
+                val partition_col = dest_dim_table.partitionSchema(i)
+                // partition col follows uniform distribution for now
+                if (partition_col.dataType.isInstanceOf[IntegralType]) {
+                  dest_part_spec.put(partition_col.name,
+                    ThreadLocalRandom.current().nextInt(dates.length).toString)
+                }
+                // partition col follows uniform distribution for now
+                if (partition_col.dataType == DateType) {
+                  dest_part_spec.put(partition_col.name,
+                    dates(ThreadLocalRandom.current().nextInt(dates.length)))
+                }
+              }
+
+              val immutable_dest_part_spec = dest_part_spec.toMap
+              val file_path = dest_dim_table.location.getPath + "/" + UUID.randomUUID()
+              val storage = CatalogStorageFormat(Some(new URI(file_path)),
+                dest_dim_table.storage.inputFormat, dest_dim_table.storage.outputFormat,
+                dest_dim_table.storage.serde, false, dest_dim_table.properties)
+              dest_table_new_files.append(CatalogTableFile(storage, immutable_dest_part_spec,
+                file_stats.sizeInBytes.toLong, stats = Some(file_stats)))
+              // finally add batch of files to the dest dimension table
+              tree_cat.addFiles(dest_dim_table, dest_table_new_files, txn)
+            }
+          }
+        }
+      }
+
+      val success = tree_cat.commit(txn.get)
+
+      max_id_sk.foreach { entry =>
+        table_configs(entry._1).setWatermark(entry._2)
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      success
+    }
+
+    private def deleteOp(op_data : Option[OpData]): Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      val target_table_names = table_generator.genDeleteTable()
+
+      val min_sk = ThreadLocalRandom.current().nextInt(dates.length)
+      val max_sk = min_sk + delete_config.date_range - 1
+      val min_sk_str = "%012d".format(min_sk)
+      val max_sk_str = "%012d".format(max_sk)
+      target_table_names.foreach{ target_table_name =>
+        if (txn.get.isOK()) {
+          // get the target fact table.
+          val target_table = tree_cat.getTable(database_name, target_table_name, txn,
+            Some(LockMode.LOCK_MODE_IX))
+          val partition_column = target_table.partitionSchema.head
+          val partition_col_name = partition_column.name
+          val filters = ArrayBuffer[Expression]()
+          val pred = f"$partition_col_name >= '$partition_col_name=$min_sk_str' and " +
+            f"$partition_col_name <= '$partition_col_name=$max_sk_str'"
+          filters.append(sqlParser.parseExpression(pred))
+
+          if (txn.get.isOK()) {
+            val files = tree_cat.listFilesWithStatsByFilter(target_table, filters, txn,
+              Some(LockMode.LOCK_MODE_X))
+            tree_cat.removeFiles(target_table, files, txn)
+          }
+        }
+
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      tree_cat.commit(txn.get)
+    }
+
+    private def readOp(op_data : Option[OpData]): Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_ONLY)
+      val query_config = table_generator.genReadQuery()
+      val table_jsons = query_config._1.elements().next()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val table = tree_cat.getTable(database_name, table_name, txn,
+            Some(LockMode.LOCK_MODE_NL))
+          tree_cat.listFiles(table, txn, Some(LockMode.LOCK_MODE_NL))
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val table = tree_cat.getTable(database_name, table_name, txn,
+            Some(LockMode.LOCK_MODE_NL))
+          val partition_column = table.partitionSchema.head
+          val partition_col_name = partition_column.name
+          val filters = ArrayBuffer[Expression]()
+
+          val partition_range = table_json.get("range")
+
+          if (partition_range.size() == 1) {
+            val sk = "%012d".format(partition_range.get(0).asInt())
+            val pred = f"$partition_col_name == '$partition_col_name=$sk'"
+            filters.append(sqlParser.parseExpression(pred))
+          }
+          else if (partition_range.size() == 2) {
+            val min_sk = "%012d".format(partition_range.get(0).asInt())
+            val max_sk = "%012d".format(partition_range.get(1).asInt())
+            val pred = f"$partition_col_name >= '$partition_col_name=$min_sk' and " +
+              f"$partition_col_name <= '$partition_col_name=$max_sk'"
+            filters.append(sqlParser.parseExpression(pred))
+          }
+
+          tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_NL))
+
+        }
+
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.misc = query_config._2.toString
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      tree_cat.commit(txn.get)
+
+    }
+  }
+
+  private def genRandomDecimal(num_digits : Long) : Int = {
+    ThreadLocalRandom.current().nextInt(math.pow(10, num_digits - 4).toInt)
+  }
+
+  private def genRandomVarChar(max_length : Long) : String = {
+    val length = ThreadLocalRandom.current().nextInt(max_length.toInt)
+    val char_buf = ArrayBuffer.fill(length)('A')
+    for (i <- 0 until length) {
+      char_buf(i) = (ThreadLocalRandom.current().nextInt(26) + 65).toChar
+    }
+    char_buf.mkString
+  }
+
+  private def skToId(length : Int, sk : Int) : String = {
+    val char_buf = ArrayBuffer.fill(length)('A')
+    var quotient = sk
+    var cur_length = 0
+    while (quotient > 0) {
+      val remainder = quotient % 26
+      quotient = quotient / 26
+      cur_length += 1
+      char_buf(length - cur_length) = (remainder + 65).toChar
+    }
+
+    char_buf.mkString
+
+  }
+
+  private def convertToMilliseconds(time : String): Int = {
+    val parts = time.split(":").map(_.toInt)
+    val hours = parts(0)
+    val minutes = parts(1)
+    val seconds = parts(2)
+    (hours * 3600 + minutes * 60 + seconds) * 1000
+  }
+
+  private def switchUUID(file: CatalogTableFile, uuid: UUID): CatalogTableFile = {
+    val old_file_path = file.storage.locationUri.get.toString
+    val new_file_path = Some(new URI(old_file_path.substring(0, old_file_path.lastIndexOf('/')
+      + 1) + uuid))
+    val file_storage = file.storage
+    val new_storage = CatalogStorageFormat(new_file_path, file_storage.inputFormat,
+      file_storage.outputFormat, file_storage.serde, file_storage.compressed,
+      file_storage.properties)
+    CatalogTableFile(new_storage, file.partitionValues, file.size, System.currentTimeMillis,
+      file.stats, file.tags)
+  }
+
+  // merges src_file to dest_file, including all the stats etc.
+  private def mergeFiles(table: CatalogTable, dest_file: CatalogTableFile,
+                         src_file: CatalogTableFile): CatalogTableFile = {
+    val stats = mergeStats(table, dest_file.stats.get, src_file.stats.get)
+    CatalogTableFile(dest_file.storage, dest_file.partitionValues, dest_file.size + src_file.size,
+      System.currentTimeMillis, Some(stats), dest_file.tags)
+  }
+
+  private def mergeStats(table : CatalogTable, base : CatalogStatistics,
+                 delta: CatalogStatistics): CatalogStatistics = {
+    val sizeInBytes = base.sizeInBytes + delta.sizeInBytes
+    val rowCount = {
+      if (base.rowCount.isDefined && delta.rowCount.isDefined) {
+        Some(base.rowCount.get + delta.rowCount.get)
+      }
+      else {
+        None
+      }
+    }
+    val colStats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+    table.schema.foreach { attr =>
+      val mergedColStat = mergeColStats(attr, base.colStats.get(attr.name),
+        delta.colStats.get(attr.name))
+      if (mergedColStat.isDefined) {
+        colStats.put(attr.name, mergedColStat.get)
+      }
+    }
+    CatalogStatistics(sizeInBytes, rowCount, colStats.toMap)
+  }
+
+  // we assume that delta is always more "complete" than base
+  private def mergeColStats(attr: StructField, base: Option[CatalogColumnStat],
+                            delta: Option[CatalogColumnStat]) : Option[CatalogColumnStat] = {
+
+    if (base.isDefined) {
+      if (delta.isDefined) {
+        val min = {
+          if (base.get.min.isDefined && delta.get.min.isDefined) {
+            attr.dataType match {
+              case _: IntegralType =>
+                Some(base.get.min.get.toInt.min(delta.get.min.get.toInt).toString)
+              case _: FractionalType =>
+                val min_val = base.get.min.get.toDouble.max(delta.get.min.get.toDouble)
+                Some(f"$min_val%.2f")
+              case _ =>
+                Some(if (base.get.min.get < delta.get.min.get) base.get.min.get
+                else delta.get.min.get)
+            }
+          }
+          else {
+            None
+          }
+        }
+        val max = {
+          if (base.get.max.isDefined && delta.get.max.isDefined) {
+            attr.dataType match {
+              case _: IntegralType =>
+                Some(base.get.max.get.toInt.max(delta.get.max.get.toInt).toString)
+              case _: FractionalType =>
+                val max_val = base.get.max.get.toDouble.max(delta.get.max.get.toDouble)
+                Some(f"$max_val%.2f")
+              case _ =>
+                Some(if (base.get.max.get > delta.get.max.get) base.get.max.get
+                else delta.get.max.get)
+            }
+          }
+          else {
+            None
+          }
+        }
+        val nullCount = {
+          if (base.get.nullCount.isDefined && delta.get.nullCount.isDefined) {
+            Some(base.get.nullCount.get + delta.get.nullCount.get)
+          }
+          else {
+            None
+          }
+        }
+        Some(CatalogColumnStat(None, min, max, nullCount, None, None, None, 1))
+      }
+      else {
+        base
+      }
+    }
+    else if (delta.isDefined) {
+      delta
+    }
+    else {
+      None
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/exp/src/main/scala/org/apache/spark/exp/ConcurrencyExperiment2.scala b/exp/src/main/scala/org/apache/spark/exp/ConcurrencyExperiment2.scala
new file mode 100644
index 00000000000..2c8cf3d0a37
--- /dev/null
+++ b/exp/src/main/scala/org/apache/spark/exp/ConcurrencyExperiment2.scala
@@ -0,0 +1,962 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.exp
+
+import java.io.{File, FileWriter}
+import java.net.URI
+import java.time.Duration
+import java.time.Instant
+import java.time.LocalDate
+import java.time.format.DateTimeFormatter
+import java.util.UUID
+import java.util.concurrent.ThreadLocalRandom
+import java.util.concurrent.atomic.{AtomicBoolean, AtomicLong}
+
+import scala.collection.mutable.ArrayBuffer
+import scala.io.Source
+
+import com.fasterxml.jackson.databind.ObjectMapper
+import com.fasterxml.jackson.databind.node.JsonNodeType
+
+import org.apache.spark.sql.catalyst.catalog.{CatalogColumnStat, CatalogStatistics, CatalogStorageFormat, CatalogTable, CatalogTableFile, CatalogTypes}
+import org.apache.spark.sql.catalyst.expressions.Expression
+import org.apache.spark.sql.execution.SparkSqlParser
+import org.apache.spark.sql.types.{DateType, FractionalType, IntegralType, StructField}
+import org.apache.spark.tree.TreeExternalCatalog
+import org.apache.spark.tree.grpc.Grpccatalog.LockMode
+import org.apache.spark.tree.grpc.Grpccatalog.TxnMode
+
+
+//  class TableGenerator(fact_weights : Map[String, Int], dimension_weights : Map[String, Int]) {
+//    val cumulative_fact_weights: List[(String, Int)] = fact_weights.toList.scanLeft(("", 0)) {
+//      case ((_, cumulative), (string, weight)) => (string, cumulative + weight)
+//    }.tail
+//
+//    private val total_fact_weight = cumulative_fact_weights.last._2
+//
+//    val cumulative_dimension_weights: List[(String, Int)] = dimension_weights.toList
+//    .scanLeft(("", 0))
+//    {
+//      case ((_, cumulative), (string, weight)) => (string, cumulative + weight)
+//    }.tail
+//
+//    private val total_dimension_weight = cumulative_dimension_weights.last._2
+//
+//    def genFactTable() : String = {
+//      val random_val = ThreadLocalRandom.current().nextInt(total_fact_weight)
+//      cumulative_fact_weights.find {
+//        case (_, cumulative) => random_val < cumulative
+//      }.map(_._1).get
+//    }
+//
+//    def genDimensionTable() : String = {
+//      val random_val = ThreadLocalRandom.current().nextInt(total_dimension_weight)
+//      cumulative_dimension_weights.find {
+//        case (_, cumulative) => random_val < cumulative
+//      }.map(_._1).get
+//    }
+//
+//  }
+
+
+object ConcurrencyExperiment2 {
+  val misc_config = scala.collection.mutable.Map.empty[String, String]
+  misc_config.put("summaryOutput", "/tmp/concurrency2-summary.json")
+  misc_config.put("opOutput", "/tmp/concurrency2-op.json")
+  misc_config.put("dryRunTime", "00:00:30")
+  misc_config.put("experimentTime", "00:05:00")
+  misc_config.put("numThreads", "10")
+  misc_config.put("totalNumThreads", "30")
+  misc_config.put("version", "1")
+  // Ratio is optimize:insertfact:insertdim:delete:read operations in order
+  misc_config.put("workloadRatio", "2:288:24:1:315")
+  misc_config.put("dbDist", "2:2:2:2:2")
+  misc_config.put("scaleFactor", "100T")
+  misc_config.put("treeAddress", "localhost:9876")
+  misc_config.put("startDate", "1998-01-01")
+  misc_config.put("endDate", "2003-12-31")
+
+  def main(args: Array[String]): Unit = {
+    if (args.size != 2) {
+      print("Usage: spark-class org.apache.spark.exp.ConcurrencyExperiment2 " +
+        "<dataConfig> <workloadConfig>\n")
+      return
+    }
+
+    val json_parser = new ObjectMapper
+    // read in data config
+    val data_config_json = json_parser.readTree(Source.fromFile(args(0)).mkString)
+    // read in workload config
+    val workload_config_json = json_parser.readTree(Source.fromFile(args(1)).mkString)
+
+    val database_names = ArrayBuffer[String]()
+    data_config_json.get("databaseNames").forEach { database_name =>
+      database_names += database_name.asText()
+    }
+
+    // initialize misc config map
+    workload_config_json.get("misc").fields().forEachRemaining { config =>
+      misc_config.put(config.getKey, config.getValue.asText())
+    }
+
+    val db_dist: ArrayBuffer[Int] = ArrayBuffer(misc_config("dbDist").split(":").map(_.toInt): _*)
+    val optimize_config = new OptimizeConfig(workload_config_json.get("optimize"))
+    val insert_config = new InsertConfig(workload_config_json.get("insert"))
+    val delete_config = new DeleteConfig(workload_config_json.get("delete"))
+    val read_config = new ReadConfig(workload_config_json.get("read"))
+
+    val table_configs = scala.collection.mutable.HashMap[String, TableConfig]()
+    data_config_json.get("tables").forEach { table_json =>
+      table_configs.put(table_json.get("name").asText(), new TableConfig(table_json,
+        misc_config("scaleFactor")))
+    }
+
+    // initialize the dates
+    val date_formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
+    val start_date = LocalDate.parse(misc_config("startDate"), date_formatter)
+    val end_date = LocalDate.parse(misc_config("endDate"), date_formatter)
+    val dates: Array[String] = Iterator.iterate(start_date)(_ plusDays 1) // Generate dates
+      .takeWhile(!_.isAfter(end_date)) // Stop when exceeding the end date
+      .map(_.format(date_formatter)) // Convert to formatted strings
+      .toArray
+
+    // Initialize the table generator. Probabilities are weighed equally for now
+    val table_generator = new TableGenerator(insert_config, optimize_config,
+      delete_config, read_config)
+    val op_generator = new OpGenerator(misc_config("workloadRatio"))
+
+    val exec_dry_run = new AtomicBoolean(false)
+    val exec_experiment = new AtomicBoolean(false)
+    val total_num_commits = new AtomicLong(0)
+    val total_num_aborts = new AtomicLong(0)
+    val dry_run_time = convertToMilliseconds(misc_config("dryRunTime"))
+    val experiment_time = convertToMilliseconds(misc_config("experimentTime"))
+    val total_op_data = ArrayBuffer[ArrayBuffer[OpData]]()
+    val threads = ArrayBuffer[Thread]()
+
+    for (i <- 0 until misc_config("numThreads").toInt) {
+      val idx = db_dist.indexWhere(_ != 0)
+      if (idx != -1) {
+        db_dist(idx) -= 1
+        val op_data_array = ArrayBuffer[OpData]()
+        total_op_data.append(op_data_array)
+        threads.append(new Thread(new threadOps(database_names(idx), misc_config.toMap,
+          optimize_config, insert_config, delete_config, read_config,
+          table_configs.toMap, dates, table_generator, op_generator, exec_dry_run,
+          exec_experiment, total_num_commits, total_num_aborts, op_data_array)))
+      }
+    }
+
+    // execute the dry run
+    exec_dry_run.set(true)
+    threads.foreach { thread =>
+      thread.start()
+    }
+    Thread.sleep(dry_run_time)
+
+    // execute the main experiment
+    exec_experiment.set(true)
+    exec_dry_run.set(false)
+    Thread.sleep(experiment_time)
+    exec_experiment.set(false)
+
+    threads.foreach { thread =>
+      thread.join()
+    }
+
+    // print the results
+    val summaryWriter = new FileWriter(new File(misc_config("summaryOutput")), true)
+    summaryWriter.write("{\"workloadRatio\":\"" + misc_config("workloadRatio") + "\", ")
+    summaryWriter.write("\"totalNumThreads\":" + misc_config("totalNumThreads") + ", ")
+    summaryWriter.write("\"version\":" + misc_config("version") + ", ")
+    summaryWriter.write("\"numCommits\":" + total_num_commits + ", ")
+    summaryWriter.write("\"numAborts\":" + total_num_aborts + ", ")
+    summaryWriter.write("\"throughput\":" +
+      (total_num_commits.get().toDouble * 1000) / experiment_time + ", ")
+    summaryWriter.write("\"dryRunTime\":" + dry_run_time / 1000 + ", ")
+    summaryWriter.write("\"experimentTime\":" + experiment_time / 1000 + ", ")
+    summaryWriter.write("\"numThreads\":" + misc_config("numThreads") + "}")
+    summaryWriter.write("\n")
+    summaryWriter.flush()
+    summaryWriter.close()
+
+    val opWriter = new FileWriter(new File(misc_config("opOutput")), true)
+    total_op_data.flatten.foreach { op_data : OpData =>
+      opWriter.write("{\"workloadRatio\":\"" + misc_config("workloadRatio") + "\", ")
+      opWriter.write("\"totalNumThreads\":" + misc_config("totalNumThreads") + ", ")
+      opWriter.write("\"version\":" + misc_config("version") + ", ")
+      opWriter.write("\"latency\":" + op_data.latency + ", ")
+      opWriter.write("\"dataSent\":" + op_data.data_sent + ", ")
+      opWriter.write("\"dataReceived\":" + op_data.data_received + ", ")
+      opWriter.write("\"opType\":" + op_data.op_type + ", ")
+      opWriter.write("\"misc\":\"" + op_data.misc + "\", ")
+      opWriter.write("\"committed\":" + op_data.committed + "}")
+      opWriter.write("\n")
+    }
+    opWriter.flush()
+    opWriter.close()
+
+  }
+
+  private class threadOps(database_name: String, misc_config: Map[String, String],
+                          optimize_config : OptimizeConfig, insert_config: InsertConfig,
+                          delete_config : DeleteConfig, read_config: ReadConfig,
+                          table_configs: Map[String, TableConfig],
+                          dates: Array[String], table_generator: TableGenerator, op_generator:
+                          OpGenerator, exec_dry_run: AtomicBoolean, exec_experiment: AtomicBoolean,
+                          total_num_commits: AtomicLong, total_num_aborts: AtomicLong,
+                          op_data_array : ArrayBuffer[OpData])
+    extends Runnable {
+
+    private val tree_address = misc_config("treeAddress")
+
+    private val tree_cat = new TreeExternalCatalog(tree_address)
+
+    private val sqlParser = new SparkSqlParser()
+
+    private var num_commits = 0
+    private var num_aborts = 0
+
+    override def run(): Unit = {
+      while (exec_dry_run.get()) {
+        runCycle(None)
+      }
+
+      while (exec_experiment.get()) {
+        val op_data = new OpData
+        op_data_array.append(op_data)
+        runCycle(Some(op_data))
+      }
+
+      total_num_commits.addAndGet(num_commits)
+      total_num_aborts.addAndGet(num_aborts)
+
+    }
+
+    // helper function for running a single cycle
+    private def runCycle(op_data : Option[OpData]): Unit = {
+      val op = op_generator.genOp()
+
+      val startTime = Instant.now()
+      val success = op match {
+        case 0 => optimizeOp(op_data)
+        case 1 => insertFact(op_data)
+        case 2 => insertDim(op_data)
+        case 3 => deleteOp(op_data)
+        case _ => readOp(op_data)
+      }
+      val endTime = Instant.now()
+
+      // if not dry run, collect the results
+      if (op_data.isDefined) {
+        op_data.get.committed = success
+        op_data.get.op_type = op
+        op_data.get.latency = Duration.between(startTime, endTime).toNanos()
+        if (success) {
+          num_commits += 1
+        }
+        else {
+          num_aborts += 1
+        }
+      }
+    }
+
+    private def dummyOp(): Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      tree_cat.commit(txn.get)
+    }
+
+    private def optimizeOp(op_data : Option[OpData]): Boolean = {
+      val read_txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_ONLY)
+      val write_txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+
+      val target_table_name = table_generator.genOptimizeTable()
+      val target_table_config = table_configs(target_table_name)
+      // get the target fact table. Is part of read-write txn as schema etc. should not change.
+      val target_table = tree_cat.getTable(database_name, target_table_config.name, write_txn,
+        Some(LockMode.LOCK_MODE_X))
+      // get the list of files to compact. Use read txn to avoid unnecessary conflicts
+      val old_files = tree_cat.listFilesToCompact(target_table, optimize_config.threshold.toLong,
+        read_txn)
+
+      val partition_groups = scala.collection.mutable.HashMap[CatalogTypes.TablePartitionSpec,
+        ArrayBuffer[CatalogTableFile]]()
+      // categorize the older files to appropriate partition groups
+      old_files.foreach { old_file =>
+        val partition_group = partition_groups.get(old_file.partitionValues)
+        if (partition_group.isDefined) {
+          partition_group.get += old_file
+        }
+        else {
+          val new_partition_group = ArrayBuffer[CatalogTableFile]()
+          new_partition_group += old_file
+          partition_groups.put(old_file.partitionValues, new_partition_group)
+        }
+      }
+
+      val merged_files = ArrayBuffer[CatalogTableFile]()
+      val new_files = ArrayBuffer[CatalogTableFile]()
+      for (partition_group <- partition_groups.values) {
+        if (partition_group.length > 1) {
+          var new_file = switchUUID(partition_group(0), UUID.randomUUID())
+          merged_files += partition_group(0)
+          for (i <- 1 until partition_group.length) {
+            if (new_file.size < optimize_config.threshold) {
+              new_file = mergeFiles(target_table, new_file, partition_group(i))
+            }
+            else {
+              new_files += new_file
+              new_file = switchUUID(partition_group(i), UUID.randomUUID())
+            }
+            merged_files += partition_group(i)
+          }
+          new_files += new_file
+        }
+      }
+
+      if (write_txn.get.isOK()) {
+        tree_cat.removeFiles(target_table, merged_files, write_txn)
+        tree_cat.addFiles(target_table, new_files, write_txn)
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += read_txn.get.data_sent
+        op_data.get.data_received += read_txn.get.data_received
+        op_data.get.data_sent += write_txn.get.data_sent
+        op_data.get.data_received += write_txn.get.data_received
+      }
+
+      tree_cat.commit(write_txn.get)
+
+    }
+
+    private def insertFact(op_data : Option[OpData]) : Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      // randomly choose a fact table, using the table generator
+      val dest_fact_table_name = table_generator.genInsertFactTable()
+      val dest_fact_table_config = table_configs(dest_fact_table_name)
+      // get the target fact table in IX mode
+      val dest_fact_table = tree_cat.getTable(database_name, dest_fact_table_config.name, txn,
+        Some(LockMode.LOCK_MODE_IX))
+      // column statistics
+      val col_stats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+      dest_fact_table_config.schema.foreach { attr_config =>
+        if (attr_config.key.isDefined) {
+          val dim_table_config = table_configs(attr_config.key.get)
+          val cardinality = dim_table_config.getWatermark().toInt
+          var min_sk = ThreadLocalRandom.current().nextInt(cardinality)
+          var max_sk = min_sk
+          val rand_sk = ThreadLocalRandom.current().nextInt(cardinality)
+          if (rand_sk < min_sk) {
+            min_sk = rand_sk
+          }
+          if (rand_sk > max_sk) {
+            max_sk = rand_sk
+          }
+
+          if (dim_table_config.business_id.isDefined && txn.get.isOK()) {
+            val filters = ArrayBuffer[Expression]()
+            val min_id = skToId(16, min_sk)
+            val max_id = skToId(16, max_sk)
+            val pred = f"${dim_table_config.business_id.get.name} >= '$min_id' and " +
+              f"${dim_table_config.business_id.get.name} <= '$max_id'"
+            filters.append(sqlParser.parseExpression(pred))
+            // get the dimension table
+            val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+              Some(LockMode.LOCK_MODE_IS))
+            // get the list of files from the dimension table
+            if (txn.get.isOK()) {
+              tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_S))
+            }
+          }
+          else if (txn.get.isOK()) {
+            // just get all the files of the dimension table
+            val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+              Some(LockMode.LOCK_MODE_IS))
+            // get the list of files from the dimension table
+            if (txn.get.isOK()) {
+              tree_cat.listFiles(table, txn, Some(LockMode.LOCK_MODE_S))
+            }
+          }
+
+          val col_stat = CatalogColumnStat(None, Some(min_sk.toString), Some(max_sk.toString),
+            Some(BigInt(0)), None, None, None, 1)
+          col_stats.put(attr_config.name, col_stat)
+
+        }
+        // for other attributes, generate random values and fill in the column statistics
+        else {
+          var min = ""
+          var max = ""
+          // generate random min and max string/int
+          attr_config.data_type match {
+            case "VARCHAR" =>
+              min = genRandomVarChar(attr_config.cardinality.get)
+              val temp = genRandomVarChar(attr_config.cardinality.get)
+              if (temp < min) {
+                max = min
+                min = temp
+              }
+              else {
+                max = temp
+              }
+            case "DATE" =>
+              min = dates(ThreadLocalRandom.current().nextInt(dates.length))
+              val temp = dates(ThreadLocalRandom.current().nextInt(dates.length))
+              if (temp < min) {
+                max = min
+                min = temp
+              }
+              else {
+                max = temp
+              }
+            case "DECIMAL" =>
+              val min_decimal = genRandomDecimal(attr_config.cardinality.get)
+              val temp_decimal = genRandomDecimal(attr_config.cardinality.get)
+              if (temp_decimal < min_decimal) {
+                max = min_decimal.toString
+                min = temp_decimal.toString
+              }
+              else {
+                min = min_decimal.toString
+                max = temp_decimal.toString
+              }
+            case "INT" =>
+              min = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get.toInt).toString
+              val temp = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get.toInt)
+                .toString
+              if (temp < min) {
+                max = min
+                min = temp
+              }
+              else {
+                max = temp
+              }
+          }
+          val col_stat = CatalogColumnStat(None, Some(min), Some(max),
+            Some(BigInt(0)), None, None, None, 1)
+          col_stats.put(attr_config.name, col_stat)
+
+        }
+
+      }
+      // Now, insert to fact table a single file with appropriate number of rows, file stats etc.
+      val row_count = (insert_config.insert_ratio * dest_fact_table_config.num_rows).toInt
+      val size_in_bytes = row_count * dest_fact_table_config.bytes_per_row
+      val file_stats = CatalogStatistics(size_in_bytes, Some(BigInt(row_count)), col_stats.toMap)
+
+      val dest_part_spec = scala.collection.mutable.Map[String, String]()
+      dest_fact_table.partitionSchema.indices.foreach { i =>
+        val partition_col = dest_fact_table.partitionSchema(i)
+        // partition col follows uniform distribution for now
+        if (partition_col.dataType.isInstanceOf[IntegralType]) {
+          dest_part_spec.put(partition_col.name,
+            ThreadLocalRandom.current().nextInt(dates.length).toString)
+        }
+        // partition col follows uniform distribution for now
+        if (partition_col.dataType == DateType) {
+          dest_part_spec.put(partition_col.name,
+            dates(ThreadLocalRandom.current().nextInt(dates.length)))
+        }
+      }
+
+      val immutable_dest_part_spec = dest_part_spec.toMap
+      val fact_table_files = ArrayBuffer[CatalogTableFile]()
+      val file_path = dest_fact_table.location.getPath + "/" + UUID.randomUUID()
+      val storage = CatalogStorageFormat(Some(new URI(file_path)),
+        dest_fact_table.storage.inputFormat, dest_fact_table.storage.outputFormat,
+        dest_fact_table.storage.serde, false, dest_fact_table.properties)
+      fact_table_files.append(CatalogTableFile(storage, immutable_dest_part_spec,
+        file_stats.sizeInBytes.toLong, stats = Some(file_stats)))
+      // if the fact table is partitioned, get the corresponding partition
+      if (dest_fact_table.partitionColumnNames.nonEmpty && txn.get.isOK()) {
+        val partition = tree_cat.getPartition(dest_fact_table, immutable_dest_part_spec, txn,
+          Some(LockMode.LOCK_MODE_X))
+      }
+
+      // finally add the file to the chosen partition
+      if (txn.get.isOK()) {
+        tree_cat.addFiles(dest_fact_table, fact_table_files, txn)
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      tree_cat.commit(txn.get)
+    }
+
+    private def insertDim(op_data : Option[OpData]) : Boolean = {
+      // generate dimension tables
+      val dest_dim_table_names = table_generator.genInsertDimTables()
+      // increment the identity sk as an independent transaction first
+      val min_id_sk = scala.collection.mutable.Map[String, Long]()
+      val max_id_sk = scala.collection.mutable.Map[String, Long]()
+      dest_dim_table_names.foreach { dest_dim_table_name =>
+        val dest_dim_table_config = table_configs(dest_dim_table_name)
+        val num_new_dim_records = (insert_config.insert_ratio * dest_dim_table_config
+          .num_rows).toLong
+        val min_sk = tree_cat.fetchAddAttr(database_name, dest_dim_table_config.name,
+          dest_dim_table_config.sk.get.name, num_new_dim_records).get.toInt + 1
+        val max_sk = min_sk + num_new_dim_records
+        min_id_sk(dest_dim_table_name) = min_sk
+        max_id_sk(dest_dim_table_name) = max_sk
+      }
+
+      // start of insert operation
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+
+      dest_dim_table_names.foreach { dest_dim_table_name =>
+        val dest_dim_table_config = table_configs(dest_dim_table_name)
+        if (txn.get.isOK()) {
+          // get the target dim table
+          val dest_dim_table = tree_cat.getTable(database_name, dest_dim_table_config.name, txn,
+            Some(LockMode.LOCK_MODE_X))
+          if (txn.get.isOK()) {
+            val dest_table_new_files = ArrayBuffer[CatalogTableFile]()
+            // column statistics
+            val col_stats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+            dest_dim_table_config.schema.foreach { attr_config =>
+              if (attr_config.key.isDefined) {
+                val dim_table_config = table_configs(attr_config.key.get)
+                val cardinality = dim_table_config.getWatermark().toInt
+                // range of sk that are written out
+                var min_sk = ThreadLocalRandom.current().nextInt(cardinality)
+                var max_sk = min_sk
+
+                // increment the watermark only once, for the surrogate key
+                if (dest_dim_table_name == attr_config.key.get) {
+                  if (attr_config.name.endsWith("_sk")) {
+                    // for destination dimension table, write range is precisely
+                    // the newly allocated range of sks
+                    min_sk = min_id_sk(dest_dim_table_name).toInt
+                    max_sk = max_id_sk(dest_dim_table_name).toInt
+                  }
+                }
+                else {
+                  val rand_sk = ThreadLocalRandom.current().nextInt(cardinality)
+                  if (rand_sk < min_sk) {
+                    min_sk = rand_sk
+                  }
+                  if (rand_sk > max_sk) {
+                    max_sk = rand_sk
+                  }
+
+                }
+
+                if (attr_config.data_type == "DATE") {
+                  // adjust the date range according to the cardinality
+                  min_sk = min_sk * dates.length / cardinality
+                  max_sk = max_sk * dates.length / cardinality
+                  val col_stat = CatalogColumnStat(None, Some(dates(min_sk)),
+                    Some(dates(max_sk)),
+                    Some(BigInt(0)), None, None, None, 1)
+                  col_stats.put(attr_config.name, col_stat)
+                }
+                else if (dim_table_config.business_id.isDefined) {
+                  val filters = ArrayBuffer[Expression]()
+                  val min_id = skToId(16, min_sk)
+                  val max_id = skToId(16, max_sk)
+                  val pred = f"${dim_table_config.business_id.get.name} >= '$min_id' and " +
+                    f"${dim_table_config.business_id.get.name} <= '$max_id'"
+                  filters.append(sqlParser.parseExpression(pred))
+
+                  if (dest_dim_table_name == attr_config.key.get) {
+                    if (attr_config.name.endsWith("_sk") && txn.get.isOK()) {
+                      // get the dimension table
+                      val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+                        Some(LockMode.LOCK_MODE_IS))
+                      if (txn.get.isOK()) {
+                        tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_X))
+                        // populate column statistics for both surrogate key and business id
+                        val col_stat = CatalogColumnStat(None, Some(min_sk.toString),
+                          Some(max_sk.toString), Some(BigInt(0)), None, None, None, 1)
+                        col_stats.put(attr_config.name, col_stat)
+                        val id_col_stat = CatalogColumnStat(None, Some(min_id),
+                          Some(max_id), Some(BigInt(0)), None, None, None, 1)
+                        col_stats.put(attr_config.name.stripSuffix("_sk") + "_id", id_col_stat)
+                      }
+                    }
+                  }
+                  else if (txn.get.isOK()) {
+                    // get the dimension table
+                    val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+                      Some(LockMode.LOCK_MODE_IS))
+                    if (txn.get.isOK()) {
+                      // get the list of files from the dimension table
+                      tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_S))
+                      val col_stat = CatalogColumnStat(None, Some(min_sk.toString),
+                        Some(max_sk.toString), Some(BigInt(0)), None, None, None, 1)
+                      col_stats.put(attr_config.name, col_stat)
+                    }
+                  }
+                }
+                else if (txn.get.isOK()) {
+                  val table = tree_cat.getTable(database_name, dim_table_config.name, txn,
+                    Some(LockMode.LOCK_MODE_IS))
+                  if (txn.get.isOK()) {
+                    // just get all the files of the dimension table
+                    tree_cat.listFiles(table, txn, Some(LockMode.LOCK_MODE_S))
+                    val col_stat = CatalogColumnStat(None, Some(min_sk.toString),
+                      Some(max_sk.toString), Some(BigInt(0)), None, None, None, 1)
+                    col_stats.put(attr_config.name, col_stat)
+                  }
+                }
+              }
+              // for other attributes, generate random values and fill in the column statistics
+              else {
+                var min = ""
+                var max = ""
+                // generate random min and max string/int
+                attr_config.data_type match {
+                  case "VARCHAR" =>
+                    min = genRandomVarChar(attr_config.cardinality.get)
+                    val temp = genRandomVarChar(attr_config.cardinality.get)
+                    if (temp < min) {
+                      max = min
+                      min = temp
+                    }
+                    else {
+                      max = temp
+                    }
+                  case "DATE" =>
+                    min = dates(ThreadLocalRandom.current().nextInt(dates.length))
+                    val temp = dates(ThreadLocalRandom.current().nextInt(dates.length))
+                    if (temp < min) {
+                      max = min
+                      min = temp
+                    }
+                    else {
+                      max = temp
+                    }
+                  case "DECIMAL" =>
+                    val min_decimal = genRandomDecimal(attr_config.cardinality.get)
+                    val temp_decimal = genRandomDecimal(attr_config.cardinality.get)
+                    if (temp_decimal < min_decimal) {
+                      max = min_decimal.toString
+                      min = temp_decimal.toString
+                    }
+                    else {
+                      min = min_decimal.toString
+                      max = temp_decimal.toString
+                    }
+                  case "INT" =>
+                    min = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get.toInt)
+                      .toString
+                    val temp = ThreadLocalRandom.current().nextInt(attr_config.cardinality.get
+                      .toInt).toString
+                    if (temp < min) {
+                      max = min
+                      min = temp
+                    }
+                    else {
+                      max = temp
+                    }
+
+                }
+
+                val col_stat = CatalogColumnStat(None, Some(min), Some(max),
+                  Some(BigInt(0)), None, None, None, 1)
+                col_stats.put(attr_config.name, col_stat)
+
+              }
+            }
+
+            if (txn.get.isOK()) {
+              // Now, insert to dim table a single file with appropriate number of rows, file stats
+              // etc.
+              val row_count = (insert_config.insert_ratio * dest_dim_table_config.num_rows).toInt
+              val size_in_bytes = row_count * dest_dim_table_config.bytes_per_row
+              val file_stats = CatalogStatistics(size_in_bytes, Some(BigInt(row_count)),
+                col_stats.toMap)
+
+              val dest_part_spec = scala.collection.mutable.Map[String, String]()
+              dest_dim_table.partitionSchema.indices.foreach { i =>
+                val partition_col = dest_dim_table.partitionSchema(i)
+                // partition col follows uniform distribution for now
+                if (partition_col.dataType.isInstanceOf[IntegralType]) {
+                  dest_part_spec.put(partition_col.name,
+                    ThreadLocalRandom.current().nextInt(dates.length).toString)
+                }
+                // partition col follows uniform distribution for now
+                if (partition_col.dataType == DateType) {
+                  dest_part_spec.put(partition_col.name,
+                    dates(ThreadLocalRandom.current().nextInt(dates.length)))
+                }
+              }
+
+              val immutable_dest_part_spec = dest_part_spec.toMap
+              val file_path = dest_dim_table.location.getPath + "/" + UUID.randomUUID()
+              val storage = CatalogStorageFormat(Some(new URI(file_path)),
+                dest_dim_table.storage.inputFormat, dest_dim_table.storage.outputFormat,
+                dest_dim_table.storage.serde, false, dest_dim_table.properties)
+              dest_table_new_files.append(CatalogTableFile(storage, immutable_dest_part_spec,
+                file_stats.sizeInBytes.toLong, stats = Some(file_stats)))
+              // finally add batch of files to the dest dimension table
+              tree_cat.addFiles(dest_dim_table, dest_table_new_files, txn)
+            }
+          }
+        }
+      }
+
+      val success = tree_cat.commit(txn.get)
+
+      max_id_sk.foreach { entry =>
+        table_configs(entry._1).setWatermark(entry._2)
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      success
+    }
+
+    private def deleteOp(op_data : Option[OpData]): Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      val target_table_names = table_generator.genDeleteTable()
+
+      val min_sk = ThreadLocalRandom.current().nextInt(dates.length)
+      val max_sk = min_sk + delete_config.date_range - 1
+      val min_sk_str = "%012d".format(min_sk)
+      val max_sk_str = "%012d".format(max_sk)
+      target_table_names.foreach{ target_table_name =>
+        if (txn.get.isOK()) {
+          // get the target fact table.
+          val target_table = tree_cat.getTable(database_name, target_table_name, txn,
+            Some(LockMode.LOCK_MODE_IX))
+          val partition_column = target_table.partitionSchema.head
+          val partition_col_name = partition_column.name
+          val filters = ArrayBuffer[Expression]()
+          val pred = f"$partition_col_name >= '$partition_col_name=$min_sk_str' and " +
+            f"$partition_col_name <= '$partition_col_name=$max_sk_str'"
+          filters.append(sqlParser.parseExpression(pred))
+
+          if (txn.get.isOK()) {
+            val files = tree_cat.listFilesWithStatsByFilter(target_table, filters, txn,
+              Some(LockMode.LOCK_MODE_X))
+            tree_cat.removeFiles(target_table, files, txn)
+          }
+        }
+
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      tree_cat.commit(txn.get)
+    }
+
+    private def readOp(op_data : Option[OpData]): Boolean = {
+      val txn = tree_cat.startTransaction(TxnMode.TXN_MODE_READ_ONLY)
+      val query_config = table_generator.genReadQuery()
+      val table_jsons = query_config._1.elements().next()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val table = tree_cat.getTable(database_name, table_name, txn,
+            Some(LockMode.LOCK_MODE_NL))
+          tree_cat.listFiles(table, txn, Some(LockMode.LOCK_MODE_NL))
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val table = tree_cat.getTable(database_name, table_name, txn,
+            Some(LockMode.LOCK_MODE_NL))
+          val partition_column = table.partitionSchema.head
+          val partition_col_name = partition_column.name
+          val filters = ArrayBuffer[Expression]()
+
+          val partition_range = table_json.get("range")
+
+          if (partition_range.size() == 1) {
+            val sk = "%012d".format(partition_range.get(0).asInt())
+            val pred = f"$partition_col_name == '$partition_col_name=$sk'"
+            filters.append(sqlParser.parseExpression(pred))
+          }
+          else if (partition_range.size() == 2) {
+            val min_sk = "%012d".format(partition_range.get(0).asInt())
+            val max_sk = "%012d".format(partition_range.get(1).asInt())
+            val pred = f"$partition_col_name >= '$partition_col_name=$min_sk' and " +
+              f"$partition_col_name <= '$partition_col_name=$max_sk'"
+            filters.append(sqlParser.parseExpression(pred))
+          }
+
+          tree_cat.listFilesByFilter(table, filters, txn, Some(LockMode.LOCK_MODE_NL))
+
+        }
+
+      }
+
+      if (op_data.isDefined) {
+        op_data.get.misc = query_config._2.toString
+        op_data.get.data_sent += txn.get.data_sent
+        op_data.get.data_received += txn.get.data_received
+      }
+
+      tree_cat.commit(txn.get)
+
+    }
+  }
+
+  private def genRandomDecimal(num_digits : Long) : Int = {
+    ThreadLocalRandom.current().nextInt(math.pow(10, num_digits - 4).toInt)
+  }
+
+  private def genRandomVarChar(max_length : Long) : String = {
+    val length = ThreadLocalRandom.current().nextInt(max_length.toInt)
+    val char_buf = ArrayBuffer.fill(length)('A')
+    for (i <- 0 until length) {
+      char_buf(i) = (ThreadLocalRandom.current().nextInt(26) + 65).toChar
+    }
+    char_buf.mkString
+  }
+
+  private def skToId(length : Int, sk : Int) : String = {
+    val char_buf = ArrayBuffer.fill(length)('A')
+    var quotient = sk
+    var cur_length = 0
+    while (quotient > 0) {
+      val remainder = quotient % 26
+      quotient = quotient / 26
+      cur_length += 1
+      char_buf(length - cur_length) = (remainder + 65).toChar
+    }
+
+    char_buf.mkString
+
+  }
+
+  private def convertToMilliseconds(time : String): Int = {
+    val parts = time.split(":").map(_.toInt)
+    val hours = parts(0)
+    val minutes = parts(1)
+    val seconds = parts(2)
+    (hours * 3600 + minutes * 60 + seconds) * 1000
+  }
+
+  private def switchUUID(file: CatalogTableFile, uuid: UUID): CatalogTableFile = {
+    val old_file_path = file.storage.locationUri.get.toString
+    val new_file_path = Some(new URI(old_file_path.substring(0, old_file_path.lastIndexOf('/')
+      + 1) + uuid))
+    val file_storage = file.storage
+    val new_storage = CatalogStorageFormat(new_file_path, file_storage.inputFormat,
+      file_storage.outputFormat, file_storage.serde, file_storage.compressed,
+      file_storage.properties)
+    CatalogTableFile(new_storage, file.partitionValues, file.size, System.currentTimeMillis,
+      file.stats, file.tags)
+  }
+
+  // merges src_file to dest_file, including all the stats etc.
+  private def mergeFiles(table: CatalogTable, dest_file: CatalogTableFile,
+                         src_file: CatalogTableFile): CatalogTableFile = {
+    val stats = mergeStats(table, dest_file.stats.get, src_file.stats.get)
+    CatalogTableFile(dest_file.storage, dest_file.partitionValues, dest_file.size + src_file.size,
+      System.currentTimeMillis, Some(stats), dest_file.tags)
+  }
+
+  private def mergeStats(table : CatalogTable, base : CatalogStatistics,
+                         delta: CatalogStatistics): CatalogStatistics = {
+    val sizeInBytes = base.sizeInBytes + delta.sizeInBytes
+    val rowCount = {
+      if (base.rowCount.isDefined && delta.rowCount.isDefined) {
+        Some(base.rowCount.get + delta.rowCount.get)
+      }
+      else {
+        None
+      }
+    }
+    val colStats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+    table.schema.foreach { attr =>
+      val mergedColStat = mergeColStats(attr, base.colStats.get(attr.name),
+        delta.colStats.get(attr.name))
+      if (mergedColStat.isDefined) {
+        colStats.put(attr.name, mergedColStat.get)
+      }
+    }
+    CatalogStatistics(sizeInBytes, rowCount, colStats.toMap)
+  }
+
+  // we assume that delta is always more "complete" than base
+  private def mergeColStats(attr: StructField, base: Option[CatalogColumnStat],
+                            delta: Option[CatalogColumnStat]) : Option[CatalogColumnStat] = {
+
+    if (base.isDefined) {
+      if (delta.isDefined) {
+        val min = {
+          if (base.get.min.isDefined && delta.get.min.isDefined) {
+            attr.dataType match {
+              case _: IntegralType =>
+                Some(base.get.min.get.toInt.min(delta.get.min.get.toInt).toString)
+              case _: FractionalType =>
+                val min_val = base.get.min.get.toDouble.max(delta.get.min.get.toDouble)
+                Some(f"$min_val%.2f")
+              case _ =>
+                Some(if (base.get.min.get < delta.get.min.get) base.get.min.get
+                else delta.get.min.get)
+            }
+          }
+          else {
+            None
+          }
+        }
+        val max = {
+          if (base.get.max.isDefined && delta.get.max.isDefined) {
+            attr.dataType match {
+              case _: IntegralType =>
+                Some(base.get.max.get.toInt.max(delta.get.max.get.toInt).toString)
+              case _: FractionalType =>
+                val max_val = base.get.max.get.toDouble.max(delta.get.max.get.toDouble)
+                Some(f"$max_val%.2f")
+              case _ =>
+                Some(if (base.get.max.get > delta.get.max.get) base.get.max.get
+                else delta.get.max.get)
+            }
+          }
+          else {
+            None
+          }
+        }
+        val nullCount = {
+          if (base.get.nullCount.isDefined && delta.get.nullCount.isDefined) {
+            Some(base.get.nullCount.get + delta.get.nullCount.get)
+          }
+          else {
+            None
+          }
+        }
+        Some(CatalogColumnStat(None, min, max, nullCount, None, None, None, 1))
+      }
+      else {
+        base
+      }
+    }
+    else if (delta.isDefined) {
+      delta
+    }
+    else {
+      None
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/exp/src/main/scala/org/apache/spark/exp/Experiment.scala b/exp/src/main/scala/org/apache/spark/exp/Experiment.scala
new file mode 100644
index 00000000000..ffe6c90833b
--- /dev/null
+++ b/exp/src/main/scala/org/apache/spark/exp/Experiment.scala
@@ -0,0 +1,413 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.exp
+
+import java.util.Locale
+
+import scala.collection.mutable.HashMap
+
+import org.apache.iceberg.spark.SparkCatalog
+
+import org.apache.spark.SparkConf
+import org.apache.spark.SparkContext
+import org.apache.spark.internal.Logging
+import org.apache.spark.sql.SparkSession
+import org.apache.spark.sql.connector.catalog.DelegatingCatalogExtension
+import org.apache.spark.sql.hive.HMSClientExt
+import org.apache.spark.sql.internal.StaticSQLConf.CATALOG_IMPLEMENTATION
+import org.apache.spark.tree.TreeExternalCatalog
+import org.apache.spark.util.Utils
+
+private[spark] class DeltaUtil() extends Logging {
+  var sparkContext: SparkContext = _
+  var sparkSession: SparkSession = _
+  private var isShellSession = false
+
+  val env = sys.env
+  var propertiesFile: String = null
+  var verbose: Boolean = false
+  val sparkProperties: HashMap[String, String] = new HashMap[String, String]()
+  lazy val defaultSparkProperties: HashMap[String, String] = {
+    val defaultProperties = new HashMap[String, String]()
+    if (verbose) {
+      logInfo(s"Using properties file: $propertiesFile")
+    }
+    Option(propertiesFile).foreach { filename =>
+      val properties = Utils.getPropertiesFromFile(filename)
+      properties.foreach { case (k, v) =>
+        defaultProperties(k) = v
+      }
+      // Property files may contain sensitive information, so redact before printing
+      if (verbose) {
+        Utils.redact(properties).foreach { case (k, v) =>
+          logInfo(s"Adding default property: $k=$v")
+        }
+      }
+    }
+    defaultProperties
+  }
+
+  mergeDefaultSparkProperties()
+
+  ignoreNonSparkProperties()
+
+  val conf = toSparkConf()
+  val rootDir = conf.getOption("spark.repl.classdir").getOrElse(Utils.getLocalDir(conf))
+  val outputDir = Utils.createTempDir(root = rootDir, namePrefix = "repl")
+
+  createSparkSession()
+
+  val delta = sparkSession.sessionState.catalogManager
+    .catalog("spark_catalog").asInstanceOf[DelegatingCatalogExtension]
+
+  private def mergeDefaultSparkProperties(): Unit = {
+    // Use common defaults file, if not specified by user
+    propertiesFile = Option(propertiesFile).getOrElse(Utils.getDefaultPropertiesFile(env))
+    // Honor --conf before the defaults file
+    defaultSparkProperties.foreach { case (k, v) =>
+      if (!sparkProperties.contains(k)) {
+        sparkProperties(k) = v
+      }
+    }
+  }
+
+  private def ignoreNonSparkProperties(): Unit = {
+    sparkProperties.keys.foreach { k =>
+      if (!k.startsWith("spark.")) {
+        sparkProperties -= k
+        logWarning(s"Ignoring non-Spark config property: $k")
+      }
+    }
+  }
+
+  private def toSparkConf(sparkConf: Option[SparkConf] = None): SparkConf = {
+    // either use an existing config or create a new empty one
+    sparkProperties.foldLeft(sparkConf.getOrElse(new SparkConf())) {
+      case (conf, (k, v)) => conf.set(k, v)
+    }
+  }
+
+  def createSparkSession(): SparkSession = {
+    try {
+      val execUri = System.getenv("SPARK_EXECUTOR_URI")
+      conf.setIfMissing("spark.app.name", "Spark shell")
+      // SparkContext will detect this configuration and register it with the RpcEnv's
+      // file server, setting spark.repl.class.uri to the actual URI for executors to
+      // use. This is sort of ugly but since executors are started as part of SparkContext
+      // initialization in certain cases, there's an initialization order issue that prevents
+      // this from being set after SparkContext is instantiated.
+      conf.set("spark.repl.class.outputDir", outputDir.getAbsolutePath())
+      if (execUri != null) {
+        conf.set("spark.executor.uri", execUri)
+      }
+      if (System.getenv("SPARK_HOME") != null) {
+        conf.setSparkHome(System.getenv("SPARK_HOME"))
+      }
+
+      val builder = SparkSession.builder.config(conf)
+      if (conf.get(CATALOG_IMPLEMENTATION.key, "hive").toLowerCase(Locale.ROOT) == "hive") {
+        if (SparkSession.hiveClassesArePresent) {
+          // In the case that the property is not set at all, builder's config
+          // does not have this value set to 'hive' yet. The original default
+          // behavior is that when there are hive classes, we use hive catalog.
+          sparkSession = builder.enableHiveSupport().getOrCreate()
+          logInfo("Created Spark session with Hive support")
+        } else {
+          // Need to change it back to 'in-memory' if no hive classes are found
+          // in the case that the property is set to hive in spark-defaults.conf
+          builder.config(CATALOG_IMPLEMENTATION.key, "in-memory")
+          sparkSession = builder.getOrCreate()
+          logInfo("Created Spark session")
+        }
+      } else {
+        // In the case that the property is set but not to 'hive', the internal
+        // default is 'in-memory'. So the sparkSession will use in-memory catalog.
+        sparkSession = builder.getOrCreate()
+        logInfo("Created Spark session")
+      }
+      sparkContext = sparkSession.sparkContext
+      sparkSession
+    } catch {
+      case e: ClassNotFoundException if isShellSession && e.getMessage.contains(
+        "org.apache.spark.sql.connect.SparkConnectPlugin") =>
+        logError("Failed to load spark connect plugin.")
+        logError("You need to build Spark with -Pconnect.")
+        sys.exit(1)
+      case e: Exception if isShellSession =>
+        logError("Failed to initialize Spark session.", e)
+        sys.exit(1)
+    }
+  }
+}
+
+private[spark] class IcebergUtil() extends Logging {
+  var sparkContext: SparkContext = _
+  var sparkSession: SparkSession = _
+  private var isShellSession = false
+
+  val env = sys.env
+  var propertiesFile: String = null
+  var verbose: Boolean = false
+  val sparkProperties: HashMap[String, String] = new HashMap[String, String]()
+  lazy val defaultSparkProperties: HashMap[String, String] = {
+    val defaultProperties = new HashMap[String, String]()
+    if (verbose) {
+      logInfo(s"Using properties file: $propertiesFile")
+    }
+    Option(propertiesFile).foreach { filename =>
+      val properties = Utils.getPropertiesFromFile(filename)
+      properties.foreach { case (k, v) =>
+        defaultProperties(k) = v
+      }
+      // Property files may contain sensitive information, so redact before printing
+      if (verbose) {
+        Utils.redact(properties).foreach { case (k, v) =>
+          logInfo(s"Adding default property: $k=$v")
+        }
+      }
+    }
+    defaultProperties
+  }
+
+  mergeDefaultSparkProperties()
+
+  ignoreNonSparkProperties()
+
+  val conf = toSparkConf()
+  val rootDir = conf.getOption("spark.repl.classdir").getOrElse(Utils.getLocalDir(conf))
+  val outputDir = Utils.createTempDir(root = rootDir, namePrefix = "repl")
+
+  createSparkSession()
+
+  val iceberg = sparkSession.sessionState.catalogManager
+    .catalog("hive_prod").asInstanceOf[SparkCatalog]
+
+  private def mergeDefaultSparkProperties(): Unit = {
+    // Use common defaults file, if not specified by user
+    propertiesFile = Option(propertiesFile).getOrElse(Utils.getDefaultPropertiesFile(env))
+    // Honor --conf before the defaults file
+    defaultSparkProperties.foreach { case (k, v) =>
+      if (!sparkProperties.contains(k)) {
+        sparkProperties(k) = v
+      }
+    }
+  }
+
+  private def ignoreNonSparkProperties(): Unit = {
+    sparkProperties.keys.foreach { k =>
+      if (!k.startsWith("spark.")) {
+        sparkProperties -= k
+        logWarning(s"Ignoring non-Spark config property: $k")
+      }
+    }
+  }
+
+  private def toSparkConf(sparkConf: Option[SparkConf] = None): SparkConf = {
+    // either use an existing config or create a new empty one
+    sparkProperties.foldLeft(sparkConf.getOrElse(new SparkConf())) {
+      case (conf, (k, v)) => conf.set(k, v)
+    }
+  }
+
+  def createSparkSession(): SparkSession = {
+    try {
+      val execUri = System.getenv("SPARK_EXECUTOR_URI")
+      conf.setIfMissing("spark.app.name", "Spark shell")
+      // SparkContext will detect this configuration and register it with the RpcEnv's
+      // file server, setting spark.repl.class.uri to the actual URI for executors to
+      // use. This is sort of ugly but since executors are started as part of SparkContext
+      // initialization in certain cases, there's an initialization order issue that prevents
+      // this from being set after SparkContext is instantiated.
+      conf.set("spark.repl.class.outputDir", outputDir.getAbsolutePath())
+      if (execUri != null) {
+        conf.set("spark.executor.uri", execUri)
+      }
+      if (System.getenv("SPARK_HOME") != null) {
+        conf.setSparkHome(System.getenv("SPARK_HOME"))
+      }
+
+      val builder = SparkSession.builder.config(conf)
+      if (conf.get(CATALOG_IMPLEMENTATION.key, "hive").toLowerCase(Locale.ROOT) == "hive") {
+        if (SparkSession.hiveClassesArePresent) {
+          // In the case that the property is not set at all, builder's config
+          // does not have this value set to 'hive' yet. The original default
+          // behavior is that when there are hive classes, we use hive catalog.
+          sparkSession = builder.enableHiveSupport().getOrCreate()
+          logInfo("Created Spark session with Hive support")
+        } else {
+          // Need to change it back to 'in-memory' if no hive classes are found
+          // in the case that the property is set to hive in spark-defaults.conf
+          builder.config(CATALOG_IMPLEMENTATION.key, "in-memory")
+          sparkSession = builder.getOrCreate()
+          logInfo("Created Spark session")
+        }
+      } else {
+        // In the case that the property is set but not to 'hive', the internal
+        // default is 'in-memory'. So the sparkSession will use in-memory catalog.
+        sparkSession = builder.getOrCreate()
+        logInfo("Created Spark session")
+      }
+      sparkContext = sparkSession.sparkContext
+      sparkSession
+    } catch {
+      case e: ClassNotFoundException if isShellSession && e.getMessage.contains(
+        "org.apache.spark.sql.connect.SparkConnectPlugin") =>
+        logError("Failed to load spark connect plugin.")
+        logError("You need to build Spark with -Pconnect.")
+        sys.exit(1)
+      case e: Exception if isShellSession =>
+        logError("Failed to initialize Spark session.", e)
+        sys.exit(1)
+    }
+  }
+}
+
+private[spark] class TreeUtil(tree_address : String) extends Logging {
+  val tree = new TreeExternalCatalog(tree_address)
+}
+
+private[spark] class HMSUtil() extends Logging {
+  val hms_ext = new HMSClientExt(Seq.empty)
+  val hms = hms_ext.client
+}
+
+private[spark] class ExperimentUtil(treeAddress: String = "localhost:9876") extends Logging {
+  var sparkContext: SparkContext = _
+  var sparkSession: SparkSession = _
+  private var isShellSession = false
+
+  val env = sys.env
+  var propertiesFile: String = null
+  var verbose: Boolean = false
+  val sparkProperties: HashMap[String, String] = new HashMap[String, String]()
+  lazy val defaultSparkProperties: HashMap[String, String] = {
+    val defaultProperties = new HashMap[String, String]()
+    if (verbose) {
+      logInfo(s"Using properties file: $propertiesFile")
+    }
+    Option(propertiesFile).foreach { filename =>
+      val properties = Utils.getPropertiesFromFile(filename)
+      properties.foreach { case (k, v) =>
+        defaultProperties(k) = v
+      }
+      // Property files may contain sensitive information, so redact before printing
+      if (verbose) {
+        Utils.redact(properties).foreach { case (k, v) =>
+          logInfo(s"Adding default property: $k=$v")
+        }
+      }
+    }
+    defaultProperties
+  }
+  mergeDefaultSparkProperties()
+
+  ignoreNonSparkProperties()
+
+  val conf = toSparkConf()
+  val rootDir = conf.getOption("spark.repl.classdir").getOrElse(Utils.getLocalDir(conf))
+  val outputDir = Utils.createTempDir(root = rootDir, namePrefix = "repl")
+
+  createSparkSession()
+
+  val hms_ext = new HMSClientExt(Seq.empty)
+  val hms = hms_ext.client
+  val tree = new TreeExternalCatalog(treeAddress)
+  val delta = sparkSession.sessionState.catalogManager
+    .catalog("spark_catalog").asInstanceOf[DelegatingCatalogExtension]
+  val iceberg = sparkSession.sessionState.catalogManager
+    .catalog("hive_prod").asInstanceOf[SparkCatalog]
+
+  private def mergeDefaultSparkProperties(): Unit = {
+    // Use common defaults file, if not specified by user
+    propertiesFile = Option(propertiesFile).getOrElse(Utils.getDefaultPropertiesFile(env))
+    // Honor --conf before the defaults file
+    defaultSparkProperties.foreach { case (k, v) =>
+      if (!sparkProperties.contains(k)) {
+        sparkProperties(k) = v
+      }
+    }
+  }
+
+  private def ignoreNonSparkProperties(): Unit = {
+    sparkProperties.keys.foreach { k =>
+      if (!k.startsWith("spark.")) {
+        sparkProperties -= k
+        logWarning(s"Ignoring non-Spark config property: $k")
+      }
+    }
+  }
+
+  private def toSparkConf(sparkConf: Option[SparkConf] = None): SparkConf = {
+    // either use an existing config or create a new empty one
+    sparkProperties.foldLeft(sparkConf.getOrElse(new SparkConf())) {
+      case (conf, (k, v)) => conf.set(k, v)
+    }
+  }
+
+  def createSparkSession(): SparkSession = {
+    try {
+      val execUri = System.getenv("SPARK_EXECUTOR_URI")
+      conf.setIfMissing("spark.app.name", "Spark shell")
+      // SparkContext will detect this configuration and register it with the RpcEnv's
+      // file server, setting spark.repl.class.uri to the actual URI for executors to
+      // use. This is sort of ugly but since executors are started as part of SparkContext
+      // initialization in certain cases, there's an initialization order issue that prevents
+      // this from being set after SparkContext is instantiated.
+      conf.set("spark.repl.class.outputDir", outputDir.getAbsolutePath())
+      if (execUri != null) {
+        conf.set("spark.executor.uri", execUri)
+      }
+      if (System.getenv("SPARK_HOME") != null) {
+        conf.setSparkHome(System.getenv("SPARK_HOME"))
+      }
+
+      val builder = SparkSession.builder.config(conf)
+      if (conf.get(CATALOG_IMPLEMENTATION.key, "hive").toLowerCase(Locale.ROOT) == "hive") {
+        if (SparkSession.hiveClassesArePresent) {
+          // In the case that the property is not set at all, builder's config
+          // does not have this value set to 'hive' yet. The original default
+          // behavior is that when there are hive classes, we use hive catalog.
+          sparkSession = builder.enableHiveSupport().getOrCreate()
+          logInfo("Created Spark session with Hive support")
+        } else {
+          // Need to change it back to 'in-memory' if no hive classes are found
+          // in the case that the property is set to hive in spark-defaults.conf
+          builder.config(CATALOG_IMPLEMENTATION.key, "in-memory")
+          sparkSession = builder.getOrCreate()
+          logInfo("Created Spark session")
+        }
+      } else {
+        // In the case that the property is set but not to 'hive', the internal
+        // default is 'in-memory'. So the sparkSession will use in-memory catalog.
+        sparkSession = builder.getOrCreate()
+        logInfo("Created Spark session")
+      }
+      sparkContext = sparkSession.sparkContext
+      sparkSession
+    } catch {
+      case e: ClassNotFoundException if isShellSession && e.getMessage.contains(
+        "org.apache.spark.sql.connect.SparkConnectPlugin") =>
+        logError("Failed to load spark connect plugin.")
+        logError("You need to build Spark with -Pconnect.")
+        sys.exit(1)
+      case e: Exception if isShellSession =>
+        logError("Failed to initialize Spark session.", e)
+        sys.exit(1)
+    }
+  }
+}
\ No newline at end of file
diff --git a/exp/src/main/scala/org/apache/spark/exp/ScanRangeExperiment.scala b/exp/src/main/scala/org/apache/spark/exp/ScanRangeExperiment.scala
new file mode 100644
index 00000000000..5ba21b4839e
--- /dev/null
+++ b/exp/src/main/scala/org/apache/spark/exp/ScanRangeExperiment.scala
@@ -0,0 +1,456 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.exp
+
+import java.io.File
+import java.io.FileWriter
+import java.time.{Duration, Instant}
+import java.time.LocalDate
+import java.time.format.DateTimeFormatter
+import java.util.concurrent.Executors
+
+import scala.collection.mutable.ArrayBuffer
+import scala.concurrent.{Await, ExecutionContext, Future}
+import scala.io.Source
+
+import com.fasterxml.jackson.databind.ObjectMapper
+import org.apache.hadoop.fs.FileSystem
+import org.apache.hadoop.fs.Path
+import org.apache.iceberg.spark.source.SparkTable
+
+import org.apache.spark.sql.catalyst.expressions.Expression
+import org.apache.spark.sql.connector.catalog.Identifier
+import org.apache.spark.sql.delta.catalog.DeltaTableV2
+import org.apache.spark.sql.execution.SparkSqlParser
+import org.apache.spark.sql.execution.datasources.{HadoopFsRelation, SparkExpressionConverter}
+
+object ScanRangeExperiment {
+  private val sql_parser = new ThreadLocal[SparkSqlParser]() {
+    override def initialValue(): SparkSqlParser = new SparkSqlParser()
+  }
+
+  val misc_config = scala.collection.mutable.Map.empty[String, String]
+  misc_config.put("resultOutput", "/tmp/scanrange.json")
+  misc_config.put("experimentIters", "100")
+  misc_config.put("treeAddress", "localhost:9876")
+  misc_config.put("startDate", "1998-01-01")
+  misc_config.put("endDate", "2003-12-31")
+  misc_config.put("partitionRange", "7")
+  misc_config.put("seed", "0")
+  misc_config.put("numCores", Runtime.getRuntime.availableProcessors().toString)
+  misc_config.put("numFiles", "50")
+
+  def main(args: Array[String]): Unit = {
+    if (args.size != 2) {
+      print("Usage: spark-class org.apache.spark.exp.ParallelScanRangeExperiment " +
+        "<scanConfig> <catalogType>\n")
+      return
+    }
+
+    val json_parser = new ObjectMapper
+    // read in data config
+    val scan_config_json = json_parser.readTree(Source.fromFile(args(0)).mkString)
+    scan_config_json.get("misc").fields().forEachRemaining { config =>
+      misc_config.put(config.getKey, config.getValue.asText())
+    }
+
+    val result_output = misc_config("resultOutput")
+    val iters = misc_config("experimentIters").toInt
+    val tree_address = misc_config("treeAddress")
+
+    val delta_db = scan_config_json.get("delta").asText()
+    val hms_db = scan_config_json.get("hms").asText()
+    val tree_db = scan_config_json.get("tree").asText()
+    val iceberg_db = scan_config_json.get("iceberg").asText()
+    val table_name = scan_config_json.get("tables").get(0).get("name").asText()
+    val partition_name = scan_config_json.get("tables").get(0).get("partitionSchema").get(0)
+      .get("name").asText()
+
+    val catalog_type = args(1)
+    val num_files = misc_config("numFiles").toInt
+
+    // initialize the dates
+    val date_formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
+    val start_date = LocalDate.parse(misc_config("startDate"), date_formatter)
+    val end_date = LocalDate.parse(misc_config("endDate"), date_formatter)
+    val dates: Array[String] = Iterator.iterate(start_date)(_ plusDays 1) // Generate dates
+      .takeWhile(!_.isAfter(end_date)) // Stop when exceeding the end date
+      .map(_.format(date_formatter)) // Convert to formatted strings
+      .toArray
+    val partition_range = misc_config("partitionRange").toInt
+    val num_partitions = dates.length.min(num_files)
+    val num_cores = misc_config("numCores").toInt
+    val thread_pool = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(num_cores))
+
+    val random = new scala.util.Random(misc_config("seed").toLong)
+    // generate min sks.
+    val min_sks = ArrayBuffer[Int]()
+    for (i <- 0 until (iters + 10)) {
+      min_sks += random.nextInt(num_partitions - partition_range)
+    }
+
+    catalog_type match {
+      case "delta" => scanDelta(result_output, iters, delta_db, table_name, partition_name,
+        num_files, partition_range, min_sks, num_cores)
+      case "hms" => scanHMS(result_output, iters, hms_db, table_name, partition_name, num_files,
+        partition_range, min_sks, num_cores)
+      case "phms" => scanParallelHMS(result_output, iters, hms_db, table_name, partition_name,
+        num_files, partition_range, min_sks, num_cores, thread_pool)
+      case "iceberg" => scanIceberg(result_output, iters, iceberg_db, table_name, partition_name,
+        num_files, partition_range, min_sks, num_cores)
+      case "tree" => scanTree(result_output, iters, tree_db, table_name, partition_name,
+        num_files, partition_range, min_sks, tree_address, num_cores)
+      case "ptree" => scanParallelTree(result_output, iters, (tree_db, table_name), partition_name,
+        num_files, partition_range, min_sks, tree_address, num_cores, thread_pool)
+      case _ => print("Invalid Catalog Type!!!")
+    }
+
+    thread_pool.shutdown()
+  }
+
+  private def writeOutput(result_output : String, times : Seq[Long], catalog : String,
+                          num_files : Int, partition_range : Int, num_cores : Int): Unit = {
+    val output_writer = new FileWriter(new File(result_output), true)
+    times.foreach { time =>
+      output_writer.write("{\"catalog\":\"" + catalog + "\", ")
+      output_writer.write("\"numFiles\":" + num_files + ", ")
+      output_writer.write("\"partitionRange\":" + partition_range + ", ")
+      output_writer.write("\"numCores\":" + num_cores + ", ")
+      output_writer.write("\"time\":" + time + "}")
+      output_writer.write("\n")
+    }
+    output_writer.flush()
+    output_writer.close()
+  }
+
+  def splitIntoBoundaries(min: Int, max: Int, n: Int): List[(Int, Int)] = {
+    require(n > 0, "Number of boundaries must be positive")
+
+    val step = (max - min) / n
+    val remainder = (max - min) % n
+
+    (0 until n).foldLeft((min, List.empty[(Int, Int)])) {
+      case ((start, acc), i) =>
+        val extra = if (i < remainder) 1 else 0 // Distribute remainder evenly
+        val end = start + step + extra
+        (end, acc :+ (start, end))
+    }._2
+  }
+
+
+  private def constructHMSFilters(partition_name : String, min_sk: Int, max_sk: Int) :
+  Seq[Expression] = {
+    val filters = ArrayBuffer[Expression]()
+    val partition_pred = f"${partition_name} >= $min_sk and " +
+      f"${partition_name} < $max_sk"
+    filters.append(sql_parser.get.parseExpression(partition_pred))
+
+    filters
+  }
+
+  private def scanDelta(result_output : String, iters : Int, db_name : String,
+                        table_name : String, partition_name : String, num_files : Int,
+                        partition_range : Int, min_sks : Seq[Int], num_cores : Int) : Unit = {
+
+    val delta_util = new DeltaUtil()
+    // dry run
+    for (i <- 0 until 10) {
+      val min_sk = min_sks(i)
+      val filters = constructHMSFilters(partition_name, min_sk, min_sk + partition_range)
+      val deltaTable = delta_util.delta.loadTable(Identifier.of(Array(db_name), table_name))
+      val baseRelation = deltaTable.asInstanceOf[DeltaTableV2].toBaseRelation
+        .asInstanceOf[HadoopFsRelation]
+      val deltaPartitions = baseRelation.location.listFiles(filters, Seq.empty)
+    }
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val min_sk = min_sks(i + 10)
+      val filters = constructHMSFilters(partition_name, min_sk, min_sk + partition_range)
+
+      val start_time = Instant.now()
+      val deltaTable = delta_util.delta.loadTable(Identifier.of(Array(db_name), table_name))
+      val baseRelation = deltaTable.asInstanceOf[DeltaTableV2].toBaseRelation
+        .asInstanceOf[HadoopFsRelation]
+      val deltaPartitions = baseRelation.location.listFiles(filters, Seq.empty)
+      val end_time = Instant.now()
+
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "delta", num_files, partition_range, num_cores)
+  }
+
+  private def scanHMS(result_output : String, iters : Int, db_name : String,
+                      table_name : String, partition_name : String, num_files : Int,
+                      partition_range : Int, min_sks : Seq[Int], num_cores : Int) : Unit = {
+
+    val hms_util = new HMSUtil()
+    // dry run
+    for (i <- 0 until 10) {
+      val min_sk = min_sks(i)
+      val filters = constructHMSFilters(partition_name, min_sk, min_sk + partition_range)
+
+      val hms_partitions = hms_util.hms.listPartitionsByFilter(db_name, table_name,
+        filters, "UTC")
+      hms_partitions.foreach { partition =>
+        val hms_files = hms_util.hms_ext.listFiles(partition)
+      }
+    }
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val min_sk = min_sks(i + 10)
+      val filters = constructHMSFilters(partition_name, min_sk, min_sk + partition_range)
+
+      val start_time = Instant.now()
+      val hms_partitions = hms_util.hms.listPartitionsByFilter(db_name, table_name,
+        filters, "UTC")
+      hms_partitions.foreach { partition =>
+        val hms_files = hms_util.hms_ext.listFiles(partition)
+      }
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "hms", num_files, partition_range, num_cores)
+  }
+
+  private def scanParallelHMS(result_output : String, iters : Int, db_name : String,
+                      table_name : String, partition_name : String, num_files : Int,
+                      partition_range : Int, min_sks : Seq[Int], num_cores : Int,
+                      thread_pool : ExecutionContext) : Unit = {
+
+    val hms_util = new HMSUtil()
+
+    val table = hms_util.hms_ext.getTable(db_name, table_name)
+
+    // Initialize multiple instances of hdfs clients because apparently they are not thread safe...
+    val file_systems = ArrayBuffer[FileSystem]()
+    for (i <- 0 until num_cores) {
+      file_systems.append(FileSystem.newInstance(table.location, hms_util.hms_ext.hadoopConf))
+    }
+
+    // dry run
+    for (i <- 0 until 10) {
+      val min_sk = min_sks(i)
+      val filters = constructHMSFilters(partition_name, min_sk, min_sk + partition_range)
+      val hms_partitions = hms_util.hms.listPartitionsByFilter(db_name, table_name,
+        filters, "UTC")
+      val num_tasks = num_cores.min(hms_partitions.length)
+      // split partitions into groups
+      val partition_groups = splitIntoBoundaries(0, hms_partitions.length, num_tasks)
+      // assign listfiles operation on each group of partitions to a single task
+      val tasks = (0 until num_tasks).map(j => Future {
+          for (k <- partition_groups(j)._1 until partition_groups(j)._2 ) {
+            val hms_files = file_systems(j).listStatus(new Path(hms_partitions(k).location)).toSeq
+          }
+      }(thread_pool))
+
+      // scalastyle:off awaitresult
+      Await.result(Future.sequence(tasks)(implicitly, thread_pool),
+        scala.concurrent.duration.Duration.Inf)
+      // scalastyle:on awaitresult
+    }
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val min_sk = min_sks(i + 10)
+      val filters = constructHMSFilters(partition_name, min_sk, min_sk + partition_range)
+      val start_time = Instant.now()
+      val hms_partitions = hms_util.hms.listPartitionsByFilter(db_name, table_name,
+        filters, "UTC")
+      val num_tasks = num_cores.min(hms_partitions.length)
+      // split partitions into groups
+      val partition_groups = splitIntoBoundaries(0, hms_partitions.length, num_tasks)
+      // assign listfiles operation of each partition group to a single task
+      val tasks = (0 until num_tasks).map(j => Future {
+        for (k <- partition_groups(j)._1 until partition_groups(j)._2 ) {
+          val hms_files = file_systems(j).listStatus(new Path(hms_partitions(k).location)).toSeq
+        }
+      }(thread_pool))
+
+      // scalastyle:off awaitresult
+      Await.result(Future.sequence(tasks)(implicitly, thread_pool),
+        scala.concurrent.duration.Duration.Inf)
+      // scalastyle:on awaitresult
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "phms", num_files, partition_range, num_cores)
+  }
+
+  private def constructTreeFilters(partition_name : String, min_sk: Int, max_sk: Int) :
+  Seq[Expression] = {
+    val filters = ArrayBuffer[Expression]()
+    val min_sk_str = "%012d".format(min_sk)
+    val max_sk_str = "%012d".format(max_sk)
+    val partition_pred = f"$partition_name >= '$partition_name=$min_sk_str' and " +
+      f"$partition_name < '$partition_name=$max_sk_str'"
+    filters.append(sql_parser.get.parseExpression(partition_pred))
+
+    filters
+  }
+
+  private def scanTree(result_output : String, iters : Int, db_name : String,
+                       table_name : String, partition_name : String, num_files : Int,
+                       partition_range : Int, min_sks : Seq[Int], tree_address : String,
+                       num_cores : Int) : Unit = {
+
+    val tree_util = new TreeUtil(tree_address)
+    // dry run
+    for (i <- 0 until 10) {
+      val min_sk = min_sks(i)
+      val filters = constructTreeFilters(partition_name, min_sk, min_sk + partition_range)
+      val tree_files = tree_util.tree.listFilesByFilter(db_name, table_name, filters, None)
+    }
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val min_sk = min_sks(i + 10)
+      val filters = constructTreeFilters(partition_name, min_sk, min_sk + partition_range)
+
+      val start_time = Instant.now()
+      val tree_files = tree_util.tree.listFilesByFilter(db_name, table_name, filters, None)
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "tree", num_files, partition_range, num_cores)
+  }
+
+  private def scanParallelTree(result_output : String, iters: Int, db_table_names: (String, String),
+                       partition_name : String, num_files : Int,
+                       partition_range : Int, min_sks : Seq[Int], tree_address : String,
+                       num_cores : Int, thread_pool : ExecutionContext) : Unit = {
+
+    val db_name = db_table_names._1
+    val table_name = db_table_names._2
+
+    val tree_util = new TreeUtil(tree_address)
+
+    // In case there are less cores than 10
+    val range_groups = splitIntoBoundaries(0, 10, num_cores)
+    val predicates = range_groups.map{ boundary =>
+      val pred_list = ArrayBuffer[String]()
+      for (j <- boundary._1 until boundary._2) {
+        pred_list += f"endswith($partition_name, '$j')"
+      }
+      pred_list.mkString(" or ")
+    }
+    val num_tasks = num_cores.min(10)
+
+    // dry run
+    for (i <- 0 until 10) {
+      val min_sk = min_sks(i)
+      // assign each range group to a single task
+      val tasks = (0 until num_tasks).map(j => Future {
+        val filters = ArrayBuffer[Expression]()
+        val min_sk_str = "%012d".format(min_sk)
+        val max_sk_str = "%012d".format(min_sk + partition_range)
+        val partition_pred = f"$partition_name >= '$partition_name=$min_sk_str' and " +
+          f"$partition_name < '$partition_name=$max_sk_str' and (${predicates(j)})"
+        filters.append(sql_parser.get.parseExpression(partition_pred))
+        val tree_files = tree_util.tree.listFilesByFilter(db_name, table_name, filters, None)
+      }(thread_pool))
+      // scalastyle:off awaitresult
+      Await.result(Future.sequence(tasks)(implicitly, thread_pool),
+        scala.concurrent.duration.Duration.Inf)
+      // scalastyle:on awaitresult
+
+    }
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val min_sk = min_sks(i + 10)
+      val start_time = Instant.now()
+      // assign each range group to a single task
+      val tasks = (0 until num_tasks).map(j => Future {
+        val filters = ArrayBuffer[Expression]()
+        val min_sk_str = "%012d".format(min_sk)
+        val max_sk_str = "%012d".format(min_sk + partition_range)
+        val partition_pred = f"$partition_name >= '$partition_name=$min_sk_str' and " +
+          f"$partition_name < '$partition_name=$max_sk_str' and (${predicates(j)})"
+        filters.append(sql_parser.get.parseExpression(partition_pred))
+        val tree_files = tree_util.tree.listFilesByFilter(db_name, table_name, filters, None)
+      }(thread_pool))
+      // scalastyle:off awaitresult
+      Await.result(Future.sequence(tasks)(implicitly, thread_pool),
+        scala.concurrent.duration.Duration.Inf)
+      // scalastyle:on awaitresult
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "ptree", num_files, partition_range, num_cores)
+  }
+
+  private def constructIcebergFilters(partition_name : String, min_sk: Int, offset: Int) :
+  org.apache.iceberg.expressions.Expression = {
+    val partition_pred = f"${partition_name} >= $min_sk and " +
+      f"${partition_name} < ${min_sk + offset}"
+
+    SparkExpressionConverter
+      .convertToIcebergExpression(sql_parser.get.parseExpression(partition_pred))
+  }
+
+  private def scanIceberg(result_output : String, iters : Int, db_name : String,
+                          table_name : String, partition_name : String, num_files : Int,
+                          partition_range : Int, min_sks : Seq[Int], num_cores : Int) : Unit = {
+
+    val iceberg_util = new IcebergUtil()
+    // dry run
+    for (i <- 0 until 10) {
+      val min_sk = min_sks(i)
+      val filters = constructIcebergFilters(partition_name, min_sk, partition_range)
+
+      val iceberg_table = iceberg_util.iceberg
+        .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+      val iceberg_plan_files = iceberg_table.table().newScan().filter(filters).planFiles()
+      iceberg_plan_files.forEach { plan_file =>
+        val file = plan_file.file()
+      }
+    }
+
+    // actual experiment
+    val times = ArrayBuffer[Long]()
+    for (i <- 0 until iters) {
+      val min_sk = min_sks(i + 10)
+      val filters = constructIcebergFilters(partition_name, min_sk, partition_range)
+
+      val start_time = Instant.now()
+      val iceberg_table = iceberg_util.iceberg
+        .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+      val iceberg_plan_files = iceberg_table.table().newScan().filter(filters).planFiles()
+      iceberg_plan_files.forEach { plan_file =>
+        val file = plan_file.file()
+      }
+      val end_time = Instant.now()
+      times += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "iceberg", num_files, partition_range, num_cores)
+  }
+
+}
\ No newline at end of file
diff --git a/exp/src/main/scala/org/apache/spark/exp/TPCDSExperiment.scala b/exp/src/main/scala/org/apache/spark/exp/TPCDSExperiment.scala
new file mode 100644
index 00000000000..903a4bcd0eb
--- /dev/null
+++ b/exp/src/main/scala/org/apache/spark/exp/TPCDSExperiment.scala
@@ -0,0 +1,615 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.exp
+
+import java.io.File
+import java.io.FileWriter
+import java.time.{Duration, Instant}
+import java.time.LocalDate
+import java.time.format.DateTimeFormatter
+
+import scala.collection.mutable
+import scala.collection.mutable.ArrayBuffer
+import scala.io.Source
+
+import com.fasterxml.jackson.databind.ObjectMapper
+import com.fasterxml.jackson.databind.node.JsonNodeType
+import org.apache.iceberg.spark.source.SparkTable
+
+import org.apache.spark.sql.catalyst.expressions.Expression
+import org.apache.spark.sql.connector.catalog.Identifier
+import org.apache.spark.sql.delta.catalog.DeltaTableV2
+import org.apache.spark.sql.execution.SparkSqlParser
+import org.apache.spark.sql.execution.datasources.{HadoopFsRelation, SparkExpressionConverter}
+
+
+
+object TPCDSExperiment {
+  private val sql_parser = new SparkSqlParser()
+  val misc_config = scala.collection.mutable.Map.empty[String, String]
+  misc_config.put("resultOutput", "/tmp/dsexperiment.json")
+  misc_config.put("experimentIters", "10")
+  misc_config.put("scaleFactor", "100T")
+  misc_config.put("treeAddress", "localhost:9876")
+  misc_config.put("startDate", "1998-01-01")
+  misc_config.put("endDate", "2003-12-31")
+  misc_config.put("seed", "0")
+
+  def main(args: Array[String]): Unit = {
+    if (args.size != 3) {
+      print("Usage: spark-class org.apache.spark.exp.TPCDSExperiment " +
+        "<dataConfig> <workloadConfig> <catalogType>\n")
+      return
+    }
+
+    val catalog_type = args(2)
+    val json_parser = new ObjectMapper
+    // read in data config
+    val data_config_json = json_parser.readTree(Source.fromFile(args(0)).mkString)
+    // read in workload config
+    val workload_config_json = json_parser.readTree(Source.fromFile(args(1)).mkString)
+    // initialize misc config map
+    workload_config_json.get("misc").fields().forEachRemaining { config =>
+      misc_config.put(config.getKey, config.getValue.asText())
+    }
+
+    val result_output = misc_config("resultOutput")
+    val iters = misc_config("experimentIters").toInt
+    val tree_address = misc_config("treeAddress")
+
+    val delta_db = data_config_json.get("delta").asText()
+    val hms_db = data_config_json.get("hms").asText()
+    val tree_db = data_config_json.get("tree").asText()
+    val iceberg_db = data_config_json.get("iceberg").asText()
+
+    val read_config = new ReadConfig(workload_config_json.get("read"))
+
+    val table_configs = scala.collection.mutable.HashMap[String, TableConfig]()
+    data_config_json.get("tables").forEach { table_json =>
+      table_configs.put(table_json.get("name").asText(), new TableConfig(table_json,
+        misc_config("scaleFactor")))
+    }
+
+    // initialize the dates
+    val date_formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
+    val start_date = LocalDate.parse(misc_config("startDate"), date_formatter)
+    val end_date = LocalDate.parse(misc_config("endDate"), date_formatter)
+    val dates: Array[String] = Iterator.iterate(start_date)(_ plusDays 1) // Generate dates
+      .takeWhile(!_.isAfter(end_date)) // Stop when exceeding the end date
+      .map(_.format(date_formatter)) // Convert to formatted strings
+      .toArray
+
+    val random = new scala.util.Random(misc_config("seed").toLong)
+    catalog_type match {
+      case "delta" => testDelta(result_output, iters, delta_db, read_config, table_configs, random)
+      case "hms" => testHMS(result_output, iters, hms_db, read_config, table_configs, random)
+      case "iceberg" => testIceberg(result_output, iters, iceberg_db, read_config, table_configs,
+        random)
+      case "tree" => testTree(result_output, iters, tree_db, read_config, table_configs, random,
+        tree_address)
+      case _ => print("Invalid Catalog Type!!!")
+    }
+  }
+
+  private def writeOutput(result_output : String, times : mutable.HashMap[Int, ArrayBuffer[Long]],
+                          catalog : String): Unit = {
+    val output_writer = new FileWriter(new File(result_output), true)
+    times.foreach { time_list =>
+      val query_name = "query" + (time_list._1 + 1)
+      time_list._2.foreach { time =>
+        output_writer.write("{\"catalog\":\"" + catalog + "\", ")
+        output_writer.write("\"query\":\"" + query_name + "\", ")
+        output_writer.write("\"time\":" + time + "}")
+        output_writer.write("\n")
+      }
+    }
+    output_writer.flush()
+    output_writer.close()
+  }
+
+  private def constructHMSFilters(partition_name : String, sk: Int) :
+  Seq[Expression] = {
+    val filters = ArrayBuffer[Expression]()
+    val partition_pred = f"${partition_name} = $sk"
+    filters.append(sql_parser.parseExpression(partition_pred))
+
+    filters
+  }
+
+  private def constructHMSFilters(partition_name : String, min_sk: Int, max_sk: Int) :
+  Seq[Expression] = {
+    val filters = ArrayBuffer[Expression]()
+    val partition_pred = f"${partition_name} >= $min_sk and " +
+      f"${partition_name} <= $max_sk"
+    filters.append(sql_parser.parseExpression(partition_pred))
+
+    filters
+  }
+
+  private def testDelta(result_output : String, iters : Int, db_name : String,
+                        read_config : ReadConfig,
+                        table_configs : mutable.HashMap[String, TableConfig],
+                        random : scala.util.Random) : Unit = {
+
+    val delta_util = new DeltaUtil()
+
+    // dry run
+    for (i <- 0 until (iters / 10)) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val deltaTable = delta_util.delta.loadTable(Identifier.of(Array(db_name), table_name))
+          val baseRelation = deltaTable.asInstanceOf[DeltaTableV2].toBaseRelation
+            .asInstanceOf[HadoopFsRelation]
+          val deltaPartitions = baseRelation.location.listFiles(Seq.empty, Seq.empty)
+
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+          val partition_range = table_json.get("range")
+
+          val filters = if (partition_range.size() == 1) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt())
+          }
+          else if (partition_range.size() == 2) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt(),
+              partition_range.get(1).asInt())
+          }
+          else {
+            ArrayBuffer[Expression]()
+          }
+
+          val deltaTable = delta_util.delta.loadTable(Identifier.of(Array(db_name), table_name))
+          val baseRelation = deltaTable.asInstanceOf[DeltaTableV2].toBaseRelation
+            .asInstanceOf[HadoopFsRelation]
+          val deltaPartitions = baseRelation.location.listFiles(filters, Seq.empty)
+
+        }
+
+      }
+
+    }
+
+    // actual experiment
+    val times = mutable.HashMap[Int, ArrayBuffer[Long]]()
+    for (i <- 0 until iters) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+
+      val start_time = Instant.now()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val deltaTable = delta_util.delta.loadTable(Identifier.of(Array(db_name), table_name))
+          val baseRelation = deltaTable.asInstanceOf[DeltaTableV2].toBaseRelation
+            .asInstanceOf[HadoopFsRelation]
+          val deltaPartitions = baseRelation.location.listFiles(Seq.empty, Seq.empty)
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+
+          val partition_range = table_json.get("range")
+
+          val filters = if (partition_range.size() == 1) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt())
+          }
+          else if (partition_range.size() == 2) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt(),
+              partition_range.get(1).asInt())
+          }
+          else {
+            ArrayBuffer[Expression]()
+          }
+
+          val deltaTable = delta_util.delta.loadTable(Identifier.of(Array(db_name), table_name))
+          val baseRelation = deltaTable.asInstanceOf[DeltaTableV2].toBaseRelation
+            .asInstanceOf[HadoopFsRelation]
+          val deltaPartitions = baseRelation.location.listFiles(filters, Seq.empty)
+        }
+
+      }
+      val end_time = Instant.now()
+
+      if (!times.contains(query_idx)) {
+        times.put(query_idx, new ArrayBuffer[Long])
+      }
+
+      times(query_idx) += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "delta")
+  }
+
+  private def testHMS(result_output : String, iters : Int, db_name : String,
+                        read_config : ReadConfig,
+                        table_configs : mutable.HashMap[String, TableConfig],
+                        random : scala.util.Random) : Unit = {
+
+    val hms_util = new HMSUtil()
+
+    // dry run
+    for (i <- 0 until (iters / 10)) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val table = hms_util.hms.getTable(db_name, table_name)
+          val hmsFiles = hms_util.hms_ext.listFiles(table)
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+          val partition_range = table_json.get("range")
+
+          val filters = if (partition_range.size() == 1) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt())
+          }
+          else if (partition_range.size() == 2) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt(),
+              partition_range.get(1).asInt())
+          }
+          else {
+            ArrayBuffer[Expression]()
+          }
+
+          val hms_partitions = hms_util.hms.listPartitionsByFilter(db_name, table_name,
+            filters, "UTC")
+          hms_partitions.foreach { partition =>
+            val hms_files = hms_util.hms_ext.listFiles(partition)
+          }
+
+        }
+
+      }
+
+    }
+
+    // actual experiment
+    val times = mutable.HashMap[Int, ArrayBuffer[Long]]()
+    for (i <- 0 until iters) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+
+      val start_time = Instant.now()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val table = hms_util.hms.getTable(db_name, table_name)
+          val hmsFiles = hms_util.hms_ext.listFiles(table)
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+
+          val partition_range = table_json.get("range")
+
+          val filters = if (partition_range.size() == 1) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt())
+          }
+          else if (partition_range.size() == 2) {
+            constructHMSFilters(partition_col_name, partition_range.get(0).asInt(),
+              partition_range.get(1).asInt())
+          }
+          else {
+            ArrayBuffer[Expression]()
+          }
+
+          val hms_partitions = hms_util.hms.listPartitionsByFilter(db_name, table_name,
+            filters, "UTC")
+          hms_partitions.foreach { partition =>
+            val hms_files = hms_util.hms_ext.listFiles(partition)
+          }
+
+        }
+
+      }
+      val end_time = Instant.now()
+
+      if (!times.contains(query_idx)) {
+        times.put(query_idx, new ArrayBuffer[Long])
+      }
+
+      times(query_idx) += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "hms")
+  }
+
+  private def constructTreeFilters(partition_name : String, sk: Int) :
+  Seq[Expression] = {
+    val filters = ArrayBuffer[Expression]()
+    val sk_str = "%012d".format(sk)
+    val partition_pred = f"$partition_name = '$partition_name=$sk_str'"
+    filters.append(sql_parser.parseExpression(partition_pred))
+
+    filters
+  }
+
+  private def constructTreeFilters(partition_name : String, min_sk: Int, max_sk: Int) :
+  Seq[Expression] = {
+    val filters = ArrayBuffer[Expression]()
+    val min_sk_str = "%012d".format(min_sk)
+    val max_sk_str = "%012d".format(max_sk)
+    val partition_pred = f"$partition_name >= '$partition_name=$min_sk_str' and " +
+      f"$partition_name <= '$partition_name=$max_sk_str'"
+    filters.append(sql_parser.parseExpression(partition_pred))
+
+    filters
+  }
+
+  private def testTree(result_output : String, iters : Int, db_name : String,
+                      read_config : ReadConfig,
+                      table_configs : mutable.HashMap[String, TableConfig],
+                      random : scala.util.Random, tree_address : String) : Unit = {
+
+    val tree_util = new TreeUtil(tree_address)
+
+    // dry run
+    for (i <- 0 until (iters / 10)) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val tree_files = tree_util.tree.listFiles(db_name, table_name, None)
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+          val partition_range = table_json.get("range")
+
+          val filters = if (partition_range.size() == 1) {
+            constructTreeFilters(partition_col_name, partition_range.get(0).asInt())
+          }
+          else if (partition_range.size() == 2) {
+            constructTreeFilters(partition_col_name, partition_range.get(0).asInt(),
+              partition_range.get(1).asInt())
+          }
+          else {
+            ArrayBuffer[Expression]()
+          }
+
+          val tree_files = tree_util.tree.listFilesByFilter(db_name, table_name, filters, None)
+
+        }
+
+      }
+
+    }
+
+    // actual experiment
+    val times = mutable.HashMap[Int, ArrayBuffer[Long]]()
+    for (i <- 0 until iters) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+
+      val start_time = Instant.now()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val tree_files = tree_util.tree.listFiles(db_name, table_name, None)
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+
+          val partition_range = table_json.get("range")
+
+          val filters = if (partition_range.size() == 1) {
+            constructTreeFilters(partition_col_name, partition_range.get(0).asInt())
+          }
+          else if (partition_range.size() == 2) {
+            constructTreeFilters(partition_col_name, partition_range.get(0).asInt(),
+              partition_range.get(1).asInt())
+          }
+          else {
+            ArrayBuffer[Expression]()
+          }
+
+          val tree_files = tree_util.tree.listFilesByFilter(db_name, table_name, filters, None)
+        }
+
+      }
+      val end_time = Instant.now()
+
+      if (!times.contains(query_idx)) {
+        times.put(query_idx, new ArrayBuffer[Long])
+      }
+
+      times(query_idx) += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "tree")
+  }
+
+  private def constructIcebergFilters(partition_name : String, sk: Int) :
+  org.apache.iceberg.expressions.Expression = {
+    val partition_pred = f"${partition_name} = $sk"
+
+    SparkExpressionConverter
+      .convertToIcebergExpression(sql_parser.parseExpression(partition_pred))
+  }
+
+  private def constructIcebergFilters(partition_name : String, min_sk: Int, max_sk: Int) :
+  org.apache.iceberg.expressions.Expression = {
+    val partition_pred = f"${partition_name} >= $min_sk and " +
+      f"${partition_name} <= ${max_sk}"
+
+    SparkExpressionConverter
+      .convertToIcebergExpression(sql_parser.parseExpression(partition_pred))
+  }
+
+  private def testIceberg(result_output : String, iters : Int, db_name : String,
+                       read_config : ReadConfig,
+                       table_configs : mutable.HashMap[String, TableConfig],
+                       random : scala.util.Random) : Unit = {
+
+    val iceberg_util = new IcebergUtil()
+
+    // dry run
+    for (i <- 0 until (iters / 10)) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val iceberg_table = iceberg_util.iceberg
+            .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+          val iceberg_plan_files = iceberg_table.table().newScan().planFiles()
+          iceberg_plan_files.forEach { plan_file =>
+            val file = plan_file.file()
+          }
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+          val partition_range = table_json.get("range")
+
+          if (partition_range.size() == 1) {
+            val filters = constructIcebergFilters(partition_col_name, partition_range.get(0)
+              .asInt())
+            val iceberg_table = iceberg_util.iceberg
+              .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+            val iceberg_plan_files = iceberg_table.table().newScan().filter(filters).planFiles()
+            iceberg_plan_files.forEach { plan_file =>
+              val file = plan_file.file()
+            }
+          }
+          else if (partition_range.size() == 2) {
+            val filters = constructIcebergFilters(partition_col_name, partition_range.get(0)
+              .asInt(), partition_range.get(1).asInt())
+            val iceberg_table = iceberg_util.iceberg
+              .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+            val iceberg_plan_files = iceberg_table.table().newScan().filter(filters).planFiles()
+            iceberg_plan_files.forEach { plan_file =>
+              val file = plan_file.file()
+            }
+          }
+          else {
+            ArrayBuffer[Expression]()
+            val iceberg_table = iceberg_util.iceberg
+              .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+            val iceberg_plan_files = iceberg_table.table().newScan().planFiles()
+            iceberg_plan_files.forEach { plan_file =>
+              val file = plan_file.file()
+            }
+          }
+
+        }
+
+      }
+
+    }
+
+    // actual experiment
+    val times = mutable.HashMap[Int, ArrayBuffer[Long]]()
+    for (i <- 0 until iters) {
+      val query_idx = random.nextInt(read_config.queries.length)
+      val query_config = read_config.queries(query_idx)
+      val table_jsons = query_config.elements().next()
+
+      val start_time = Instant.now()
+      table_jsons.forEach{ table_json =>
+        // if json is simply a string, it specifies a dimension table
+        if (table_json.getNodeType() == JsonNodeType.STRING) {
+          val table_name = table_json.asText()
+          val iceberg_table = iceberg_util.iceberg
+            .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+          val iceberg_plan_files = iceberg_table.table().newScan().planFiles()
+          iceberg_plan_files.forEach { plan_file =>
+            val file = plan_file.file()
+          }
+        }
+        // otherwise (json object), a partitioned fact table
+        else {
+          val table_name = table_json.get("name").asText()
+          val partition_col_name = table_configs(table_name).partition_schema.head.name
+          val partition_range = table_json.get("range")
+
+          if (partition_range.size() == 1) {
+            val filters = constructIcebergFilters(partition_col_name, partition_range.get(0)
+              .asInt())
+            val iceberg_table = iceberg_util.iceberg
+              .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+            val iceberg_plan_files = iceberg_table.table().newScan().filter(filters).planFiles()
+            iceberg_plan_files.forEach { plan_file =>
+              val file = plan_file.file()
+            }
+          }
+          else if (partition_range.size() == 2) {
+            val filters = constructIcebergFilters(partition_col_name, partition_range.get(0)
+              .asInt(), partition_range.get(1).asInt())
+            val iceberg_table = iceberg_util.iceberg
+              .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+            val iceberg_plan_files = iceberg_table.table().newScan().filter(filters).planFiles()
+            iceberg_plan_files.forEach { plan_file =>
+              val file = plan_file.file()
+            }
+          }
+          else {
+            ArrayBuffer[Expression]()
+            val iceberg_table = iceberg_util.iceberg
+              .loadTable(Identifier.of(Array(db_name), table_name)).asInstanceOf[SparkTable]
+            val iceberg_plan_files = iceberg_table.table().newScan().planFiles()
+            iceberg_plan_files.forEach { plan_file =>
+              val file = plan_file.file()
+            }
+          }
+
+        }
+
+      }
+      val end_time = Instant.now()
+
+      if (!times.contains(query_idx)) {
+        times.put(query_idx, new ArrayBuffer[Long])
+      }
+
+      times(query_idx) += Duration.between(start_time, end_time).toNanos()
+    }
+
+    writeOutput(result_output, times, "iceberg")
+  }
+
+}
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index a681adba193..4d92c8bf476 100644
--- a/pom.xml
+++ b/pom.xml
@@ -91,6 +91,8 @@
     <module>sql/catalyst</module>
     <module>sql/core</module>
     <module>sql/hive</module>
+    <module>tree</module>
+    <module>exp</module>
     <module>assembly</module>
     <module>examples</module>
     <module>repl</module>
@@ -104,7 +106,9 @@
     <module>connector/connect/common</module>
     <module>connector/connect/client/jvm</module>
     <module>connector/protobuf</module>
-    <!-- See additional modules enabled by profiles below -->
+
+
+      <!-- See additional modules enabled by profiles below -->
   </modules>
 
   <properties>
@@ -940,6 +944,21 @@
       </dependency>
       <!-- Netty End -->
 
+      <dependency>
+        <groupId>org.mongodb</groupId>
+        <artifactId>bson</artifactId>
+        <version>4.11.2</version>
+      </dependency>
+      <dependency>
+        <groupId>io.delta</groupId>
+        <artifactId>delta-core_2.12</artifactId>
+        <version>2.4.0</version>
+      </dependency>
+      <dependency>
+        <groupId>org.apache.iceberg</groupId>
+        <artifactId>iceberg-spark-runtime-3.4_2.12</artifactId>
+        <version>1.5.2</version>
+      </dependency>
       <dependency>
         <groupId>org.apache.derby</groupId>
         <artifactId>derby</artifactId>
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/catalog/interface.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/catalog/interface.scala
index 08dd2dfd5bc..8ee1b545c9b 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/catalog/interface.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/catalog/interface.scala
@@ -168,6 +168,59 @@ case class CatalogTablePartition(
   }
 }
 
+/**
+ * A file (Hive style) defined in the catalog.
+ * @param storage storage format of the file
+ * @param partitionValues partition spec values indexed by column name
+ * @param size: size of the file
+ * @param modificationTime creation time of the file, in milliseconds
+ * @param stats optional statistics (number of rows, total size, etc.)
+ * @param optional tags
+ */
+case class CatalogTableFile(
+    storage: CatalogStorageFormat,
+    partitionValues: CatalogTypes.TablePartitionSpec,
+    size: Long,
+    modificationTime: Long = System.currentTimeMillis,
+    stats: Option[CatalogStatistics] = None,
+    tags: Map[String, String] = Map.empty) {
+
+  def toLinkedHashMap: mutable.LinkedHashMap[String, String] = {
+    val map = new mutable.LinkedHashMap[String, String]()
+    map ++= storage.toLinkedHashMap
+    val partValString = partitionValues.map { case (k, v) => s"$k=$v" }.mkString(", ")
+    map.put("Partition Values", s"[$partValString]")
+    map.put("Size", size.toString)
+    map.put("Modification Time", new Date(modificationTime).toString)
+    stats.foreach(s => map.put("File Statistics", s.simpleString))
+    if (tags.nonEmpty) {
+      map.put("File Tags", s"{" +
+        s"${tags.map(p => p._1 + "=" + p._2).mkString(", ")}}")
+    }
+    map
+  }
+
+  override def toString: String = {
+    toLinkedHashMap.map { case ((key, value)) =>
+      if (value.isEmpty) key else s"$key: $value"
+    }.mkString("CatalogTableFile(\n\t", "\n\t", ")")
+  }
+
+  /** Readable string representation for the CatalogTableFile. */
+  def simpleString: String = {
+    toLinkedHashMap.map { case ((key, value)) =>
+      if (value.isEmpty) key else s"$key: $value"
+    }.mkString("", "\n", "")
+  }
+
+  /** Return the partition location, assuming it is specified. */
+  def location: URI = storage.locationUri.getOrElse {
+    val specString = partitionValues.map { case (k, v) => s"$k=$v" }.mkString(", ")
+    throw QueryCompilationErrors.partitionNotSpecifyLocationUriError(specString)
+  }
+
+}
+
 
 /**
  * A container for bucketing information.
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/AbstractDataType.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/AbstractDataType.scala
index 294fb13e48c..5aa1cacc96a 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/AbstractDataType.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/AbstractDataType.scala
@@ -121,7 +121,7 @@ protected[sql] object AnyDataType extends AbstractDataType with Serializable {
 /**
  * An internal type used to represent everything that is not null, UDTs, arrays, structs, and maps.
  */
-protected[sql] abstract class AtomicType extends DataType {
+protected[spark] abstract class AtomicType extends DataType {
   private[sql] type InternalType
   private[sql] val tag: TypeTag[InternalType]
   private[sql] val ordering: Ordering[InternalType]
@@ -176,7 +176,7 @@ private[spark] object NumericType extends AbstractDataType {
 }
 
 
-private[sql] object IntegralType extends AbstractDataType {
+private[spark] object IntegralType extends AbstractDataType {
   /**
    * Enables matching against IntegralType for expressions:
    * {{{
@@ -194,12 +194,12 @@ private[sql] object IntegralType extends AbstractDataType {
 }
 
 
-private[sql] abstract class IntegralType extends NumericType {
+private[spark] abstract class IntegralType extends NumericType {
   private[sql] val integral: Integral[InternalType]
 }
 
 
-private[sql] object FractionalType {
+private[spark] object FractionalType {
   /**
    * Enables matching against FractionalType for expressions:
    * {{{
@@ -211,7 +211,7 @@ private[sql] object FractionalType {
 }
 
 
-private[sql] abstract class FractionalType extends NumericType {
+private[spark] abstract class FractionalType extends NumericType {
   private[sql] val fractional: Fractional[InternalType]
   private[sql] val asIntegral: Integral[InternalType]
 }
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/ArrayType.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/ArrayType.scala
index 9665385f046..8dcc27dd48f 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/ArrayType.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/ArrayType.scala
@@ -80,7 +80,7 @@ case class ArrayType(elementType: DataType, containsNull: Boolean) extends DataT
     }
   }
 
-  override private[sql] def jsonValue =
+  override private[spark] def jsonValue =
     ("type" -> typeName) ~
       ("elementType" -> elementType.jsonValue) ~
       ("containsNull" -> containsNull)
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/DataType.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/DataType.scala
index 13a7b03bc61..8c7dae47289 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/DataType.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/DataType.scala
@@ -74,7 +74,7 @@ abstract class DataType extends AbstractDataType {
       .toLowerCase(Locale.ROOT)
   }
 
-  private[sql] def jsonValue: JValue = typeName
+  private[spark] def jsonValue: JValue = typeName
 
   /** The compact JSON representation of this data type. */
   def json: String = compact(render(jsonValue))
@@ -217,7 +217,7 @@ object DataType {
   }
 
   // NOTE: Map fields must be sorted in alphabetical order to keep consistent with the Python side.
-  private[sql] def parseDataType(json: JValue): DataType = json match {
+  def parseDataType(json: JValue): DataType = json match {
     case JString(name) =>
       nameToType(name)
 
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/MapType.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/MapType.scala
index 48a8e77250a..faa5407a389 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/MapType.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/MapType.scala
@@ -55,7 +55,7 @@ case class MapType(
     }
   }
 
-  override private[sql] def jsonValue: JValue =
+  override private[spark] def jsonValue: JValue =
     ("type" -> typeName) ~
       ("keyType" -> keyType.jsonValue) ~
       ("valueType" -> valueType.jsonValue) ~
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/Metadata.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/Metadata.scala
index 3e05eda3443..32184d6ef34 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/Metadata.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/Metadata.scala
@@ -132,7 +132,7 @@ object Metadata {
   }
 
   /** Creates a Metadata instance from JSON AST. */
-  private[sql] def fromJObject(jObj: JObject): Metadata = {
+  def fromJObject(jObj: JObject): Metadata = {
     val builder = new MetadataBuilder
     jObj.obj.foreach {
       case (key, JInt(value)) =>
@@ -175,7 +175,7 @@ object Metadata {
   }
 
   /** Converts to JSON AST. */
-  private def toJsonValue(obj: Any): JValue = {
+  def toJsonValue(obj: Any): JValue = {
     obj match {
       case map: Map[_, _] =>
         val fields = map.toList.map { case (k, v) => (k.toString, toJsonValue(v)) }
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/StructType.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/StructType.scala
index 9ef3c4d60fd..c1eb45b03ea 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/StructType.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/StructType.scala
@@ -416,7 +416,7 @@ case class StructType(fields: Array[StructField]) extends DataType with Seq[Stru
     fields.foreach(field => field.buildFormattedString(prefix, stringConcat, maxDepth))
   }
 
-  override private[sql] def jsonValue =
+  override private[spark] def jsonValue =
     ("type" -> typeName) ~
       ("fields" -> map(_.jsonValue))
 
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/UserDefinedType.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/UserDefinedType.scala
index 5cbd876b31e..cdbfddf29ae 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/types/UserDefinedType.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/types/UserDefinedType.scala
@@ -58,7 +58,7 @@ abstract class UserDefinedType[UserType >: Null] extends DataType with Serializa
   /** Convert a SQL datum to the user type */
   def deserialize(datum: Any): UserType
 
-  override private[sql] def jsonValue: JValue = {
+  override private[spark] def jsonValue: JValue = {
     ("type" -> "udt") ~
       ("class" -> this.getClass.getName) ~
       ("pyClass" -> pyUDT) ~
@@ -124,7 +124,7 @@ private[sql] class PythonUserDefinedType(
   /* There is no Java class for Python UDT */
   override def userClass: java.lang.Class[Any] = null
 
-  override private[sql] def jsonValue: JValue = {
+  override private[spark] def jsonValue: JValue = {
     ("type" -> "udt") ~
       ("pyClass" -> pyUDT) ~
       ("serializedClass" -> serializedPyClass) ~
diff --git a/sql/hive/pom.xml b/sql/hive/pom.xml
index fd4070aa819..8c8a4ca653b 100644
--- a/sql/hive/pom.xml
+++ b/sql/hive/pom.xml
@@ -185,6 +185,11 @@
       <groupId>org.apache.derby</groupId>
       <artifactId>derby</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.mongodb</groupId>
+      <artifactId>bson</artifactId>
+      <version>4.11.2</version>
+    </dependency>
     <dependency>
       <groupId>org.scala-lang</groupId>
       <artifactId>scala-compiler</artifactId>
diff --git a/sql/hive/src/main/scala/org/apache/spark/sql/hive/HMSExtractor.scala b/sql/hive/src/main/scala/org/apache/spark/sql/hive/HMSExtractor.scala
new file mode 100644
index 00000000000..b7f21e05122
--- /dev/null
+++ b/sql/hive/src/main/scala/org/apache/spark/sql/hive/HMSExtractor.scala
@@ -0,0 +1,840 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.sql.hive
+
+import java.io.{File, FileWriter}
+import java.net.URI
+
+import scala.collection.mutable.ArrayBuffer
+import scala.collection.mutable.HashMap
+import scala.collection.mutable.Map
+import scala.io.Source
+import scala.util.matching.Regex
+
+import com.fasterxml.jackson.databind.ObjectMapper
+import org.apache.hadoop.fs.FileStatus
+import org.apache.hadoop.fs.Path
+import org.bson.BsonBinaryWriter
+import org.bson.RawBsonDocument
+import org.bson.io.BasicOutputBuffer
+import org.bson.json.JsonMode
+import org.bson.json.JsonWriterSettings
+import org.json4s.CustomSerializer
+import org.json4s.JsonAST.JNull
+import org.json4s.JsonAST.JObject
+import org.json4s.JsonAST.JString
+import org.json4s.NoTypeHints
+import org.json4s.jackson.Serialization
+
+import org.apache.spark.SparkConf
+import org.apache.spark.deploy.SparkHadoopUtil
+import org.apache.spark.internal.Logging
+import org.apache.spark.sql.catalyst.catalog.{CatalogColumnStat, CatalogStatistics, CatalogStorageFormat, CatalogTable, CatalogTableFile, CatalogTablePartition, CatalogTypes}
+import org.apache.spark.sql.types._
+import org.apache.spark.util._
+
+
+private[spark] class HMSClientExt(args: Seq[String], env:
+  scala.collection.immutable.Map[String, String] = sys.env)
+  extends Logging {
+  private val jsonWriterSetting : JsonWriterSettings = JsonWriterSettings.builder().
+    outputMode(JsonMode.RELAXED).build()
+
+  private implicit val formats = Serialization.formats(NoTypeHints) + new HiveURISerializer +
+    new HiveDataTypeSerializer + new HiveMetadataSerializer + new HiveStructTypeSerializer
+  var propertiesFile: String = null
+  var verbose: Boolean = false
+  val sparkProperties: HashMap[String, String] = new HashMap[String, String]()
+  lazy val defaultSparkProperties: HashMap[String, String] = {
+    val defaultProperties = new HashMap[String, String]()
+    if (verbose) {
+      logInfo(s"Using properties file: $propertiesFile")
+    }
+    Option(propertiesFile).foreach { filename =>
+      val properties = Utils.getPropertiesFromFile(filename)
+      properties.foreach { case (k, v) =>
+        defaultProperties(k) = v
+      }
+      // Property files may contain sensitive information, so redact before printing
+      if (verbose) {
+        Utils.redact(properties).foreach { case (k, v) =>
+          logInfo(s"Adding default property: $k=$v")
+        }
+      }
+    }
+    defaultProperties
+  }
+  mergeDefaultSparkProperties()
+
+  ignoreNonSparkProperties()
+
+  private val sparkConf = toSparkConf()
+
+  val hadoopConf = SparkHadoopUtil.get.newConfiguration(sparkConf)
+
+  lazy val client = new HiveExternalCatalog(sparkConf, hadoopConf)
+  private class HiveURISerializer extends CustomSerializer[URI](format =>
+    (
+      {
+        case JString(s) => URI.create(s)
+        case JNull => null
+      },
+      { case x: URI =>
+        JString(x.toString)
+      }
+    )
+  )
+
+  private class HiveDataTypeSerializer extends CustomSerializer[DataType](format =>
+    (
+      {
+        case JObject(o) => DataType.parseDataType(JObject(o))
+        case JNull => null
+      },
+      { case x: DataType =>
+        x.jsonValue
+      }
+    )
+  )
+
+  // have to cast as case class of Datatype for each one
+//  private class HiveArrayTypeSerializer extends CustomSerializer[ArrayType](format =>
+//    (
+//      {
+//        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[ArrayType]
+//        case JNull => null
+//      },
+//      { case x: ArrayType =>
+//        x.jsonValue
+//      }
+//    )
+//  )
+//
+//  private class HiveMapTypeSerializer extends CustomSerializer[MapType](format =>
+//    (
+//      {
+//        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[MapType]
+//        case JNull => null
+//      },
+//      { case x: MapType =>
+//        x.jsonValue
+//      }
+//    )
+//  )
+
+  private class HiveStructTypeSerializer extends CustomSerializer[StructType](format =>
+    (
+      {
+        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[StructType]
+        case JNull => null
+      },
+      { case x: StructType =>
+        x.jsonValue
+      }
+    )
+  )
+
+//  private class HiveUserDefinedTypeSerializer extends
+//    CustomSerializer[UserDefinedType[Any]](format =>
+//    (
+//      {
+//        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[UserDefinedType[Any]]
+//        case JNull => null
+//      },
+//      { case x: UserDefinedType[Any] =>
+//        x.jsonValue
+//      }
+//    )
+//  )
+//
+//  private class HivePythonUserDefinedTypeSerializer extends
+//    CustomSerializer[PythonUserDefinedType](format =>
+//    (
+//      {
+//        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[PythonUserDefinedType]
+//        case JNull => null
+//      },
+//      { case x: PythonUserDefinedType =>
+//        x.jsonValue
+//      }
+//    )
+//  )
+
+  private class HiveMetadataSerializer extends CustomSerializer[Metadata](format =>
+    (
+      {
+        case JObject(o) => Metadata.fromJObject(JObject(o))
+        case JNull => null
+      },
+      { case x: Metadata =>
+        Metadata.toJsonValue(x)
+      }
+    )
+  )
+
+  private def mergeDefaultSparkProperties(): Unit = {
+    // Use common defaults file, if not specified by user
+    propertiesFile = Option(propertiesFile).getOrElse(Utils.getDefaultPropertiesFile(env))
+    // Honor --conf before the defaults file
+    defaultSparkProperties.foreach { case (k, v) =>
+      if (!sparkProperties.contains(k)) {
+        sparkProperties(k) = v
+      }
+    }
+  }
+
+  private def ignoreNonSparkProperties(): Unit = {
+    sparkProperties.keys.foreach { k =>
+      if (!k.startsWith("spark.")) {
+        sparkProperties -= k
+        logWarning(s"Ignoring non-Spark config property: $k")
+      }
+    }
+  }
+
+  private def toSparkConf(sparkConf: Option[SparkConf] = None): SparkConf = {
+    // either use an existing config or create a new empty one
+    sparkProperties.foldLeft(sparkConf.getOrElse(new SparkConf())) {
+      case (conf, (k, v)) => conf.set(k, v)
+    }
+  }
+
+  def getTable(db_name : String, table_name : String) : CatalogTable = {
+    client.getTable(db_name, table_name)
+  }
+
+  def getDBJson(db_name : String) : String = {
+    val database = client.getDatabase(db_name)
+    val db_prefix = "{\"meta\": {\"paths\": [\"/" + db_name +
+      "\"], \"obj_kind\": 0}, \"val\": {\"obj_type\": \"database\", "
+    val json_brace : Regex = "\\{".r
+    val db_json = Serialization.write(database)
+    json_brace.replaceFirstIn(db_json, db_prefix) + "}"
+  }
+
+  def getTableJson(table : CatalogTable, obj_kind : Int) : String = {
+    val table_prefix = "{\"meta\": {\"paths\": [\"/" + table.identifier.database.get +
+      "/" + table.identifier.table + "\"], \"obj_kind\": " + obj_kind.toString +
+      "}, \"val\": {\"obj_type\": \"table\", "
+    val json_brace : Regex = "\\{".r
+    val table_json = Serialization.write(table)
+    json_brace.replaceFirstIn(table_json, table_prefix) + "}"
+  }
+
+  def getPartitionJson(table : CatalogTable, partition :
+    CatalogTablePartition, obj_kind : Int) : String = {
+    val partition_prefix = "{\"meta\": {\"paths\": [\"/" + table.identifier.database.get +
+      "/" + table.identifier.table + getPartId(table, partition.spec) + "\"], \"obj_kind\": " +
+      obj_kind.toString + "}," + "\"val\": {\"obj_type\": \"partition\", "
+    val json_brace : Regex = "\\{".r
+    val partition_json = Serialization.write(partition)
+    json_brace.replaceFirstIn(partition_json, partition_prefix) + "}"
+  }
+
+  def getFileJson(table : CatalogTable, file : FileStatus, stats: Option[CatalogStatistics],
+                  file_sizes : scala.collection.mutable.Map[String, Long])
+      : String = {
+    val file_prefix = "{\"meta\": {\"paths\": [\"/" + table.identifier.database.get + "/" +
+      table.identifier.table + getFileId(file) + "\"], \"obj_kind\": 2}, " +
+      "\"val\": {"
+    val fileStorage = CatalogStorageFormat(Some(new URI(file.getPath.toString)),
+      table.storage.inputFormat, table.storage.outputFormat, table.storage.serde,
+      table.storage.compressed, table.storage.properties)
+    val fileObj = CatalogTableFile(fileStorage, Map.empty[String, String].toMap,
+      file.getLen, file.getModificationTime, stats, Map.empty[String, String].toMap)
+    val json_brace : Regex = "\\{".r
+
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+    writer.writeStartDocument()
+    writer.writeString("obj_type", "file")
+    writer.writeName("storage")
+    appendBson(writer, fileObj.storage)
+    writer.writeName("partitionValues")
+    appendBson(writer, fileObj.partitionValues)
+    if (file_sizes.contains(table.identifier.table)) {
+      writer.writeInt64("size", file_sizes(table.identifier.table))
+    }
+    else {
+      writer.writeInt64("size", fileObj.size)
+    }
+    writer.writeInt64("modificationTime", fileObj.modificationTime)
+    if (fileObj.stats.isDefined) {
+      writer.writeName("stats")
+      appendBson(writer, table, fileObj.stats.get)
+    }
+    writer.writeName("tags")
+    appendBson(writer, fileObj.tags)
+    writer.writeEndDocument()
+
+    val fileJson = new RawBsonDocument(outputBuffer.getInternalBuffer, 0, outputBuffer.getPosition)
+      .toJson(jsonWriterSetting)
+    json_brace.replaceFirstIn(fileJson, file_prefix) + "}"
+  }
+
+  def getFileJson(table : CatalogTable, partition : CatalogTablePartition,
+                  file : FileStatus, stats: Option[CatalogStatistics],
+                  file_sizes : scala.collection.mutable.Map[String, Long]) : String = {
+    val file_prefix = "{\"meta\": {\"paths\": [\"/" + table.identifier.database.get + "/" +
+      table.identifier.table + getPartId(table, partition.spec) + getFileId(file) +
+      "\"], \"obj_kind\": 2}, " +
+      "\"val\": {"
+    val fileStorage = CatalogStorageFormat(Some(new URI(file.getPath.toString)),
+      partition.storage.inputFormat, partition.storage.outputFormat, partition.storage.serde,
+      partition.storage.compressed, partition.storage.properties)
+    val fileObj = CatalogTableFile(fileStorage, partition.spec,
+      file.getLen, file.getModificationTime, stats, Map.empty[String, String].toMap)
+    val json_brace : Regex = "\\{".r
+
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+    writer.writeStartDocument()
+    writer.writeString("obj_type", "file")
+    writer.writeName("storage")
+    appendBson(writer, fileObj.storage)
+    writer.writeName("partitionValues")
+    appendBson(writer, fileObj.partitionValues)
+    if (file_sizes.contains(table.identifier.table)) {
+      writer.writeInt64("size", file_sizes(table.identifier.table))
+    }
+    else {
+      writer.writeInt64("size", fileObj.size)
+    }
+    writer.writeInt64("modificationTime", fileObj.modificationTime)
+    if (fileObj.stats.isDefined) {
+      writer.writeName("stats")
+      appendBson(writer, table, fileObj.stats.get)
+    }
+    writer.writeName("tags")
+    appendBson(writer, fileObj.tags)
+    writer.writeEndDocument()
+
+    val fileJson = new RawBsonDocument(outputBuffer.getInternalBuffer, 0, outputBuffer.getPosition)
+      .toJson(jsonWriterSetting)
+    json_brace.replaceFirstIn(fileJson, file_prefix) + "}"
+
+  }
+
+  private def appendBson(writer : BsonBinaryWriter, storage : CatalogStorageFormat) : Unit = {
+    writer.writeStartDocument()
+    if (storage.locationUri.isDefined) {
+      writer.writeString("locationUri", storage.locationUri.get.toString)
+    }
+    if (storage.inputFormat.isDefined) {
+      writer.writeString("inputFormat", storage.inputFormat.get)
+    }
+    if (storage.outputFormat.isDefined) {
+      writer.writeString("outputFormat", storage.outputFormat.get)
+    }
+    if (storage.serde.isDefined) {
+      writer.writeString("serde", storage.serde.get)
+    }
+    writer.writeBoolean("compressed", storage.compressed)
+    writer.writeName("properties")
+    appendBson(writer, storage.properties)
+    writer.writeEndDocument()
+  }
+
+  private def appendBson(writer : BsonBinaryWriter, map :
+      scala.collection.immutable.Map[String, String]) : Unit = {
+    writer.writeStartDocument()
+    map.foreach{ case (key, value) =>
+      writer.writeString(key, value)
+    }
+    writer.writeEndDocument()
+  }
+
+  private def appendBson(writer : BsonBinaryWriter, table: CatalogTable,
+      stats : CatalogStatistics) : Unit = {
+    writer.writeStartDocument()
+    writer.writeInt64("sizeInBytes", stats.sizeInBytes.toLong)
+    if (stats.rowCount.isDefined) {
+      writer.writeInt64("rowCount", stats.rowCount.get.toLong)
+    }
+    writer.writeName("colStats")
+    writer.writeStartDocument()
+
+    table.schema.fields.foreach{ field =>
+      val colStat = stats.colStats.get(field.name)
+      if (colStat.isDefined) {
+        writer.writeName(field.name)
+        appendBson(writer, field.dataType, colStat.get)
+      }
+    }
+
+    writer.writeEndDocument()
+    writer.writeEndDocument()
+  }
+
+  def getStatsJson(table: CatalogTable, partitionSpec: CatalogTypes.TablePartitionSpec,
+                   stats: CatalogStatistics) : String = {
+    val statsPrefix = "{\"meta\": {\"paths\": [\"/" + table.identifier.database.get + "/" +
+      table.identifier.table + getPartId(table, partitionSpec) + "/stats" +
+      "\"], \"obj_kind\": 0}, \"val\": {\"obj_type\": \"stats\", "
+    val jsonBrace : Regex = "\\{".r
+
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+      writer.writeStartDocument()
+      writer.writeInt64("sizeInBytes", stats.sizeInBytes.toLong)
+      if (stats.rowCount.isDefined) {
+        writer.writeInt64("rowCount", stats.rowCount.get.toLong)
+      }
+      writer.writeName("colStats")
+      writer.writeStartDocument()
+      table.schema.fields.foreach{ field =>
+        val colStat = stats.colStats.get(field.name)
+        if (colStat.isDefined) {
+          writer.writeName(field.name)
+          appendBson(writer, field.dataType, colStat.get)
+        }
+      }
+      writer.writeEndDocument()
+
+    writer.writeEndDocument()
+
+    val statsJson = new RawBsonDocument(outputBuffer.getInternalBuffer, 0, outputBuffer.getPosition)
+      .toJson(jsonWriterSetting)
+    jsonBrace.replaceFirstIn(statsJson, statsPrefix) + "}"
+  }
+
+  private def appendBson(writer : BsonBinaryWriter, dataType: DataType, colStat: CatalogColumnStat):
+  Unit = {
+    writer.writeStartDocument()
+    if (colStat.distinctCount.isDefined) {
+      writer.writeInt64("distinctCount", colStat.distinctCount.get.toLong)
+    }
+    if (colStat.min.isDefined) {
+      dataType match {
+        case ByteType => writer.writeInt32("min", colStat.min.get.toInt)
+        case ShortType => writer.writeInt32("min", colStat.min.get.toInt)
+        case IntegerType => writer.writeInt32("min", colStat.min.get.toInt)
+        case LongType => writer.writeInt64("min", colStat.min.get.toLong)
+        case BooleanType => writer.writeBoolean("min", colStat.min.get.toBoolean)
+        case FloatType => writer.writeDouble("min", colStat.min.get.toDouble)
+        case DoubleType => writer.writeDouble("min", colStat.min.get.toDouble)
+        case DecimalType.Fixed(_, _) => writer.writeDouble("min", colStat.min.get.toDouble)
+        case _ => writer.writeString("min", colStat.min.get)
+      }
+    }
+    if (colStat.max.isDefined) {
+      dataType match {
+        case ByteType => writer.writeInt32("max", colStat.max.get.toInt)
+        case ShortType => writer.writeInt32("max", colStat.max.get.toInt)
+        case IntegerType => writer.writeInt32("max", colStat.max.get.toInt)
+        case LongType => writer.writeInt64("max", colStat.max.get.toLong)
+        case BooleanType => writer.writeBoolean("max", colStat.max.get.toBoolean)
+        case FloatType => writer.writeDouble("max", colStat.max.get.toDouble)
+        case DoubleType => writer.writeDouble("max", colStat.max.get.toDouble)
+        case DecimalType.Fixed(_, _) => writer.writeDouble("max", colStat.max.get.toDouble)
+        case _ => writer.writeString("max", colStat.max.get)
+      }
+    }
+    if (colStat.nullCount.isDefined) {
+      writer.writeInt64("nullCount", colStat.nullCount.get.toLong)
+    }
+    if (colStat.avgLen.isDefined) {
+      writer.writeInt64("avgLen", colStat.avgLen.get)
+    }
+    if (colStat.maxLen.isDefined) {
+      writer.writeInt64("maxLen", colStat.maxLen.get)
+    }
+    // no support for histogram
+    writer.writeInt32("version", colStat.version)
+
+    writer.writeEndDocument()
+  }
+
+  // helper function for merging partition values into table statistics
+  def mergePartitionVals(table: CatalogTable, base : CatalogStatistics, partitionSpec :
+                        CatalogTypes.TablePartitionSpec): CatalogStatistics = {
+    val colStats = Map(base.colStats.toSeq: _ *)
+    table.partitionSchema.foreach{ partCol =>
+      val delta = CatalogColumnStat(None, Some(partitionSpec(partCol.name)),
+        Some(partitionSpec(partCol.name)), None, None, None, None, 1)
+
+      val mergedColStat = mergeColStats(partCol, base.colStats.get(partCol.name),
+        Some(delta))
+      if (mergedColStat.isDefined) {
+        colStats.put(partCol.name, mergedColStat.get)
+      }
+    }
+    CatalogStatistics(base.sizeInBytes, base.rowCount, colStats.toMap)
+
+  }
+
+  def mergeStats(table : CatalogTable, base : CatalogStatistics,
+                 delta: CatalogStatistics): CatalogStatistics = {
+    val sizeInBytes = base.sizeInBytes + delta.sizeInBytes
+    val rowCount = {
+      if (base.rowCount.isDefined && delta.rowCount.isDefined) {
+        Some(base.rowCount.get + delta.rowCount.get)
+      }
+      else {
+        None
+      }
+    }
+    val colStats = Map.empty[String, CatalogColumnStat]
+    table.schema.foreach { attr =>
+      val mergedColStat = mergeColStats(attr, base.colStats.get(attr.name),
+        delta.colStats.get(attr.name))
+      if (mergedColStat.isDefined) {
+        colStats.put(attr.name, mergedColStat.get)
+      }
+    }
+    CatalogStatistics(sizeInBytes, rowCount, colStats.toMap)
+  }
+
+  // we assume that delta is always more "complete" than base
+  private def mergeColStats(attr: StructField, base: Option[CatalogColumnStat],
+                            delta: Option[CatalogColumnStat]) : Option[CatalogColumnStat] = {
+
+    if (base.isDefined) {
+      if (delta.isDefined) {
+        val min = {
+          if (base.get.min.isDefined && delta.get.min.isDefined) {
+            attr.dataType match {
+              case _: IntegralType =>
+                Some(base.get.min.get.toInt.min(delta.get.min.get.toInt).toString)
+              case _: FractionalType =>
+                val min_val = base.get.min.get.toDouble.max(delta.get.min.get.toDouble)
+                Some(f"$min_val%.2f")
+              case _ =>
+                Some(if (base.get.min.get < delta.get.min.get) base.get.min.get
+                else delta.get.min.get)
+            }
+          }
+          else {
+            None
+          }
+        }
+        val max = {
+          if (base.get.max.isDefined && delta.get.max.isDefined) {
+            attr.dataType match {
+              case _: IntegralType =>
+                Some(base.get.max.get.toInt.max(delta.get.max.get.toInt).toString)
+              case _: FractionalType =>
+                val max_val = base.get.max.get.toDouble.max(delta.get.max.get.toDouble)
+                Some(f"$max_val%.2f")
+              case _ =>
+                Some(if (base.get.max.get > delta.get.max.get) base.get.max.get
+                else delta.get.max.get)
+            }
+          }
+          else {
+            None
+          }
+        }
+        val nullCount = {
+          if (base.get.nullCount.isDefined && delta.get.nullCount.isDefined) {
+            Some(base.get.nullCount.get + delta.get.nullCount.get)
+          }
+          else {
+            None
+          }
+        }
+        Some(CatalogColumnStat(None, min, max, nullCount, None, None, None, 1))
+      }
+      else {
+        base
+      }
+    }
+    else if (delta.isDefined) {
+      delta
+    }
+    else {
+      None
+    }
+  }
+
+  def listTables(db_name : String) : Seq[String] = {
+    client.listTables(db_name)
+  }
+
+  def listPartitions(db_name : String, table_name : String) : Seq[CatalogTablePartition] = {
+    client.listPartitions(db_name, table_name, None)
+  }
+
+  def listFiles(table : CatalogTable) : Seq[FileStatus] = {
+    val table_path = new Path(table.location)
+    val fs = table_path.getFileSystem(hadoopConf)
+    fs.listStatus(table_path).toSeq
+  }
+
+  def listFiles(partition : CatalogTablePartition): Seq[FileStatus] = {
+    val partition_path = new Path(partition.location)
+    val fs = partition_path.getFileSystem(hadoopConf)
+    fs.listStatus(partition_path).toSeq
+  }
+
+  def extractStats(table : CatalogTable, file : FileStatus,
+                   file_sizes : scala.collection.mutable.Map[String, Long],
+                   rows_per_files : scala.collection.mutable.Map[String, Long])
+    : CatalogStatistics = {
+    val fs = file.getPath.getFileSystem(hadoopConf)
+    val dataBuf: Array[Byte] = new Array[Byte](file.getLen.toInt)
+    val ifstream = fs.open(file.getPath)
+    ifstream.readFully(dataBuf)
+    ifstream.close()
+    val schema = table.schema
+    val records = dataBuf.map(_.toChar).mkString.split("\n")
+      .map(_.replaceAll("[\n\r]", "").split(","))
+
+    var final_stats = CatalogStatistics(0, Some(0),
+      scala.collection.immutable.Map.empty[String, CatalogColumnStat])
+    records.indices.foreach { i =>
+      val col_stats = Map.empty[String, CatalogColumnStat]
+      records(i).indices.foreach { j =>
+        col_stats.put(schema(j).name, CatalogColumnStat(None, Some(records(i)(j)),
+          Some(records(i)(j)), Some(0), None, None, None, 1))
+      }
+      // leave out the file size and number of rows for now
+      val cur_stats = CatalogStatistics(0, Some(0), col_stats.toMap)
+      final_stats = mergeStats(table, final_stats, cur_stats)
+
+    }
+
+    val file_size : Long = if (file_sizes.contains(table.identifier.table)) {
+      file_sizes(table.identifier.table)
+    }
+    else {
+      file.getLen
+    }
+    val rows_per_file : Long = if (rows_per_files.contains(table.identifier.table)) {
+      rows_per_files(table.identifier.table)
+    }
+    else {
+      2
+    }
+
+    CatalogStatistics(file_size, Some(rows_per_file), final_stats.colStats)
+
+  }
+
+  private def getPartId(table : CatalogTable, partitionSpec : CatalogTypes.TablePartitionSpec)
+      : String = {
+    var partId = ""
+    table.partitionSchema.foreach { partitionColumn =>
+      if (partitionSpec.contains(partitionColumn.name)) {
+        val partitionVal = getPartitionVal(partitionColumn, partitionSpec)
+        partId = partId + "/" + partitionColumn.name + "=" + partitionVal
+      }
+    }
+
+    partId
+  }
+
+  private def getFileId(file : FileStatus) : String = {
+    val file_path = file.getPath.toString
+    file_path.slice(file_path.lastIndexOf('/'), file_path.size)
+  }
+
+  // precondition: corresponding partition val exists
+  private def getPartitionVal(partitionColumn: StructField,
+                              partitionSpec : CatalogTypes.TablePartitionSpec): String = {
+    val partitionVal = partitionSpec.get(partitionColumn.name).get
+    if (partitionColumn.dataType.isInstanceOf[IntegralType]) {
+      "%012d".format(partitionVal.toLong)
+    }
+    else {
+      partitionVal
+    }
+  }
+
+}
+/**
+ * Main function of the extractor
+ */
+private[spark] object HMSExtractor extends Logging {
+
+  def main(args: Array[String]): Unit = {
+    val hms_ext = new HMSClientExt(args.toSeq)
+    val db_name = args(0)
+    val file_writer = new FileWriter(new File(args(1)))
+    val file_sizes = scala.collection.mutable.Map.empty[String, Long]
+    val rows_per_files = scala.collection.mutable.Map.empty[String, Long]
+
+    if (args.length >= 4 ) {
+      val scale_factor = args(3)
+      val jsonParser = new ObjectMapper
+      jsonParser.readTree(Source.fromFile(args(2)).mkString).get("tables").forEach{ table =>
+          val num_rows = table.get("scaling").get(scale_factor).asLong()
+          val partition_schema_size = table.get("partitionSchema").size()
+          val schema_size = table.get("schema").size()
+          val bytes_per_row = 4 * (partition_schema_size + schema_size)
+          val rows_per_file = math.min(num_rows, 100000000 / bytes_per_row)
+          // we assume number of files exceeds number of partitions
+          val file_size = bytes_per_row * rows_per_file
+          file_sizes.put(table.get("name").asText(), file_size)
+          rows_per_files.put(table.get("name").asText(), rows_per_file)
+        }
+    }
+    else if (args.length < 3) {
+      print("Usage: spark-class org.apache.spark.sql.hive.HMSExtractor <dbName> <destFile> " +
+      "<dataConfig> <optional scalFactor>\n" )
+      return
+    }
+
+    // write the db object
+    val db_json = hms_ext.getDBJson(db_name)
+    file_writer.write(db_json + "\n")
+
+    val table_names = hms_ext.listTables(db_name)
+    table_names.foreach { table_name =>
+      val table = hms_ext.getTable(db_name, table_name)
+      var tableStats = CatalogStatistics(BigInt(0), Some(BigInt(0)),
+          Map.empty[String, CatalogColumnStat].toMap)
+      // non-partitioned table
+      if (table.partitionColumnNames.isEmpty) {
+        val table_json = hms_ext.getTableJson(table, 1)
+        file_writer.write(table_json + "\n")
+        val files = hms_ext.listFiles(table)
+        files.foreach { file =>
+          if (file.getLen > 0) {
+            val file_stats = hms_ext.extractStats(table, file, file_sizes, rows_per_files)
+            tableStats = hms_ext.mergeStats(table, tableStats, file_stats)
+            val file_json = hms_ext.getFileJson(table, file, Some(file_stats), file_sizes)
+            file_writer.write(file_json + "\n")
+          }
+        }
+      }
+      // partitioned table
+      else {
+        val table_json = hms_ext.getTableJson(table, 0)
+        file_writer.write(table_json + "\n")
+        val partitions = hms_ext.listPartitions(db_name, table_name)
+          .sortWith( compPartition(table.partitionColumnNames, _, _) )
+        // array for keeping track of current partition value at each level
+        val cur_part_vals = new ArrayBuffer[String]
+        table.partitionColumnNames.foreach { part_col =>
+          cur_part_vals += ""
+        }
+        // array for keeping track of current statistics at each level
+        val cur_part_stats = new ArrayBuffer[CatalogStatistics]
+
+        val emptyStorage = CatalogStorageFormat(None, None, None, None,
+            false, Map.empty[String, String].toMap)
+        partitions.foreach { partition =>
+          var diff = false
+          // new partition spec to build
+          val new_part_spec = Map.empty[String, String]
+          // previous partition spec for which statistics have to be flushed before new partition
+          // is added
+          val prev_part_spec = Map.empty[String, String]
+          table.partitionColumnNames.indices.foreach { i =>
+            new_part_spec.put(table.partitionColumnNames(i), partition.
+              spec(table.partitionColumnNames(i)))
+            prev_part_spec.put(table.partitionColumnNames(i), cur_part_vals(i))
+            if (!diff && partition.spec(table.partitionColumnNames(i)) != cur_part_vals(i)) {
+              diff = true
+              table.partitionColumnNames.indices.slice(i,
+                table.partitionColumnNames.size - 1).foreach { j =>
+                new_part_spec.put(table.partitionColumnNames(j), partition.
+                  spec(table.partitionColumnNames(j)))
+                prev_part_spec.put(table.partitionColumnNames(j), cur_part_vals(j))
+                cur_part_vals(j) = partition.spec(table.partitionColumnNames(j))
+                val new_part = CatalogTablePartition(new_part_spec.toMap,
+                  emptyStorage, Map.empty[String, String].toMap, partition.createTime, -1, None)
+                val partition_json = hms_ext.getPartitionJson(table, new_part, 0)
+                // before new partition is added, stats of the previous partition is flushed out
+                if (cur_part_stats.size > j) {
+                  // write the previous stat and replace it with empty stat
+                  val stats_json = hms_ext.getStatsJson(table, prev_part_spec.toMap,
+                      cur_part_stats(j))
+                  cur_part_stats(j) = CatalogStatistics(BigInt(0), Some(BigInt(0)),
+                      Map.empty[String, CatalogColumnStat].toMap)
+                  file_writer.write(stats_json + "\n")
+                }
+                else {
+                  // add empty stat object to the stats array
+                  cur_part_stats.append(CatalogStatistics(BigInt(0), Some(BigInt(0)),
+                    Map.empty[String, CatalogColumnStat].toMap))
+                }
+
+                file_writer.write(partition_json + "\n")
+              }
+            }
+          }
+          cur_part_vals(table.partitionColumnNames.size - 1) = partition.spec(table.
+            partitionColumnNames(table.partitionColumnNames.size - 1))
+          val partition_json = hms_ext.getPartitionJson(table, partition, 1)
+          file_writer.write(partition_json + "\n")
+          val files = hms_ext.listFiles(partition)
+          var leafStats = CatalogStatistics(BigInt(0), Some(BigInt(0)),
+              Map.empty[String, CatalogColumnStat].toMap)
+          files.foreach { file =>
+            if (file.getLen > 0) {
+              val file_stats = hms_ext.extractStats(table, file, file_sizes, rows_per_files)
+              cur_part_stats.indices.foreach { i =>
+                cur_part_stats(i) = hms_ext.mergeStats(table, cur_part_stats(i), file_stats)
+
+              }
+              tableStats = hms_ext.mergeStats(table, tableStats, file_stats)
+              leafStats = hms_ext.mergeStats(table, leafStats, file_stats)
+
+              val file_json = hms_ext.getFileJson(table, partition, file, Some(file_stats),
+                file_sizes)
+              file_writer.write(file_json + "\n")
+            }
+          }
+          // merge partition values into table statistics
+          tableStats = hms_ext.mergePartitionVals(table, tableStats, partition.spec)
+
+          val stats_json = hms_ext.getStatsJson(table, partition.spec, leafStats)
+          file_writer.write(stats_json + "\n")
+        }
+        // flush out partition stats that has not been written out to json
+        val partVals = Map.empty[String, String]
+        cur_part_stats.indices.foreach { i =>
+          val partStats = cur_part_stats(i)
+          partVals.put(table.partitionColumnNames(i), cur_part_vals(i))
+          // if the stats object is not empty, flush it out
+          if (!( partStats.sizeInBytes == BigInt(0) && partStats.rowCount.get == BigInt(0) &&
+              partStats.colStats.isEmpty)) {
+            val stats_json = hms_ext.getStatsJson(table, partVals.toMap, cur_part_stats(i))
+            file_writer.write(stats_json + "\n")
+          }
+        }
+      }
+
+      val tableStatsJson = hms_ext.getStatsJson(table, Map.empty[String, String].toMap, tableStats)
+      file_writer.write(tableStatsJson + "\n")
+    }
+    file_writer.close()
+  }
+
+  private def compPartition(part_cols : Seq[String], part1 : CatalogTablePartition,
+                            part2 : CatalogTablePartition): Boolean = {
+    var comp_val = 0
+    part_cols.foreach { part_col =>
+      if (comp_val == 0 && part1.spec(part_col) < part2.spec(part_col)) {
+        comp_val = -1
+      }
+      else if (comp_val == 0 && part1.spec(part_col) > part2.spec(part_col)) {
+        comp_val = 1
+      }
+    }
+
+    if (comp_val == -1 || comp_val == 0) {
+      true
+    }
+    else {
+      false
+    }
+  }
+}
diff --git a/sql/hive/src/main/scala/org/apache/spark/sql/hive/HiveExternalCatalog.scala b/sql/hive/src/main/scala/org/apache/spark/sql/hive/HiveExternalCatalog.scala
index 0c556cd34ed..7128db190bd 100644
--- a/sql/hive/src/main/scala/org/apache/spark/sql/hive/HiveExternalCatalog.scala
+++ b/sql/hive/src/main/scala/org/apache/spark/sql/hive/HiveExternalCatalog.scala
@@ -1294,7 +1294,8 @@ private[spark] class HiveExternalCatalog(conf: SparkConf, hadoopConf: Configurat
       client.getPartitionsByFilter(rawHiveTable, predicates).map { part =>
         part.copy(spec = restorePartitionSpec(part.spec, partColNameMap))
       }
-    prunePartitionsByFilter(catalogTable, clientPrunedPartitions, predicates, defaultTimeZoneId)
+    clientPrunedPartitions
+    // prunePartitionsByFilter(catalogTable, clientPrunedPartitions, predicates, defaultTimeZoneId)
   }
 
   // --------------------------------------------------------------------------
diff --git a/sql/hive/src/main/scala/org/apache/spark/sql/hive/TableReader.scala b/sql/hive/src/main/scala/org/apache/spark/sql/hive/TableReader.scala
index c5e8a9f1764..c0e4a56f53c 100644
--- a/sql/hive/src/main/scala/org/apache/spark/sql/hive/TableReader.scala
+++ b/sql/hive/src/main/scala/org/apache/spark/sql/hive/TableReader.scala
@@ -294,6 +294,8 @@ class HadoopTableReader(
       case Some(filter) =>
         val fs = path.getFileSystem(hadoopConf)
         val filteredFiles = fs.listStatus(path, filter).map(_.getPath.toString)
+        logWarning("Hive Trace: Listing files under " + path.toString )
+        logWarning("Hive Trace: " + filteredFiles.mkString(","))
         filteredFiles.mkString(",")
       case None => path.toString
     }
diff --git a/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveClientImpl.scala b/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveClientImpl.scala
index 48902a94593..10f36af653e 100644
--- a/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveClientImpl.scala
+++ b/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveClientImpl.scala
@@ -625,7 +625,6 @@ private[hive] class HiveClientImpl(
         it.remove()
       }
     }
-
     // set new schema table properties
     schemaProps.foreach { case (k, v) => oldTable.setProperty(k, v) }
 
diff --git a/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveShim.scala b/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveShim.scala
index 5e5d2757e9d..3ebbd9b3dc0 100644
--- a/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveShim.scala
+++ b/sql/hive/src/main/scala/org/apache/spark/sql/hive/client/HiveShim.scala
@@ -37,7 +37,6 @@ import org.apache.hadoop.hive.ql.metadata.{Hive, Partition, Table}
 import org.apache.hadoop.hive.ql.plan.AddPartitionDesc
 import org.apache.hadoop.hive.ql.processors.{CommandProcessor, CommandProcessorFactory}
 import org.apache.hadoop.hive.ql.session.SessionState
-import org.apache.hadoop.hive.serde.serdeConstants
 
 import org.apache.spark.internal.Logging
 import org.apache.spark.metrics.source.HiveCatalogMetrics
@@ -948,21 +947,21 @@ private[client] class Shim_v0_13 extends Shim_v0_12 {
 
     object SupportedAttribute {
       // hive varchar is treated as catalyst string, but hive varchar can't be pushed down.
-      private val varcharKeys = table.getPartitionKeys.asScala
-        .filter(col => col.getType.startsWith(serdeConstants.VARCHAR_TYPE_NAME) ||
-          col.getType.startsWith(serdeConstants.CHAR_TYPE_NAME))
-        .map(col => col.getName).toSet
+//      private val varcharKeys = table.getPartitionKeys.asScala
+//        .filter(col => col.getType.startsWith(serdeConstants.VARCHAR_TYPE_NAME) ||
+//          col.getType.startsWith(serdeConstants.CHAR_TYPE_NAME))
+//        .map(col => col.getName).toSet
 
       def unapply(attr: Attribute): Option[String] = {
-        val resolver = SQLConf.get.resolver
-        if (varcharKeys.exists(c => resolver(c, attr.name))) {
-          None
-        } else if (attr.dataType.isInstanceOf[IntegralType] || attr.dataType == StringType ||
-            attr.dataType == DateType) {
-          Some(attr.name)
-        } else {
-          None
-        }
+//        val resolver = SQLConf.get.resolver
+//        if (varcharKeys.exists(c => resolver(c, attr.name))) {
+//          None
+//        } else if (attr.dataType.isInstanceOf[IntegralType] || attr.dataType == StringType ||
+//            attr.dataType == DateType) {
+        Some(attr.name)
+//        } else {
+//          None
+//        }
       }
     }
 
diff --git a/tree/pom.xml b/tree/pom.xml
new file mode 100644
index 00000000000..63fe586e896
--- /dev/null
+++ b/tree/pom.xml
@@ -0,0 +1,320 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the "License"); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~    http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<modelVersion>4.0.0</modelVersion>
+<parent>
+    <groupId>org.apache.spark</groupId>
+    <artifactId>spark-parent_2.12</artifactId>
+    <version>3.4.2-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+</parent>
+
+<artifactId>tree_2.12</artifactId>
+<properties>
+    <sbt.project.name>tree</sbt.project.name>
+    <guava.version>31.0.1-jre</guava.version>
+    <guava.failureaccess.version>1.0.1</guava.failureaccess.version>
+    <io.grpc.version>1.47.0</io.grpc.version>
+    <tomcat.annotations.api.version>6.0.53</tomcat.annotations.api.version>
+</properties>
+<packaging>jar</packaging>
+<name>Spark Tree</name>
+<url>https://spark.apache.org/</url>
+
+<dependencies>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-core_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-sql_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.apache.spark</groupId>
+        <artifactId>spark-catalyst_${scala.binary.version}</artifactId>
+        <version>${project.version}</version>
+        <scope>provided</scope>
+        <exclusions>
+            <exclusion>
+                <groupId>com.google.guava</groupId>
+                <artifactId>guava</artifactId>
+            </exclusion>
+        </exclusions>
+    </dependency>
+    <dependency>
+        <groupId>org.scalacheck</groupId>
+        <artifactId>scalacheck_${scala.binary.version}</artifactId>
+        <scope>test</scope>
+    </dependency>
+    <!-- #if scala-2.13 --><!--
+    <dependency>
+      <groupId>org.scala-lang.modules</groupId>
+      <artifactId>scala-parallel-collections_${scala.binary.version}</artifactId>
+    </dependency>
+    --><!-- #endif scala-2.13 -->
+    <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+        <scope>compile</scope>
+    </dependency>
+    <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>failureaccess</artifactId>
+        <version>${guava.failureaccess.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>com.google.protobuf</groupId>
+        <artifactId>protobuf-java</artifactId>
+        <version>${protobuf.version}</version>
+        <scope>compile</scope>
+    </dependency>
+    <dependency>
+        <groupId>com.google.protobuf</groupId>
+        <artifactId>protobuf-java-util</artifactId>
+        <version>${protobuf.version}</version>
+        <scope>compile</scope>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-netty</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-protobuf</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-services</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.grpc</groupId>
+        <artifactId>grpc-stub</artifactId>
+        <version>${io.grpc.version}</version>
+    </dependency>
+    <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-codec-http2</artifactId>
+        <version>${netty.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-handler-proxy</artifactId>
+        <version>${netty.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency>
+        <groupId>io.netty</groupId>
+        <artifactId>netty-transport-native-unix-common</artifactId>
+        <version>${netty.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency> <!-- necessary for Java 9+ -->
+        <groupId>org.apache.tomcat</groupId>
+        <artifactId>annotations-api</artifactId>
+        <version>${tomcat.annotations.api.version}</version>
+        <scope>provided</scope>
+    </dependency>
+    <dependency>
+        <groupId>org.mongodb</groupId>
+        <artifactId>bson</artifactId>
+        <version>4.11.2</version>
+    </dependency>
+</dependencies>
+
+
+<build>
+    <outputDirectory>target/scala-${scala.binary.version}/classes</outputDirectory>
+    <testOutputDirectory>target/scala-${scala.binary.version}/test-classes</testOutputDirectory>
+<!--    Manually building proto and copying and pasting the classes for now because of package naming-->
+    <extensions>
+        <extension>
+            <groupId>kr.motd.maven</groupId>
+            <artifactId>os-maven-plugin</artifactId>
+            <version>1.6.2</version>
+        </extension>
+    </extensions>
+    <plugins>
+        <!--    Manually building proto and copying and pasting the classes for now because of package naming-->
+        <plugin>
+            <groupId>org.xolstice.maven.plugins</groupId>
+            <artifactId>protobuf-maven-plugin</artifactId>
+            <version>0.6.1</version>
+            <configuration>
+                <protocArtifact>com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.classifier}</protocArtifact>
+                <pluginId>grpc-java</pluginId>
+                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${io.grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
+                <protoSourceRoot>src/main/proto</protoSourceRoot>
+            </configuration>
+            <executions>
+                <execution>
+                    <goals>
+                        <goal>compile</goal>
+                        <goal>compile-custom</goal>
+                    </goals>
+                </execution>
+            </executions>
+        </plugin>
+        <!-- Shade all GRPC / Guava / Protobuf dependencies of this build -->
+        <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-shade-plugin</artifactId>
+            <configuration>
+                <shadedArtifactAttached>false</shadedArtifactAttached>
+                <artifactSet>
+                    <includes>
+                        <include>com.google.guava:*</include>
+                        <include>io.grpc:*:</include>
+                        <include>com.google.protobuf:*</include>
+
+                        <!--
+                          The dependencies below are not added in SBT because SBT add them all
+                          as assembly build.
+                        -->
+                        <include>com.google.android:annotations</include>
+                        <include>com.google.api.grpc:proto-google-common-protos</include>
+                        <include>io.perfmark:perfmark-api</include>
+                        <include>org.codehaus.mojo:animal-sniffer-annotations</include>
+                        <include>com.google.errorprone:error_prone_annotations</include>
+                        <include>com.google.j2objc:j2objc-annotations</include>
+                        <include>org.checkerframework:checker-qual</include>
+                        <include>com.google.code.gson:gson</include>
+                        <include>org.apache.spark:spark-connect-common_${scala.binary.version}</include>
+                    </includes>
+                </artifactSet>
+                <relocations>
+                    <relocation>
+                        <pattern>com.google.common</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.guava</shadedPattern>
+                        <includes>
+                            <include>com.google.common.**</include>
+                        </includes>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.thirdparty</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.guava</shadedPattern>
+                        <includes>
+                            <include>com.google.thirdparty.**</include>
+                        </includes>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.protobuf</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.protobuf</shadedPattern>
+                        <includes>
+                            <include>com.google.protobuf.**</include>
+                        </includes>
+                    </relocation>
+                    <relocation>
+                        <pattern>io.grpc</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.grpc</shadedPattern>
+                    </relocation>
+
+                    <relocation>
+                        <pattern>android.annotation</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.android_annotation</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>io.perfmark</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.io_perfmark</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>org.codehaus.mojo.animal_sniffer</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.animal_sniffer</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.j2objc.annotations</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.j2objc_annotations</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.errorprone.annotations</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.errorprone_annotations</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>org.checkerframework</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.checkerframework</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.gson</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.gson</shadedPattern>
+                    </relocation>
+
+                    <!--
+                      For `com.google.api.grpc:proto-google-common-protos`, do not directly define pattern
+                      as `common.google`, otherwise, otherwise, the relocation result may be uncertain due
+                      to the change of rule order.
+                    -->
+                    <relocation>
+                        <pattern>com.google.api</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.api</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.cloud</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.cloud</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.geo</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.geo</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.logging</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.logging</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.longrunning</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.longrunning</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.rpc</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.rpc</shadedPattern>
+                    </relocation>
+                    <relocation>
+                        <pattern>com.google.type</pattern>
+                        <shadedPattern>${spark.shade.packageName}.connect.google_protos.type</shadedPattern>
+                    </relocation>
+                </relocations>
+                <transformers>
+                    <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/>
+                </transformers>
+            </configuration>
+        </plugin>
+    </plugins>
+</build>
+
+</project>
diff --git a/tree/src/main/java/org/apache/spark/tree/grpc/GRPCCatalogGrpc.java b/tree/src/main/java/org/apache/spark/tree/grpc/GRPCCatalogGrpc.java
new file mode 100644
index 00000000000..15dd1de1842
--- /dev/null
+++ b/tree/src/main/java/org/apache/spark/tree/grpc/GRPCCatalogGrpc.java
@@ -0,0 +1,919 @@
+package org.apache.spark.tree.grpc;
+
+import static io.grpc.MethodDescriptor.generateFullMethodName;
+
+/**
+ */
+@javax.annotation.Generated(
+        value = "by gRPC proto compiler (version 1.47.0)",
+        comments = "Source: grpccatalog.proto")
+@io.grpc.stub.annotations.GrpcGenerated
+public final class GRPCCatalogGrpc {
+
+    private GRPCCatalogGrpc() {}
+
+    public static final String SERVICE_NAME = "GRPCCatalog";
+
+    // Static method descriptors that strictly reflect the proto.
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.StartTxnRequest,
+            Grpccatalog.StartTxnResponse> getStartTxnMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "StartTxn",
+            requestType = Grpccatalog.StartTxnRequest.class,
+            responseType = Grpccatalog.StartTxnResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.StartTxnRequest,
+            Grpccatalog.StartTxnResponse> getStartTxnMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.StartTxnRequest, Grpccatalog.StartTxnResponse> getStartTxnMethod;
+        if ((getStartTxnMethod = GRPCCatalogGrpc.getStartTxnMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getStartTxnMethod = GRPCCatalogGrpc.getStartTxnMethod) == null) {
+                    GRPCCatalogGrpc.getStartTxnMethod = getStartTxnMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.StartTxnRequest, Grpccatalog.StartTxnResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "StartTxn"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.StartTxnRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.StartTxnResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("StartTxn"))
+                                    .build();
+                }
+            }
+        }
+        return getStartTxnMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.SnapshotRequest,
+            Grpccatalog.SnapshotResponse> getSnapshotMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "Snapshot",
+            requestType = Grpccatalog.SnapshotRequest.class,
+            responseType = Grpccatalog.SnapshotResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.SnapshotRequest,
+            Grpccatalog.SnapshotResponse> getSnapshotMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.SnapshotRequest, Grpccatalog.SnapshotResponse> getSnapshotMethod;
+        if ((getSnapshotMethod = GRPCCatalogGrpc.getSnapshotMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getSnapshotMethod = GRPCCatalogGrpc.getSnapshotMethod) == null) {
+                    GRPCCatalogGrpc.getSnapshotMethod = getSnapshotMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.SnapshotRequest, Grpccatalog.SnapshotResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "Snapshot"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.SnapshotRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.SnapshotResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("Snapshot"))
+                                    .build();
+                }
+            }
+        }
+        return getSnapshotMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.CloneRequest,
+            Grpccatalog.CloneResponse> getCloneMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "Clone",
+            requestType = Grpccatalog.CloneRequest.class,
+            responseType = Grpccatalog.CloneResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.CloneRequest,
+            Grpccatalog.CloneResponse> getCloneMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.CloneRequest, Grpccatalog.CloneResponse> getCloneMethod;
+        if ((getCloneMethod = GRPCCatalogGrpc.getCloneMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getCloneMethod = GRPCCatalogGrpc.getCloneMethod) == null) {
+                    GRPCCatalogGrpc.getCloneMethod = getCloneMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.CloneRequest, Grpccatalog.CloneResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "Clone"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.CloneRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.CloneResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("Clone"))
+                                    .build();
+                }
+            }
+        }
+        return getCloneMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.GetGarbageRequest,
+            Grpccatalog.GetGarbageResponse> getGetGarbageMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "GetGarbage",
+            requestType = Grpccatalog.GetGarbageRequest.class,
+            responseType = Grpccatalog.GetGarbageResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.GetGarbageRequest,
+            Grpccatalog.GetGarbageResponse> getGetGarbageMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.GetGarbageRequest, Grpccatalog.GetGarbageResponse> getGetGarbageMethod;
+        if ((getGetGarbageMethod = GRPCCatalogGrpc.getGetGarbageMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getGetGarbageMethod = GRPCCatalogGrpc.getGetGarbageMethod) == null) {
+                    GRPCCatalogGrpc.getGetGarbageMethod = getGetGarbageMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.GetGarbageRequest, Grpccatalog.GetGarbageResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "GetGarbage"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.GetGarbageRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.GetGarbageResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("GetGarbage"))
+                                    .build();
+                }
+            }
+        }
+        return getGetGarbageMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.ClearGarbageRequest,
+            Grpccatalog.ClearGarbageResponse> getClearGarbageMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "ClearGarbage",
+            requestType = Grpccatalog.ClearGarbageRequest.class,
+            responseType = Grpccatalog.ClearGarbageResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.ClearGarbageRequest,
+            Grpccatalog.ClearGarbageResponse> getClearGarbageMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.ClearGarbageRequest, Grpccatalog.ClearGarbageResponse> getClearGarbageMethod;
+        if ((getClearGarbageMethod = GRPCCatalogGrpc.getClearGarbageMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getClearGarbageMethod = GRPCCatalogGrpc.getClearGarbageMethod) == null) {
+                    GRPCCatalogGrpc.getClearGarbageMethod = getClearGarbageMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.ClearGarbageRequest, Grpccatalog.ClearGarbageResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "ClearGarbage"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.ClearGarbageRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.ClearGarbageResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("ClearGarbage"))
+                                    .build();
+                }
+            }
+        }
+        return getClearGarbageMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.DefineTypeRequest,
+            Grpccatalog.DefineTypeResponse> getDefineTypeMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "DefineType",
+            requestType = Grpccatalog.DefineTypeRequest.class,
+            responseType = Grpccatalog.DefineTypeResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.DefineTypeRequest,
+            Grpccatalog.DefineTypeResponse> getDefineTypeMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.DefineTypeRequest, Grpccatalog.DefineTypeResponse> getDefineTypeMethod;
+        if ((getDefineTypeMethod = GRPCCatalogGrpc.getDefineTypeMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getDefineTypeMethod = GRPCCatalogGrpc.getDefineTypeMethod) == null) {
+                    GRPCCatalogGrpc.getDefineTypeMethod = getDefineTypeMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.DefineTypeRequest, Grpccatalog.DefineTypeResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "DefineType"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.DefineTypeRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.DefineTypeResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("DefineType"))
+                                    .build();
+                }
+            }
+        }
+        return getDefineTypeMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.ExecuteQueryRequest,
+            Grpccatalog.ExecuteQueryResponse> getExecuteQueryMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "ExecuteQuery",
+            requestType = Grpccatalog.ExecuteQueryRequest.class,
+            responseType = Grpccatalog.ExecuteQueryResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
+    public static io.grpc.MethodDescriptor<Grpccatalog.ExecuteQueryRequest,
+            Grpccatalog.ExecuteQueryResponse> getExecuteQueryMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.ExecuteQueryRequest, Grpccatalog.ExecuteQueryResponse> getExecuteQueryMethod;
+        if ((getExecuteQueryMethod = GRPCCatalogGrpc.getExecuteQueryMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getExecuteQueryMethod = GRPCCatalogGrpc.getExecuteQueryMethod) == null) {
+                    GRPCCatalogGrpc.getExecuteQueryMethod = getExecuteQueryMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.ExecuteQueryRequest, Grpccatalog.ExecuteQueryResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.SERVER_STREAMING)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "ExecuteQuery"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.ExecuteQueryRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.ExecuteQueryResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("ExecuteQuery"))
+                                    .build();
+                }
+            }
+        }
+        return getExecuteQueryMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.CommitRequest,
+            Grpccatalog.CommitResponse> getCommitMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "Commit",
+            requestType = Grpccatalog.CommitRequest.class,
+            responseType = Grpccatalog.CommitResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.CommitRequest,
+            Grpccatalog.CommitResponse> getCommitMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.CommitRequest, Grpccatalog.CommitResponse> getCommitMethod;
+        if ((getCommitMethod = GRPCCatalogGrpc.getCommitMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getCommitMethod = GRPCCatalogGrpc.getCommitMethod) == null) {
+                    GRPCCatalogGrpc.getCommitMethod = getCommitMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.CommitRequest, Grpccatalog.CommitResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "Commit"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.CommitRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.CommitResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("Commit"))
+                                    .build();
+                }
+            }
+        }
+        return getCommitMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.PreCommitRequest,
+            Grpccatalog.PreCommitResponse> getPreCommitMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "PreCommit",
+            requestType = Grpccatalog.PreCommitRequest.class,
+            responseType = Grpccatalog.PreCommitResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.UNARY)
+    public static io.grpc.MethodDescriptor<Grpccatalog.PreCommitRequest,
+            Grpccatalog.PreCommitResponse> getPreCommitMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.PreCommitRequest, Grpccatalog.PreCommitResponse> getPreCommitMethod;
+        if ((getPreCommitMethod = GRPCCatalogGrpc.getPreCommitMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getPreCommitMethod = GRPCCatalogGrpc.getPreCommitMethod) == null) {
+                    GRPCCatalogGrpc.getPreCommitMethod = getPreCommitMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.PreCommitRequest, Grpccatalog.PreCommitResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "PreCommit"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.PreCommitRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.PreCommitResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("PreCommit"))
+                                    .build();
+                }
+            }
+        }
+        return getPreCommitMethod;
+    }
+
+    private static volatile io.grpc.MethodDescriptor<Grpccatalog.BulkLoadRequest,
+            Grpccatalog.BulkLoadResponse> getBulkLoadMethod;
+
+    @io.grpc.stub.annotations.RpcMethod(
+            fullMethodName = SERVICE_NAME + '/' + "BulkLoad",
+            requestType = Grpccatalog.BulkLoadRequest.class,
+            responseType = Grpccatalog.BulkLoadResponse.class,
+            methodType = io.grpc.MethodDescriptor.MethodType.CLIENT_STREAMING)
+    public static io.grpc.MethodDescriptor<Grpccatalog.BulkLoadRequest,
+            Grpccatalog.BulkLoadResponse> getBulkLoadMethod() {
+        io.grpc.MethodDescriptor<Grpccatalog.BulkLoadRequest, Grpccatalog.BulkLoadResponse> getBulkLoadMethod;
+        if ((getBulkLoadMethod = GRPCCatalogGrpc.getBulkLoadMethod) == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                if ((getBulkLoadMethod = GRPCCatalogGrpc.getBulkLoadMethod) == null) {
+                    GRPCCatalogGrpc.getBulkLoadMethod = getBulkLoadMethod =
+                            io.grpc.MethodDescriptor.<Grpccatalog.BulkLoadRequest, Grpccatalog.BulkLoadResponse>newBuilder()
+                                    .setType(io.grpc.MethodDescriptor.MethodType.CLIENT_STREAMING)
+                                    .setFullMethodName(generateFullMethodName(SERVICE_NAME, "BulkLoad"))
+                                    .setSampledToLocalTracing(true)
+                                    .setRequestMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.BulkLoadRequest.getDefaultInstance()))
+                                    .setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(
+                                            Grpccatalog.BulkLoadResponse.getDefaultInstance()))
+                                    .setSchemaDescriptor(new GRPCCatalogMethodDescriptorSupplier("BulkLoad"))
+                                    .build();
+                }
+            }
+        }
+        return getBulkLoadMethod;
+    }
+
+    /**
+     * Creates a new async stub that supports all call types for the service
+     */
+    public static GRPCCatalogStub newStub(io.grpc.Channel channel) {
+        io.grpc.stub.AbstractStub.StubFactory<GRPCCatalogStub> factory =
+                new io.grpc.stub.AbstractStub.StubFactory<GRPCCatalogStub>() {
+                    @java.lang.Override
+                    public GRPCCatalogStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+                        return new GRPCCatalogStub(channel, callOptions);
+                    }
+                };
+        return GRPCCatalogStub.newStub(factory, channel);
+    }
+
+    /**
+     * Creates a new blocking-style stub that supports unary and streaming output calls on the service
+     */
+    public static GRPCCatalogBlockingStub newBlockingStub(
+            io.grpc.Channel channel) {
+        io.grpc.stub.AbstractStub.StubFactory<GRPCCatalogBlockingStub> factory =
+                new io.grpc.stub.AbstractStub.StubFactory<GRPCCatalogBlockingStub>() {
+                    @java.lang.Override
+                    public GRPCCatalogBlockingStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+                        return new GRPCCatalogBlockingStub(channel, callOptions);
+                    }
+                };
+        return GRPCCatalogBlockingStub.newStub(factory, channel);
+    }
+
+    /**
+     * Creates a new ListenableFuture-style stub that supports unary calls on the service
+     */
+    public static GRPCCatalogFutureStub newFutureStub(
+            io.grpc.Channel channel) {
+        io.grpc.stub.AbstractStub.StubFactory<GRPCCatalogFutureStub> factory =
+                new io.grpc.stub.AbstractStub.StubFactory<GRPCCatalogFutureStub>() {
+                    @java.lang.Override
+                    public GRPCCatalogFutureStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+                        return new GRPCCatalogFutureStub(channel, callOptions);
+                    }
+                };
+        return GRPCCatalogFutureStub.newStub(factory, channel);
+    }
+
+    /**
+     */
+    public static abstract class GRPCCatalogImplBase implements io.grpc.BindableService {
+
+        /**
+         */
+        public void startTxn(Grpccatalog.StartTxnRequest request,
+                             io.grpc.stub.StreamObserver<Grpccatalog.StartTxnResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getStartTxnMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void snapshot(Grpccatalog.SnapshotRequest request,
+                             io.grpc.stub.StreamObserver<Grpccatalog.SnapshotResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getSnapshotMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void clone(Grpccatalog.CloneRequest request,
+                          io.grpc.stub.StreamObserver<Grpccatalog.CloneResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getCloneMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void getGarbage(Grpccatalog.GetGarbageRequest request,
+                               io.grpc.stub.StreamObserver<Grpccatalog.GetGarbageResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getGetGarbageMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void clearGarbage(Grpccatalog.ClearGarbageRequest request,
+                                 io.grpc.stub.StreamObserver<Grpccatalog.ClearGarbageResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getClearGarbageMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void defineType(Grpccatalog.DefineTypeRequest request,
+                               io.grpc.stub.StreamObserver<Grpccatalog.DefineTypeResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getDefineTypeMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void executeQuery(Grpccatalog.ExecuteQueryRequest request,
+                                 io.grpc.stub.StreamObserver<Grpccatalog.ExecuteQueryResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getExecuteQueryMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void commit(Grpccatalog.CommitRequest request,
+                           io.grpc.stub.StreamObserver<Grpccatalog.CommitResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getCommitMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public void preCommit(Grpccatalog.PreCommitRequest request,
+                              io.grpc.stub.StreamObserver<Grpccatalog.PreCommitResponse> responseObserver) {
+            io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall(getPreCommitMethod(), responseObserver);
+        }
+
+        /**
+         */
+        public io.grpc.stub.StreamObserver<Grpccatalog.BulkLoadRequest> bulkLoad(
+                io.grpc.stub.StreamObserver<Grpccatalog.BulkLoadResponse> responseObserver) {
+            return io.grpc.stub.ServerCalls.asyncUnimplementedStreamingCall(getBulkLoadMethod(), responseObserver);
+        }
+
+        @java.lang.Override public final io.grpc.ServerServiceDefinition bindService() {
+            return io.grpc.ServerServiceDefinition.builder(getServiceDescriptor())
+                    .addMethod(
+                            getStartTxnMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.StartTxnRequest,
+                                            Grpccatalog.StartTxnResponse>(
+                                            this, METHODID_START_TXN)))
+                    .addMethod(
+                            getSnapshotMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.SnapshotRequest,
+                                            Grpccatalog.SnapshotResponse>(
+                                            this, METHODID_SNAPSHOT)))
+                    .addMethod(
+                            getCloneMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.CloneRequest,
+                                            Grpccatalog.CloneResponse>(
+                                            this, METHODID_CLONE)))
+                    .addMethod(
+                            getGetGarbageMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.GetGarbageRequest,
+                                            Grpccatalog.GetGarbageResponse>(
+                                            this, METHODID_GET_GARBAGE)))
+                    .addMethod(
+                            getClearGarbageMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.ClearGarbageRequest,
+                                            Grpccatalog.ClearGarbageResponse>(
+                                            this, METHODID_CLEAR_GARBAGE)))
+                    .addMethod(
+                            getDefineTypeMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.DefineTypeRequest,
+                                            Grpccatalog.DefineTypeResponse>(
+                                            this, METHODID_DEFINE_TYPE)))
+                    .addMethod(
+                            getExecuteQueryMethod(),
+                            io.grpc.stub.ServerCalls.asyncServerStreamingCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.ExecuteQueryRequest,
+                                            Grpccatalog.ExecuteQueryResponse>(
+                                            this, METHODID_EXECUTE_QUERY)))
+                    .addMethod(
+                            getCommitMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.CommitRequest,
+                                            Grpccatalog.CommitResponse>(
+                                            this, METHODID_COMMIT)))
+                    .addMethod(
+                            getPreCommitMethod(),
+                            io.grpc.stub.ServerCalls.asyncUnaryCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.PreCommitRequest,
+                                            Grpccatalog.PreCommitResponse>(
+                                            this, METHODID_PRE_COMMIT)))
+                    .addMethod(
+                            getBulkLoadMethod(),
+                            io.grpc.stub.ServerCalls.asyncClientStreamingCall(
+                                    new MethodHandlers<
+                                            Grpccatalog.BulkLoadRequest,
+                                            Grpccatalog.BulkLoadResponse>(
+                                            this, METHODID_BULK_LOAD)))
+                    .build();
+        }
+    }
+
+    /**
+     */
+    public static final class GRPCCatalogStub extends io.grpc.stub.AbstractAsyncStub<GRPCCatalogStub> {
+        private GRPCCatalogStub(
+                io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+            super(channel, callOptions);
+        }
+
+        @java.lang.Override
+        protected GRPCCatalogStub build(
+                io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+            return new GRPCCatalogStub(channel, callOptions);
+        }
+
+        /**
+         */
+        public void startTxn(Grpccatalog.StartTxnRequest request,
+                             io.grpc.stub.StreamObserver<Grpccatalog.StartTxnResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getStartTxnMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void snapshot(Grpccatalog.SnapshotRequest request,
+                             io.grpc.stub.StreamObserver<Grpccatalog.SnapshotResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getSnapshotMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void clone(Grpccatalog.CloneRequest request,
+                          io.grpc.stub.StreamObserver<Grpccatalog.CloneResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getCloneMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void getGarbage(Grpccatalog.GetGarbageRequest request,
+                               io.grpc.stub.StreamObserver<Grpccatalog.GetGarbageResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getGetGarbageMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void clearGarbage(Grpccatalog.ClearGarbageRequest request,
+                                 io.grpc.stub.StreamObserver<Grpccatalog.ClearGarbageResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getClearGarbageMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void defineType(Grpccatalog.DefineTypeRequest request,
+                               io.grpc.stub.StreamObserver<Grpccatalog.DefineTypeResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getDefineTypeMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void executeQuery(Grpccatalog.ExecuteQueryRequest request,
+                                 io.grpc.stub.StreamObserver<Grpccatalog.ExecuteQueryResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncServerStreamingCall(
+                    getChannel().newCall(getExecuteQueryMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void commit(Grpccatalog.CommitRequest request,
+                           io.grpc.stub.StreamObserver<Grpccatalog.CommitResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getCommitMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public void preCommit(Grpccatalog.PreCommitRequest request,
+                              io.grpc.stub.StreamObserver<Grpccatalog.PreCommitResponse> responseObserver) {
+            io.grpc.stub.ClientCalls.asyncUnaryCall(
+                    getChannel().newCall(getPreCommitMethod(), getCallOptions()), request, responseObserver);
+        }
+
+        /**
+         */
+        public io.grpc.stub.StreamObserver<Grpccatalog.BulkLoadRequest> bulkLoad(
+                io.grpc.stub.StreamObserver<Grpccatalog.BulkLoadResponse> responseObserver) {
+            return io.grpc.stub.ClientCalls.asyncClientStreamingCall(
+                    getChannel().newCall(getBulkLoadMethod(), getCallOptions()), responseObserver);
+        }
+    }
+
+    /**
+     */
+    public static final class GRPCCatalogBlockingStub extends io.grpc.stub.AbstractBlockingStub<GRPCCatalogBlockingStub> {
+        private GRPCCatalogBlockingStub(
+                io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+            super(channel, callOptions);
+        }
+
+        @java.lang.Override
+        protected GRPCCatalogBlockingStub build(
+                io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+            return new GRPCCatalogBlockingStub(channel, callOptions);
+        }
+
+        /**
+         */
+        public Grpccatalog.StartTxnResponse startTxn(Grpccatalog.StartTxnRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getStartTxnMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.SnapshotResponse snapshot(Grpccatalog.SnapshotRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getSnapshotMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.CloneResponse clone(Grpccatalog.CloneRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getCloneMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.GetGarbageResponse getGarbage(Grpccatalog.GetGarbageRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getGetGarbageMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.ClearGarbageResponse clearGarbage(Grpccatalog.ClearGarbageRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getClearGarbageMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.DefineTypeResponse defineType(Grpccatalog.DefineTypeRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getDefineTypeMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public java.util.Iterator<Grpccatalog.ExecuteQueryResponse> executeQuery(
+                Grpccatalog.ExecuteQueryRequest request) {
+            return io.grpc.stub.ClientCalls.blockingServerStreamingCall(
+                    getChannel(), getExecuteQueryMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.CommitResponse commit(Grpccatalog.CommitRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getCommitMethod(), getCallOptions(), request);
+        }
+
+        /**
+         */
+        public Grpccatalog.PreCommitResponse preCommit(Grpccatalog.PreCommitRequest request) {
+            return io.grpc.stub.ClientCalls.blockingUnaryCall(
+                    getChannel(), getPreCommitMethod(), getCallOptions(), request);
+        }
+    }
+
+    /**
+     */
+    public static final class GRPCCatalogFutureStub extends io.grpc.stub.AbstractFutureStub<GRPCCatalogFutureStub> {
+        private GRPCCatalogFutureStub(
+                io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+            super(channel, callOptions);
+        }
+
+        @java.lang.Override
+        protected GRPCCatalogFutureStub build(
+                io.grpc.Channel channel, io.grpc.CallOptions callOptions) {
+            return new GRPCCatalogFutureStub(channel, callOptions);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.StartTxnResponse> startTxn(
+                Grpccatalog.StartTxnRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getStartTxnMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.SnapshotResponse> snapshot(
+                Grpccatalog.SnapshotRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getSnapshotMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.CloneResponse> clone(
+                Grpccatalog.CloneRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getCloneMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.GetGarbageResponse> getGarbage(
+                Grpccatalog.GetGarbageRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getGetGarbageMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.ClearGarbageResponse> clearGarbage(
+                Grpccatalog.ClearGarbageRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getClearGarbageMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.DefineTypeResponse> defineType(
+                Grpccatalog.DefineTypeRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getDefineTypeMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.CommitResponse> commit(
+                Grpccatalog.CommitRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getCommitMethod(), getCallOptions()), request);
+        }
+
+        /**
+         */
+        public com.google.common.util.concurrent.ListenableFuture<Grpccatalog.PreCommitResponse> preCommit(
+                Grpccatalog.PreCommitRequest request) {
+            return io.grpc.stub.ClientCalls.futureUnaryCall(
+                    getChannel().newCall(getPreCommitMethod(), getCallOptions()), request);
+        }
+    }
+
+    private static final int METHODID_START_TXN = 0;
+    private static final int METHODID_SNAPSHOT = 1;
+    private static final int METHODID_CLONE = 2;
+    private static final int METHODID_GET_GARBAGE = 3;
+    private static final int METHODID_CLEAR_GARBAGE = 4;
+    private static final int METHODID_DEFINE_TYPE = 5;
+    private static final int METHODID_EXECUTE_QUERY = 6;
+    private static final int METHODID_COMMIT = 7;
+    private static final int METHODID_PRE_COMMIT = 8;
+    private static final int METHODID_BULK_LOAD = 9;
+
+    private static final class MethodHandlers<Req, Resp> implements
+            io.grpc.stub.ServerCalls.UnaryMethod<Req, Resp>,
+            io.grpc.stub.ServerCalls.ServerStreamingMethod<Req, Resp>,
+            io.grpc.stub.ServerCalls.ClientStreamingMethod<Req, Resp>,
+            io.grpc.stub.ServerCalls.BidiStreamingMethod<Req, Resp> {
+        private final GRPCCatalogImplBase serviceImpl;
+        private final int methodId;
+
+        MethodHandlers(GRPCCatalogImplBase serviceImpl, int methodId) {
+            this.serviceImpl = serviceImpl;
+            this.methodId = methodId;
+        }
+
+        @java.lang.Override
+        @java.lang.SuppressWarnings("unchecked")
+        public void invoke(Req request, io.grpc.stub.StreamObserver<Resp> responseObserver) {
+            switch (methodId) {
+                case METHODID_START_TXN:
+                    serviceImpl.startTxn((Grpccatalog.StartTxnRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.StartTxnResponse>) responseObserver);
+                    break;
+                case METHODID_SNAPSHOT:
+                    serviceImpl.snapshot((Grpccatalog.SnapshotRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.SnapshotResponse>) responseObserver);
+                    break;
+                case METHODID_CLONE:
+                    serviceImpl.clone((Grpccatalog.CloneRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.CloneResponse>) responseObserver);
+                    break;
+                case METHODID_GET_GARBAGE:
+                    serviceImpl.getGarbage((Grpccatalog.GetGarbageRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.GetGarbageResponse>) responseObserver);
+                    break;
+                case METHODID_CLEAR_GARBAGE:
+                    serviceImpl.clearGarbage((Grpccatalog.ClearGarbageRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.ClearGarbageResponse>) responseObserver);
+                    break;
+                case METHODID_DEFINE_TYPE:
+                    serviceImpl.defineType((Grpccatalog.DefineTypeRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.DefineTypeResponse>) responseObserver);
+                    break;
+                case METHODID_EXECUTE_QUERY:
+                    serviceImpl.executeQuery((Grpccatalog.ExecuteQueryRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.ExecuteQueryResponse>) responseObserver);
+                    break;
+                case METHODID_COMMIT:
+                    serviceImpl.commit((Grpccatalog.CommitRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.CommitResponse>) responseObserver);
+                    break;
+                case METHODID_PRE_COMMIT:
+                    serviceImpl.preCommit((Grpccatalog.PreCommitRequest) request,
+                            (io.grpc.stub.StreamObserver<Grpccatalog.PreCommitResponse>) responseObserver);
+                    break;
+                default:
+                    throw new AssertionError();
+            }
+        }
+
+        @java.lang.Override
+        @java.lang.SuppressWarnings("unchecked")
+        public io.grpc.stub.StreamObserver<Req> invoke(
+                io.grpc.stub.StreamObserver<Resp> responseObserver) {
+            switch (methodId) {
+                case METHODID_BULK_LOAD:
+                    return (io.grpc.stub.StreamObserver<Req>) serviceImpl.bulkLoad(
+                            (io.grpc.stub.StreamObserver<Grpccatalog.BulkLoadResponse>) responseObserver);
+                default:
+                    throw new AssertionError();
+            }
+        }
+    }
+
+    private static abstract class GRPCCatalogBaseDescriptorSupplier
+            implements io.grpc.protobuf.ProtoFileDescriptorSupplier, io.grpc.protobuf.ProtoServiceDescriptorSupplier {
+        GRPCCatalogBaseDescriptorSupplier() {}
+
+        @java.lang.Override
+        public com.google.protobuf.Descriptors.FileDescriptor getFileDescriptor() {
+            return Grpccatalog.getDescriptor();
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Descriptors.ServiceDescriptor getServiceDescriptor() {
+            return getFileDescriptor().findServiceByName("GRPCCatalog");
+        }
+    }
+
+    private static final class GRPCCatalogFileDescriptorSupplier
+            extends GRPCCatalogBaseDescriptorSupplier {
+        GRPCCatalogFileDescriptorSupplier() {}
+    }
+
+    private static final class GRPCCatalogMethodDescriptorSupplier
+            extends GRPCCatalogBaseDescriptorSupplier
+            implements io.grpc.protobuf.ProtoMethodDescriptorSupplier {
+        private final String methodName;
+
+        GRPCCatalogMethodDescriptorSupplier(String methodName) {
+            this.methodName = methodName;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Descriptors.MethodDescriptor getMethodDescriptor() {
+            return getServiceDescriptor().findMethodByName(methodName);
+        }
+    }
+
+    private static volatile io.grpc.ServiceDescriptor serviceDescriptor;
+
+    public static io.grpc.ServiceDescriptor getServiceDescriptor() {
+        io.grpc.ServiceDescriptor result = serviceDescriptor;
+        if (result == null) {
+            synchronized (GRPCCatalogGrpc.class) {
+                result = serviceDescriptor;
+                if (result == null) {
+                    serviceDescriptor = result = io.grpc.ServiceDescriptor.newBuilder(SERVICE_NAME)
+                            .setSchemaDescriptor(new GRPCCatalogFileDescriptorSupplier())
+                            .addMethod(getStartTxnMethod())
+                            .addMethod(getSnapshotMethod())
+                            .addMethod(getCloneMethod())
+                            .addMethod(getGetGarbageMethod())
+                            .addMethod(getClearGarbageMethod())
+                            .addMethod(getDefineTypeMethod())
+                            .addMethod(getExecuteQueryMethod())
+                            .addMethod(getCommitMethod())
+                            .addMethod(getPreCommitMethod())
+                            .addMethod(getBulkLoadMethod())
+                            .build();
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/tree/src/main/java/org/apache/spark/tree/grpc/Grpccatalog.java b/tree/src/main/java/org/apache/spark/tree/grpc/Grpccatalog.java
new file mode 100644
index 00000000000..27a9e4bd293
--- /dev/null
+++ b/tree/src/main/java/org/apache/spark/tree/grpc/Grpccatalog.java
@@ -0,0 +1,28263 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: grpccatalog.proto
+
+package org.apache.spark.tree.grpc;
+
+public final class Grpccatalog {
+    private Grpccatalog() {}
+    public static void registerAllExtensions(
+            com.google.protobuf.ExtensionRegistryLite registry) {
+    }
+
+    public static void registerAllExtensions(
+            com.google.protobuf.ExtensionRegistry registry) {
+        registerAllExtensions(
+                (com.google.protobuf.ExtensionRegistryLite) registry);
+    }
+    /**
+     * Protobuf enum {@code TxnMode}
+     */
+    public enum TxnMode
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>TXN_MODE_READ_ONLY = 0;</code>
+         */
+        TXN_MODE_READ_ONLY(0),
+        /**
+         * <code>TXN_MODE_READ_WRITE = 1;</code>
+         */
+        TXN_MODE_READ_WRITE(1),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>TXN_MODE_READ_ONLY = 0;</code>
+         */
+        public static final int TXN_MODE_READ_ONLY_VALUE = 0;
+        /**
+         * <code>TXN_MODE_READ_WRITE = 1;</code>
+         */
+        public static final int TXN_MODE_READ_WRITE_VALUE = 1;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static TxnMode valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static TxnMode forNumber(int value) {
+            switch (value) {
+                case 0: return TXN_MODE_READ_ONLY;
+                case 1: return TXN_MODE_READ_WRITE;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<TxnMode>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                TxnMode> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<TxnMode>() {
+                    public TxnMode findValueByNumber(int number) {
+                        return TxnMode.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(0);
+        }
+
+        private static final TxnMode[] VALUES = values();
+
+        public static TxnMode valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private TxnMode(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:TxnMode)
+    }
+
+    /**
+     * Protobuf enum {@code LockMode}
+     */
+    public enum LockMode
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>LOCK_MODE_NL = 0;</code>
+         */
+        LOCK_MODE_NL(0),
+        /**
+         * <code>LOCK_MODE_IS = 1;</code>
+         */
+        LOCK_MODE_IS(1),
+        /**
+         * <code>LOCK_MODE_IX = 2;</code>
+         */
+        LOCK_MODE_IX(2),
+        /**
+         * <code>LOCK_MODE_S = 3;</code>
+         */
+        LOCK_MODE_S(3),
+        /**
+         * <code>LOCK_MODE_SIX = 4;</code>
+         */
+        LOCK_MODE_SIX(4),
+        /**
+         * <code>LOCK_MODE_X = 5;</code>
+         */
+        LOCK_MODE_X(5),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>LOCK_MODE_NL = 0;</code>
+         */
+        public static final int LOCK_MODE_NL_VALUE = 0;
+        /**
+         * <code>LOCK_MODE_IS = 1;</code>
+         */
+        public static final int LOCK_MODE_IS_VALUE = 1;
+        /**
+         * <code>LOCK_MODE_IX = 2;</code>
+         */
+        public static final int LOCK_MODE_IX_VALUE = 2;
+        /**
+         * <code>LOCK_MODE_S = 3;</code>
+         */
+        public static final int LOCK_MODE_S_VALUE = 3;
+        /**
+         * <code>LOCK_MODE_SIX = 4;</code>
+         */
+        public static final int LOCK_MODE_SIX_VALUE = 4;
+        /**
+         * <code>LOCK_MODE_X = 5;</code>
+         */
+        public static final int LOCK_MODE_X_VALUE = 5;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static LockMode valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static LockMode forNumber(int value) {
+            switch (value) {
+                case 0: return LOCK_MODE_NL;
+                case 1: return LOCK_MODE_IS;
+                case 2: return LOCK_MODE_IX;
+                case 3: return LOCK_MODE_S;
+                case 4: return LOCK_MODE_SIX;
+                case 5: return LOCK_MODE_X;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<LockMode>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                LockMode> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<LockMode>() {
+                    public LockMode findValueByNumber(int number) {
+                        return LockMode.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(1);
+        }
+
+        private static final LockMode[] VALUES = values();
+
+        public static LockMode valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private LockMode(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:LockMode)
+    }
+
+    /**
+     * Protobuf enum {@code WriteType}
+     */
+    public enum WriteType
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>WRITE_TYPE_ADD = 0;</code>
+         */
+        WRITE_TYPE_ADD(0),
+        /**
+         * <code>WRITE_TYPE_REMOVE = 1;</code>
+         */
+        WRITE_TYPE_REMOVE(1),
+        /**
+         * <code>WRITE_TYPE_MERGE = 2;</code>
+         */
+        WRITE_TYPE_MERGE(2),
+        /**
+         * <code>WRITE_TYPE_UPDATE = 3;</code>
+         */
+        WRITE_TYPE_UPDATE(3),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>WRITE_TYPE_ADD = 0;</code>
+         */
+        public static final int WRITE_TYPE_ADD_VALUE = 0;
+        /**
+         * <code>WRITE_TYPE_REMOVE = 1;</code>
+         */
+        public static final int WRITE_TYPE_REMOVE_VALUE = 1;
+        /**
+         * <code>WRITE_TYPE_MERGE = 2;</code>
+         */
+        public static final int WRITE_TYPE_MERGE_VALUE = 2;
+        /**
+         * <code>WRITE_TYPE_UPDATE = 3;</code>
+         */
+        public static final int WRITE_TYPE_UPDATE_VALUE = 3;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static WriteType valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static WriteType forNumber(int value) {
+            switch (value) {
+                case 0: return WRITE_TYPE_ADD;
+                case 1: return WRITE_TYPE_REMOVE;
+                case 2: return WRITE_TYPE_MERGE;
+                case 3: return WRITE_TYPE_UPDATE;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<WriteType>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                WriteType> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<WriteType>() {
+                    public WriteType findValueByNumber(int number) {
+                        return WriteType.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(2);
+        }
+
+        private static final WriteType[] VALUES = values();
+
+        public static WriteType valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private WriteType(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:WriteType)
+    }
+
+    /**
+     * <pre>
+     * List of default types + OTHER for extended types.
+     * TODO:    1. Potentially extend the default types supported.
+     *          2. Rename to ObjTypeName.
+     * </pre>
+     *
+     * Protobuf enum {@code ObjTypeName}
+     */
+    public enum ObjTypeName
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>OBJ_TYPE_NAME_DATABASE = 0;</code>
+         */
+        OBJ_TYPE_NAME_DATABASE(0),
+        /**
+         * <code>OBJ_TYPE_NAME_TABLE = 1;</code>
+         */
+        OBJ_TYPE_NAME_TABLE(1),
+        /**
+         * <code>OBJ_TYPE_NAME_PARTITION = 2;</code>
+         */
+        OBJ_TYPE_NAME_PARTITION(2),
+        /**
+         * <code>OBJ_TYPE_NAME_FILE_OBJECT = 3;</code>
+         */
+        OBJ_TYPE_NAME_FILE_OBJECT(3),
+        /**
+         * <code>OBJ_TYPE_NAME_OTHER = 4;</code>
+         */
+        OBJ_TYPE_NAME_OTHER(4),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>OBJ_TYPE_NAME_DATABASE = 0;</code>
+         */
+        public static final int OBJ_TYPE_NAME_DATABASE_VALUE = 0;
+        /**
+         * <code>OBJ_TYPE_NAME_TABLE = 1;</code>
+         */
+        public static final int OBJ_TYPE_NAME_TABLE_VALUE = 1;
+        /**
+         * <code>OBJ_TYPE_NAME_PARTITION = 2;</code>
+         */
+        public static final int OBJ_TYPE_NAME_PARTITION_VALUE = 2;
+        /**
+         * <code>OBJ_TYPE_NAME_FILE_OBJECT = 3;</code>
+         */
+        public static final int OBJ_TYPE_NAME_FILE_OBJECT_VALUE = 3;
+        /**
+         * <code>OBJ_TYPE_NAME_OTHER = 4;</code>
+         */
+        public static final int OBJ_TYPE_NAME_OTHER_VALUE = 4;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static ObjTypeName valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static ObjTypeName forNumber(int value) {
+            switch (value) {
+                case 0: return OBJ_TYPE_NAME_DATABASE;
+                case 1: return OBJ_TYPE_NAME_TABLE;
+                case 2: return OBJ_TYPE_NAME_PARTITION;
+                case 3: return OBJ_TYPE_NAME_FILE_OBJECT;
+                case 4: return OBJ_TYPE_NAME_OTHER;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<ObjTypeName>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                ObjTypeName> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<ObjTypeName>() {
+                    public ObjTypeName findValueByNumber(int number) {
+                        return ObjTypeName.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(3);
+        }
+
+        private static final ObjTypeName[] VALUES = values();
+
+        public static ObjTypeName valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private ObjTypeName(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:ObjTypeName)
+    }
+
+    /**
+     * Protobuf enum {@code Wildcard}
+     */
+    public enum Wildcard
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <pre>
+         * match any object in the given level
+         * </pre>
+         *
+         * <code>WILDCARD_ANY = 0;</code>
+         */
+        WILDCARD_ANY(0),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <pre>
+         * match any object in the given level
+         * </pre>
+         *
+         * <code>WILDCARD_ANY = 0;</code>
+         */
+        public static final int WILDCARD_ANY_VALUE = 0;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static Wildcard valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static Wildcard forNumber(int value) {
+            switch (value) {
+                case 0: return WILDCARD_ANY;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<Wildcard>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                Wildcard> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<Wildcard>() {
+                    public Wildcard findValueByNumber(int number) {
+                        return Wildcard.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(4);
+        }
+
+        private static final Wildcard[] VALUES = values();
+
+        public static Wildcard valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private Wildcard(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:Wildcard)
+    }
+
+    /**
+     * <pre>
+     * type of unary/binary operators for ExprOp parse tree nodes
+     * </pre>
+     *
+     * Protobuf enum {@code ExprOpType}
+     */
+    public enum ExprOpType
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>EXPR_OP_TYPE_LESS = 0;</code>
+         */
+        EXPR_OP_TYPE_LESS(0),
+        /**
+         * <code>EXPR_OP_TYPE_GREATER = 1;</code>
+         */
+        EXPR_OP_TYPE_GREATER(1),
+        /**
+         * <code>EXPR_OP_TYPE_EQUALS = 2;</code>
+         */
+        EXPR_OP_TYPE_EQUALS(2),
+        /**
+         * <code>EXPR_OP_TYPE_LESS_EQUALS = 3;</code>
+         */
+        EXPR_OP_TYPE_LESS_EQUALS(3),
+        /**
+         * <code>EXPR_OP_TYPE_GREATER_EQUALS = 4;</code>
+         */
+        EXPR_OP_TYPE_GREATER_EQUALS(4),
+        /**
+         * <code>EXPR_OP_TYPE_NOT_EQUALS = 5;</code>
+         */
+        EXPR_OP_TYPE_NOT_EQUALS(5),
+        /**
+         * <code>EXPR_OP_TYPE_PLUS = 6;</code>
+         */
+        EXPR_OP_TYPE_PLUS(6),
+        /**
+         * <code>EXPR_OP_TYPE_MINUS = 7;</code>
+         */
+        EXPR_OP_TYPE_MINUS(7),
+        /**
+         * <code>EXPR_OP_TYPE_MULT = 8;</code>
+         */
+        EXPR_OP_TYPE_MULT(8),
+        /**
+         * <code>EXPR_OP_TYPE_DIV = 9;</code>
+         */
+        EXPR_OP_TYPE_DIV(9),
+        /**
+         * <code>EXPR_OP_TYPE_ENDSWITH = 10;</code>
+         */
+        EXPR_OP_TYPE_ENDSWITH(10),
+        /**
+         * <code>EXPR_OP_TYPE_OTHER = 11;</code>
+         */
+        EXPR_OP_TYPE_OTHER(11),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>EXPR_OP_TYPE_LESS = 0;</code>
+         */
+        public static final int EXPR_OP_TYPE_LESS_VALUE = 0;
+        /**
+         * <code>EXPR_OP_TYPE_GREATER = 1;</code>
+         */
+        public static final int EXPR_OP_TYPE_GREATER_VALUE = 1;
+        /**
+         * <code>EXPR_OP_TYPE_EQUALS = 2;</code>
+         */
+        public static final int EXPR_OP_TYPE_EQUALS_VALUE = 2;
+        /**
+         * <code>EXPR_OP_TYPE_LESS_EQUALS = 3;</code>
+         */
+        public static final int EXPR_OP_TYPE_LESS_EQUALS_VALUE = 3;
+        /**
+         * <code>EXPR_OP_TYPE_GREATER_EQUALS = 4;</code>
+         */
+        public static final int EXPR_OP_TYPE_GREATER_EQUALS_VALUE = 4;
+        /**
+         * <code>EXPR_OP_TYPE_NOT_EQUALS = 5;</code>
+         */
+        public static final int EXPR_OP_TYPE_NOT_EQUALS_VALUE = 5;
+        /**
+         * <code>EXPR_OP_TYPE_PLUS = 6;</code>
+         */
+        public static final int EXPR_OP_TYPE_PLUS_VALUE = 6;
+        /**
+         * <code>EXPR_OP_TYPE_MINUS = 7;</code>
+         */
+        public static final int EXPR_OP_TYPE_MINUS_VALUE = 7;
+        /**
+         * <code>EXPR_OP_TYPE_MULT = 8;</code>
+         */
+        public static final int EXPR_OP_TYPE_MULT_VALUE = 8;
+        /**
+         * <code>EXPR_OP_TYPE_DIV = 9;</code>
+         */
+        public static final int EXPR_OP_TYPE_DIV_VALUE = 9;
+        /**
+         * <code>EXPR_OP_TYPE_ENDSWITH = 10;</code>
+         */
+        public static final int EXPR_OP_TYPE_ENDSWITH_VALUE = 10;
+        /**
+         * <code>EXPR_OP_TYPE_OTHER = 11;</code>
+         */
+        public static final int EXPR_OP_TYPE_OTHER_VALUE = 11;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static ExprOpType valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static ExprOpType forNumber(int value) {
+            switch (value) {
+                case 0: return EXPR_OP_TYPE_LESS;
+                case 1: return EXPR_OP_TYPE_GREATER;
+                case 2: return EXPR_OP_TYPE_EQUALS;
+                case 3: return EXPR_OP_TYPE_LESS_EQUALS;
+                case 4: return EXPR_OP_TYPE_GREATER_EQUALS;
+                case 5: return EXPR_OP_TYPE_NOT_EQUALS;
+                case 6: return EXPR_OP_TYPE_PLUS;
+                case 7: return EXPR_OP_TYPE_MINUS;
+                case 8: return EXPR_OP_TYPE_MULT;
+                case 9: return EXPR_OP_TYPE_DIV;
+                case 10: return EXPR_OP_TYPE_ENDSWITH;
+                case 11: return EXPR_OP_TYPE_OTHER;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<ExprOpType>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                ExprOpType> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<ExprOpType>() {
+                    public ExprOpType findValueByNumber(int number) {
+                        return ExprOpType.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(5);
+        }
+
+        private static final ExprOpType[] VALUES = values();
+
+        public static ExprOpType valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private ExprOpType(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:ExprOpType)
+    }
+
+    /**
+     * <pre>
+     * type of boolean operators for ExprBool parse tree nodes
+     * </pre>
+     *
+     * Protobuf enum {@code ExprBoolType}
+     */
+    public enum ExprBoolType
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>EXPR_BOOL_TYPE_OR = 0;</code>
+         */
+        EXPR_BOOL_TYPE_OR(0),
+        /**
+         * <code>EXPR_BOOL_TYPE_AND = 1;</code>
+         */
+        EXPR_BOOL_TYPE_AND(1),
+        /**
+         * <code>EXPR_BOOL_TYPE_NOT = 2;</code>
+         */
+        EXPR_BOOL_TYPE_NOT(2),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>EXPR_BOOL_TYPE_OR = 0;</code>
+         */
+        public static final int EXPR_BOOL_TYPE_OR_VALUE = 0;
+        /**
+         * <code>EXPR_BOOL_TYPE_AND = 1;</code>
+         */
+        public static final int EXPR_BOOL_TYPE_AND_VALUE = 1;
+        /**
+         * <code>EXPR_BOOL_TYPE_NOT = 2;</code>
+         */
+        public static final int EXPR_BOOL_TYPE_NOT_VALUE = 2;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static ExprBoolType valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static ExprBoolType forNumber(int value) {
+            switch (value) {
+                case 0: return EXPR_BOOL_TYPE_OR;
+                case 1: return EXPR_BOOL_TYPE_AND;
+                case 2: return EXPR_BOOL_TYPE_NOT;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<ExprBoolType>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                ExprBoolType> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<ExprBoolType>() {
+                    public ExprBoolType findValueByNumber(int number) {
+                        return ExprBoolType.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(6);
+        }
+
+        private static final ExprBoolType[] VALUES = values();
+
+        public static ExprBoolType valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private ExprBoolType(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:ExprBoolType)
+    }
+
+    /**
+     * <pre>
+     * type of constant for ExprConst parse tree nodes
+     * </pre>
+     *
+     * Protobuf enum {@code ExprConstType}
+     */
+    public enum ExprConstType
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>EXPR_CONST_TYPE_STRING = 0;</code>
+         */
+        EXPR_CONST_TYPE_STRING(0),
+        /**
+         * <code>EXPR_CONST_TYPE_INT = 1;</code>
+         */
+        EXPR_CONST_TYPE_INT(1),
+        /**
+         * <code>EXPR_CONST_TYPE_LONG = 2;</code>
+         */
+        EXPR_CONST_TYPE_LONG(2),
+        /**
+         * <code>EXPR_CONST_TYPE_DOUBLE = 3;</code>
+         */
+        EXPR_CONST_TYPE_DOUBLE(3),
+        /**
+         * <code>EXPR_CONST_TYPE_BOOLEAN = 4;</code>
+         */
+        EXPR_CONST_TYPE_BOOLEAN(4),
+        /**
+         * <code>EXPR_CONST_TYPE_DATE = 5;</code>
+         */
+        EXPR_CONST_TYPE_DATE(5),
+        /**
+         * <code>EXPR_CONST_TYPE_NULL = 6;</code>
+         */
+        EXPR_CONST_TYPE_NULL(6),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>EXPR_CONST_TYPE_STRING = 0;</code>
+         */
+        public static final int EXPR_CONST_TYPE_STRING_VALUE = 0;
+        /**
+         * <code>EXPR_CONST_TYPE_INT = 1;</code>
+         */
+        public static final int EXPR_CONST_TYPE_INT_VALUE = 1;
+        /**
+         * <code>EXPR_CONST_TYPE_LONG = 2;</code>
+         */
+        public static final int EXPR_CONST_TYPE_LONG_VALUE = 2;
+        /**
+         * <code>EXPR_CONST_TYPE_DOUBLE = 3;</code>
+         */
+        public static final int EXPR_CONST_TYPE_DOUBLE_VALUE = 3;
+        /**
+         * <code>EXPR_CONST_TYPE_BOOLEAN = 4;</code>
+         */
+        public static final int EXPR_CONST_TYPE_BOOLEAN_VALUE = 4;
+        /**
+         * <code>EXPR_CONST_TYPE_DATE = 5;</code>
+         */
+        public static final int EXPR_CONST_TYPE_DATE_VALUE = 5;
+        /**
+         * <code>EXPR_CONST_TYPE_NULL = 6;</code>
+         */
+        public static final int EXPR_CONST_TYPE_NULL_VALUE = 6;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static ExprConstType valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static ExprConstType forNumber(int value) {
+            switch (value) {
+                case 0: return EXPR_CONST_TYPE_STRING;
+                case 1: return EXPR_CONST_TYPE_INT;
+                case 2: return EXPR_CONST_TYPE_LONG;
+                case 3: return EXPR_CONST_TYPE_DOUBLE;
+                case 4: return EXPR_CONST_TYPE_BOOLEAN;
+                case 5: return EXPR_CONST_TYPE_DATE;
+                case 6: return EXPR_CONST_TYPE_NULL;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<ExprConstType>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                ExprConstType> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<ExprConstType>() {
+                    public ExprConstType findValueByNumber(int number) {
+                        return ExprConstType.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(7);
+        }
+
+        private static final ExprConstType[] VALUES = values();
+
+        public static ExprConstType valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private ExprConstType(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:ExprConstType)
+    }
+
+    /**
+     * Protobuf enum {@code BufCompression}
+     */
+    public enum BufCompression
+            implements com.google.protobuf.ProtocolMessageEnum {
+        /**
+         * <code>BUF_NO_COMPRESSION = 0;</code>
+         */
+        BUF_NO_COMPRESSION(0),
+        /**
+         * <code>BUF_SNAPPY_COMPRESSION = 1;</code>
+         */
+        BUF_SNAPPY_COMPRESSION(1),
+        UNRECOGNIZED(-1),
+        ;
+
+        /**
+         * <code>BUF_NO_COMPRESSION = 0;</code>
+         */
+        public static final int BUF_NO_COMPRESSION_VALUE = 0;
+        /**
+         * <code>BUF_SNAPPY_COMPRESSION = 1;</code>
+         */
+        public static final int BUF_SNAPPY_COMPRESSION_VALUE = 1;
+
+
+        public final int getNumber() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalArgumentException(
+                        "Can't get the number of an unknown enum value.");
+            }
+            return value;
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         * @deprecated Use {@link #forNumber(int)} instead.
+         */
+        @java.lang.Deprecated
+        public static BufCompression valueOf(int value) {
+            return forNumber(value);
+        }
+
+        /**
+         * @param value The numeric wire value of the corresponding enum entry.
+         * @return The enum associated with the given numeric wire value.
+         */
+        public static BufCompression forNumber(int value) {
+            switch (value) {
+                case 0: return BUF_NO_COMPRESSION;
+                case 1: return BUF_SNAPPY_COMPRESSION;
+                default: return null;
+            }
+        }
+
+        public static com.google.protobuf.Internal.EnumLiteMap<BufCompression>
+        internalGetValueMap() {
+            return internalValueMap;
+        }
+        private static final com.google.protobuf.Internal.EnumLiteMap<
+                BufCompression> internalValueMap =
+                new com.google.protobuf.Internal.EnumLiteMap<BufCompression>() {
+                    public BufCompression findValueByNumber(int number) {
+                        return BufCompression.forNumber(number);
+                    }
+                };
+
+        public final com.google.protobuf.Descriptors.EnumValueDescriptor
+        getValueDescriptor() {
+            if (this == UNRECOGNIZED) {
+                throw new java.lang.IllegalStateException(
+                        "Can't get the descriptor of an unrecognized enum value.");
+            }
+            return getDescriptor().getValues().get(ordinal());
+        }
+        public final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptorForType() {
+            return getDescriptor();
+        }
+        public static final com.google.protobuf.Descriptors.EnumDescriptor
+        getDescriptor() {
+            return Grpccatalog.getDescriptor().getEnumTypes().get(8);
+        }
+
+        private static final BufCompression[] VALUES = values();
+
+        public static BufCompression valueOf(
+                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
+            if (desc.getType() != getDescriptor()) {
+                throw new java.lang.IllegalArgumentException(
+                        "EnumValueDescriptor is not for this type.");
+            }
+            if (desc.getIndex() == -1) {
+                return UNRECOGNIZED;
+            }
+            return VALUES[desc.getIndex()];
+        }
+
+        private final int value;
+
+        private BufCompression(int value) {
+            this.value = value;
+        }
+
+        // @@protoc_insertion_point(enum_scope:BufCompression)
+    }
+
+    public interface FieldOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:Field)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The fieldName.
+         */
+        java.lang.String getFieldName();
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The bytes for fieldName.
+         */
+        com.google.protobuf.ByteString
+        getFieldNameBytes();
+
+        /**
+         * <code>optional string field_value = 2;</code>
+         * @return Whether the fieldValue field is set.
+         */
+        boolean hasFieldValue();
+        /**
+         * <code>optional string field_value = 2;</code>
+         * @return The fieldValue.
+         */
+        java.lang.String getFieldValue();
+        /**
+         * <code>optional string field_value = 2;</code>
+         * @return The bytes for fieldValue.
+         */
+        com.google.protobuf.ByteString
+        getFieldValueBytes();
+    }
+    /**
+     * <pre>
+     * a field has a name and the corresponding value, if absent, is
+     * considered NULL
+     * </pre>
+     *
+     * Protobuf type {@code Field}
+     */
+    public static final class Field extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:Field)
+            FieldOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use Field.newBuilder() to construct.
+        private Field(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private Field() {
+            fieldName_ = "";
+            fieldValue_ = "";
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new Field();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_Field_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_Field_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.Field.class, Grpccatalog.Field.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int FIELD_NAME_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object fieldName_ = "";
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The fieldName.
+         */
+        @java.lang.Override
+        public java.lang.String getFieldName() {
+            java.lang.Object ref = fieldName_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                fieldName_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The bytes for fieldName.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getFieldNameBytes() {
+            java.lang.Object ref = fieldName_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                fieldName_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int FIELD_VALUE_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object fieldValue_ = "";
+        /**
+         * <code>optional string field_value = 2;</code>
+         * @return Whether the fieldValue field is set.
+         */
+        @java.lang.Override
+        public boolean hasFieldValue() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional string field_value = 2;</code>
+         * @return The fieldValue.
+         */
+        @java.lang.Override
+        public java.lang.String getFieldValue() {
+            java.lang.Object ref = fieldValue_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                fieldValue_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>optional string field_value = 2;</code>
+         * @return The bytes for fieldValue.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getFieldValueBytes() {
+            java.lang.Object ref = fieldValue_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                fieldValue_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fieldName_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, fieldName_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, fieldValue_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fieldName_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, fieldName_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, fieldValue_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.Field)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.Field other = (Grpccatalog.Field) obj;
+
+            if (!getFieldName()
+                    .equals(other.getFieldName())) return false;
+            if (hasFieldValue() != other.hasFieldValue()) return false;
+            if (hasFieldValue()) {
+                if (!getFieldValue()
+                        .equals(other.getFieldValue())) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + FIELD_NAME_FIELD_NUMBER;
+            hash = (53 * hash) + getFieldName().hashCode();
+            if (hasFieldValue()) {
+                hash = (37 * hash) + FIELD_VALUE_FIELD_NUMBER;
+                hash = (53 * hash) + getFieldValue().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.Field parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Field parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Field parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Field parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Field parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Field parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Field parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Field parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Field parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Field parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Field parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Field parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.Field prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * a field has a name and the corresponding value, if absent, is
+         * considered NULL
+         * </pre>
+         *
+         * Protobuf type {@code Field}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:Field)
+                Grpccatalog.FieldOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_Field_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_Field_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.Field.class, Grpccatalog.Field.Builder.class);
+            }
+
+            // Construct using Grpccatalog.Field.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                fieldName_ = "";
+                fieldValue_ = "";
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_Field_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Field getDefaultInstanceForType() {
+                return Grpccatalog.Field.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Field build() {
+                Grpccatalog.Field result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Field buildPartial() {
+                Grpccatalog.Field result = new Grpccatalog.Field(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.Field result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.fieldName_ = fieldName_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.fieldValue_ = fieldValue_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.Field) {
+                    return mergeFrom((Grpccatalog.Field)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.Field other) {
+                if (other == Grpccatalog.Field.getDefaultInstance()) return this;
+                if (!other.getFieldName().isEmpty()) {
+                    fieldName_ = other.fieldName_;
+                    bitField0_ |= 0x00000001;
+                    onChanged();
+                }
+                if (other.hasFieldValue()) {
+                    fieldValue_ = other.fieldValue_;
+                    bitField0_ |= 0x00000002;
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                fieldName_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            case 18: {
+                                fieldValue_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.lang.Object fieldName_ = "";
+            /**
+             * <code>string field_name = 1;</code>
+             * @return The fieldName.
+             */
+            public java.lang.String getFieldName() {
+                java.lang.Object ref = fieldName_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    fieldName_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @return The bytes for fieldName.
+             */
+            public com.google.protobuf.ByteString
+            getFieldNameBytes() {
+                java.lang.Object ref = fieldName_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    fieldName_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @param value The fieldName to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldName(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                fieldName_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearFieldName() {
+                fieldName_ = getDefaultInstance().getFieldName();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @param value The bytes for fieldName to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldNameBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                fieldName_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+
+            private java.lang.Object fieldValue_ = "";
+            /**
+             * <code>optional string field_value = 2;</code>
+             * @return Whether the fieldValue field is set.
+             */
+            public boolean hasFieldValue() {
+                return ((bitField0_ & 0x00000002) != 0);
+            }
+            /**
+             * <code>optional string field_value = 2;</code>
+             * @return The fieldValue.
+             */
+            public java.lang.String getFieldValue() {
+                java.lang.Object ref = fieldValue_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    fieldValue_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>optional string field_value = 2;</code>
+             * @return The bytes for fieldValue.
+             */
+            public com.google.protobuf.ByteString
+            getFieldValueBytes() {
+                java.lang.Object ref = fieldValue_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    fieldValue_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>optional string field_value = 2;</code>
+             * @param value The fieldValue to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldValue(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                fieldValue_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional string field_value = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearFieldValue() {
+                fieldValue_ = getDefaultInstance().getFieldValue();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional string field_value = 2;</code>
+             * @param value The bytes for fieldValue to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldValueBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                fieldValue_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:Field)
+        }
+
+        // @@protoc_insertion_point(class_scope:Field)
+        private static final Grpccatalog.Field DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.Field();
+        }
+
+        public static Grpccatalog.Field getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<Field>
+                PARSER = new com.google.protobuf.AbstractParser<Field>() {
+            @java.lang.Override
+            public Field parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<Field> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<Field> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.Field getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface FieldDefOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:FieldDef)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The fieldName.
+         */
+        java.lang.String getFieldName();
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The bytes for fieldName.
+         */
+        com.google.protobuf.ByteString
+        getFieldNameBytes();
+
+        /**
+         * <pre>
+         * Potentially change this to enum.
+         * </pre>
+         *
+         * <code>string field_def = 2;</code>
+         * @return The fieldDef.
+         */
+        java.lang.String getFieldDef();
+        /**
+         * <pre>
+         * Potentially change this to enum.
+         * </pre>
+         *
+         * <code>string field_def = 2;</code>
+         * @return The bytes for fieldDef.
+         */
+        com.google.protobuf.ByteString
+        getFieldDefBytes();
+    }
+    /**
+     * <pre>
+     * field definition has field name and the corresponding
+     * definition, which is required.
+     * </pre>
+     *
+     * Protobuf type {@code FieldDef}
+     */
+    public static final class FieldDef extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:FieldDef)
+            FieldDefOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use FieldDef.newBuilder() to construct.
+        private FieldDef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private FieldDef() {
+            fieldName_ = "";
+            fieldDef_ = "";
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new FieldDef();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_FieldDef_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_FieldDef_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.FieldDef.class, Grpccatalog.FieldDef.Builder.class);
+        }
+
+        public static final int FIELD_NAME_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object fieldName_ = "";
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The fieldName.
+         */
+        @java.lang.Override
+        public java.lang.String getFieldName() {
+            java.lang.Object ref = fieldName_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                fieldName_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>string field_name = 1;</code>
+         * @return The bytes for fieldName.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getFieldNameBytes() {
+            java.lang.Object ref = fieldName_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                fieldName_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int FIELD_DEF_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object fieldDef_ = "";
+        /**
+         * <pre>
+         * Potentially change this to enum.
+         * </pre>
+         *
+         * <code>string field_def = 2;</code>
+         * @return The fieldDef.
+         */
+        @java.lang.Override
+        public java.lang.String getFieldDef() {
+            java.lang.Object ref = fieldDef_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                fieldDef_ = s;
+                return s;
+            }
+        }
+        /**
+         * <pre>
+         * Potentially change this to enum.
+         * </pre>
+         *
+         * <code>string field_def = 2;</code>
+         * @return The bytes for fieldDef.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getFieldDefBytes() {
+            java.lang.Object ref = fieldDef_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                fieldDef_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fieldName_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, fieldName_);
+            }
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fieldDef_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, fieldDef_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fieldName_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, fieldName_);
+            }
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(fieldDef_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, fieldDef_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.FieldDef)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.FieldDef other = (Grpccatalog.FieldDef) obj;
+
+            if (!getFieldName()
+                    .equals(other.getFieldName())) return false;
+            if (!getFieldDef()
+                    .equals(other.getFieldDef())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + FIELD_NAME_FIELD_NUMBER;
+            hash = (53 * hash) + getFieldName().hashCode();
+            hash = (37 * hash) + FIELD_DEF_FIELD_NUMBER;
+            hash = (53 * hash) + getFieldDef().hashCode();
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.FieldDef parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.FieldDef parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.FieldDef parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.FieldDef parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.FieldDef parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.FieldDef parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.FieldDef prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * field definition has field name and the corresponding
+         * definition, which is required.
+         * </pre>
+         *
+         * Protobuf type {@code FieldDef}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:FieldDef)
+                Grpccatalog.FieldDefOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_FieldDef_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_FieldDef_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.FieldDef.class, Grpccatalog.FieldDef.Builder.class);
+            }
+
+            // Construct using Grpccatalog.FieldDef.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                fieldName_ = "";
+                fieldDef_ = "";
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_FieldDef_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.FieldDef getDefaultInstanceForType() {
+                return Grpccatalog.FieldDef.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.FieldDef build() {
+                Grpccatalog.FieldDef result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.FieldDef buildPartial() {
+                Grpccatalog.FieldDef result = new Grpccatalog.FieldDef(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.FieldDef result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.fieldName_ = fieldName_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.fieldDef_ = fieldDef_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.FieldDef) {
+                    return mergeFrom((Grpccatalog.FieldDef)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.FieldDef other) {
+                if (other == Grpccatalog.FieldDef.getDefaultInstance()) return this;
+                if (!other.getFieldName().isEmpty()) {
+                    fieldName_ = other.fieldName_;
+                    bitField0_ |= 0x00000001;
+                    onChanged();
+                }
+                if (!other.getFieldDef().isEmpty()) {
+                    fieldDef_ = other.fieldDef_;
+                    bitField0_ |= 0x00000002;
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                fieldName_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            case 18: {
+                                fieldDef_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.lang.Object fieldName_ = "";
+            /**
+             * <code>string field_name = 1;</code>
+             * @return The fieldName.
+             */
+            public java.lang.String getFieldName() {
+                java.lang.Object ref = fieldName_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    fieldName_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @return The bytes for fieldName.
+             */
+            public com.google.protobuf.ByteString
+            getFieldNameBytes() {
+                java.lang.Object ref = fieldName_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    fieldName_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @param value The fieldName to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldName(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                fieldName_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearFieldName() {
+                fieldName_ = getDefaultInstance().getFieldName();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string field_name = 1;</code>
+             * @param value The bytes for fieldName to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldNameBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                fieldName_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+
+            private java.lang.Object fieldDef_ = "";
+            /**
+             * <pre>
+             * Potentially change this to enum.
+             * </pre>
+             *
+             * <code>string field_def = 2;</code>
+             * @return The fieldDef.
+             */
+            public java.lang.String getFieldDef() {
+                java.lang.Object ref = fieldDef_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    fieldDef_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <pre>
+             * Potentially change this to enum.
+             * </pre>
+             *
+             * <code>string field_def = 2;</code>
+             * @return The bytes for fieldDef.
+             */
+            public com.google.protobuf.ByteString
+            getFieldDefBytes() {
+                java.lang.Object ref = fieldDef_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    fieldDef_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <pre>
+             * Potentially change this to enum.
+             * </pre>
+             *
+             * <code>string field_def = 2;</code>
+             * @param value The fieldDef to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldDef(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                fieldDef_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <pre>
+             * Potentially change this to enum.
+             * </pre>
+             *
+             * <code>string field_def = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearFieldDef() {
+                fieldDef_ = getDefaultInstance().getFieldDef();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                onChanged();
+                return this;
+            }
+            /**
+             * <pre>
+             * Potentially change this to enum.
+             * </pre>
+             *
+             * <code>string field_def = 2;</code>
+             * @param value The bytes for fieldDef to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldDefBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                fieldDef_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:FieldDef)
+        }
+
+        // @@protoc_insertion_point(class_scope:FieldDef)
+        private static final Grpccatalog.FieldDef DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.FieldDef();
+        }
+
+        public static Grpccatalog.FieldDef getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<FieldDef>
+                PARSER = new com.google.protobuf.AbstractParser<FieldDef>() {
+            @java.lang.Override
+            public FieldDef parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<FieldDef> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<FieldDef> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.FieldDef getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExtObjTypeNameOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExtObjTypeName)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ObjTypeName obj_type_name = 1;</code>
+         * @return The enum numeric value on the wire for objTypeName.
+         */
+        int getObjTypeNameValue();
+        /**
+         * <code>.ObjTypeName obj_type_name = 1;</code>
+         * @return The objTypeName.
+         */
+        Grpccatalog.ObjTypeName getObjTypeName();
+
+        /**
+         * <code>optional string extension = 2;</code>
+         * @return Whether the extension field is set.
+         */
+        boolean hasExtension();
+        /**
+         * <code>optional string extension = 2;</code>
+         * @return The extension.
+         */
+        java.lang.String getExtension();
+        /**
+         * <code>optional string extension = 2;</code>
+         * @return The bytes for extension.
+         */
+        com.google.protobuf.ByteString
+        getExtensionBytes();
+    }
+    /**
+     * <pre>
+     * an extended typename has an extension if obj_type_name is OTHER
+     * </pre>
+     *
+     * Protobuf type {@code ExtObjTypeName}
+     */
+    public static final class ExtObjTypeName extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExtObjTypeName)
+            ExtObjTypeNameOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExtObjTypeName.newBuilder() to construct.
+        private ExtObjTypeName(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExtObjTypeName() {
+            objTypeName_ = 0;
+            extension_ = "";
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExtObjTypeName();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExtObjTypeName_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExtObjTypeName_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExtObjTypeName.class, Grpccatalog.ExtObjTypeName.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int OBJ_TYPE_NAME_FIELD_NUMBER = 1;
+        private int objTypeName_ = 0;
+        /**
+         * <code>.ObjTypeName obj_type_name = 1;</code>
+         * @return The enum numeric value on the wire for objTypeName.
+         */
+        @java.lang.Override public int getObjTypeNameValue() {
+            return objTypeName_;
+        }
+        /**
+         * <code>.ObjTypeName obj_type_name = 1;</code>
+         * @return The objTypeName.
+         */
+        @java.lang.Override public Grpccatalog.ObjTypeName getObjTypeName() {
+            Grpccatalog.ObjTypeName result = Grpccatalog.ObjTypeName.forNumber(objTypeName_);
+            return result == null ? Grpccatalog.ObjTypeName.UNRECOGNIZED : result;
+        }
+
+        public static final int EXTENSION_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object extension_ = "";
+        /**
+         * <code>optional string extension = 2;</code>
+         * @return Whether the extension field is set.
+         */
+        @java.lang.Override
+        public boolean hasExtension() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional string extension = 2;</code>
+         * @return The extension.
+         */
+        @java.lang.Override
+        public java.lang.String getExtension() {
+            java.lang.Object ref = extension_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                extension_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>optional string extension = 2;</code>
+         * @return The bytes for extension.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getExtensionBytes() {
+            java.lang.Object ref = extension_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                extension_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (objTypeName_ != Grpccatalog.ObjTypeName.OBJ_TYPE_NAME_DATABASE.getNumber()) {
+                output.writeEnum(1, objTypeName_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, extension_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (objTypeName_ != Grpccatalog.ObjTypeName.OBJ_TYPE_NAME_DATABASE.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(1, objTypeName_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, extension_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExtObjTypeName)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExtObjTypeName other = (Grpccatalog.ExtObjTypeName) obj;
+
+            if (objTypeName_ != other.objTypeName_) return false;
+            if (hasExtension() != other.hasExtension()) return false;
+            if (hasExtension()) {
+                if (!getExtension()
+                        .equals(other.getExtension())) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + OBJ_TYPE_NAME_FIELD_NUMBER;
+            hash = (53 * hash) + objTypeName_;
+            if (hasExtension()) {
+                hash = (37 * hash) + EXTENSION_FIELD_NUMBER;
+                hash = (53 * hash) + getExtension().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExtObjTypeName parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExtObjTypeName parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExtObjTypeName parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExtObjTypeName prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * an extended typename has an extension if obj_type_name is OTHER
+         * </pre>
+         *
+         * Protobuf type {@code ExtObjTypeName}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExtObjTypeName)
+                Grpccatalog.ExtObjTypeNameOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExtObjTypeName_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExtObjTypeName_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExtObjTypeName.class, Grpccatalog.ExtObjTypeName.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExtObjTypeName.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                objTypeName_ = 0;
+                extension_ = "";
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExtObjTypeName_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExtObjTypeName getDefaultInstanceForType() {
+                return Grpccatalog.ExtObjTypeName.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExtObjTypeName build() {
+                Grpccatalog.ExtObjTypeName result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExtObjTypeName buildPartial() {
+                Grpccatalog.ExtObjTypeName result = new Grpccatalog.ExtObjTypeName(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ExtObjTypeName result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.objTypeName_ = objTypeName_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.extension_ = extension_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExtObjTypeName) {
+                    return mergeFrom((Grpccatalog.ExtObjTypeName)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExtObjTypeName other) {
+                if (other == Grpccatalog.ExtObjTypeName.getDefaultInstance()) return this;
+                if (other.objTypeName_ != 0) {
+                    setObjTypeNameValue(other.getObjTypeNameValue());
+                }
+                if (other.hasExtension()) {
+                    extension_ = other.extension_;
+                    bitField0_ |= 0x00000002;
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                objTypeName_ = input.readEnum();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 18: {
+                                extension_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private int objTypeName_ = 0;
+            /**
+             * <code>.ObjTypeName obj_type_name = 1;</code>
+             * @return The enum numeric value on the wire for objTypeName.
+             */
+            @java.lang.Override public int getObjTypeNameValue() {
+                return objTypeName_;
+            }
+            /**
+             * <code>.ObjTypeName obj_type_name = 1;</code>
+             * @param value The enum numeric value on the wire for objTypeName to set.
+             * @return This builder for chaining.
+             */
+            public Builder setObjTypeNameValue(int value) {
+                objTypeName_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ObjTypeName obj_type_name = 1;</code>
+             * @return The objTypeName.
+             */
+            @java.lang.Override
+            public Grpccatalog.ObjTypeName getObjTypeName() {
+                Grpccatalog.ObjTypeName result = Grpccatalog.ObjTypeName.forNumber(objTypeName_);
+                return result == null ? Grpccatalog.ObjTypeName.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.ObjTypeName obj_type_name = 1;</code>
+             * @param value The objTypeName to set.
+             * @return This builder for chaining.
+             */
+            public Builder setObjTypeName(Grpccatalog.ObjTypeName value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                objTypeName_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ObjTypeName obj_type_name = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearObjTypeName() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                objTypeName_ = 0;
+                onChanged();
+                return this;
+            }
+
+            private java.lang.Object extension_ = "";
+            /**
+             * <code>optional string extension = 2;</code>
+             * @return Whether the extension field is set.
+             */
+            public boolean hasExtension() {
+                return ((bitField0_ & 0x00000002) != 0);
+            }
+            /**
+             * <code>optional string extension = 2;</code>
+             * @return The extension.
+             */
+            public java.lang.String getExtension() {
+                java.lang.Object ref = extension_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    extension_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>optional string extension = 2;</code>
+             * @return The bytes for extension.
+             */
+            public com.google.protobuf.ByteString
+            getExtensionBytes() {
+                java.lang.Object ref = extension_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    extension_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>optional string extension = 2;</code>
+             * @param value The extension to set.
+             * @return This builder for chaining.
+             */
+            public Builder setExtension(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                extension_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional string extension = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearExtension() {
+                extension_ = getDefaultInstance().getExtension();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional string extension = 2;</code>
+             * @param value The bytes for extension to set.
+             * @return This builder for chaining.
+             */
+            public Builder setExtensionBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                extension_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExtObjTypeName)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExtObjTypeName)
+        private static final Grpccatalog.ExtObjTypeName DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExtObjTypeName();
+        }
+
+        public static Grpccatalog.ExtObjTypeName getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExtObjTypeName>
+                PARSER = new com.google.protobuf.AbstractParser<ExtObjTypeName>() {
+            @java.lang.Override
+            public ExtObjTypeName parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExtObjTypeName> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExtObjTypeName> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExtObjTypeName getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ObjTypeDefOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ObjTypeDef)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return Whether the extObjTypeName field is set.
+         */
+        boolean hasExtObjTypeName();
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return The extObjTypeName.
+         */
+        Grpccatalog.ExtObjTypeName getExtObjTypeName();
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         */
+        Grpccatalog.ExtObjTypeNameOrBuilder getExtObjTypeNameOrBuilder();
+
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        java.util.List<Grpccatalog.FieldDef>
+        getFieldDefsList();
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        Grpccatalog.FieldDef getFieldDefs(int index);
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        int getFieldDefsCount();
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        java.util.List<? extends Grpccatalog.FieldDefOrBuilder>
+        getFieldDefsOrBuilderList();
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        Grpccatalog.FieldDefOrBuilder getFieldDefsOrBuilder(
+                int index);
+    }
+    /**
+     * <pre>
+     * A type definition has a extended type name and a list of field
+     * definitions.
+     * TODO(LATER): Add more information to parse the type.
+     * </pre>
+     *
+     * Protobuf type {@code ObjTypeDef}
+     */
+    public static final class ObjTypeDef extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ObjTypeDef)
+            ObjTypeDefOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ObjTypeDef.newBuilder() to construct.
+        private ObjTypeDef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ObjTypeDef() {
+            fieldDefs_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ObjTypeDef();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ObjTypeDef_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ObjTypeDef_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ObjTypeDef.class, Grpccatalog.ObjTypeDef.Builder.class);
+        }
+
+        public static final int EXT_OBJ_TYPE_NAME_FIELD_NUMBER = 1;
+        private Grpccatalog.ExtObjTypeName extObjTypeName_;
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return Whether the extObjTypeName field is set.
+         */
+        @java.lang.Override
+        public boolean hasExtObjTypeName() {
+            return extObjTypeName_ != null;
+        }
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return The extObjTypeName.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExtObjTypeName getExtObjTypeName() {
+            return extObjTypeName_ == null ? Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+        }
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExtObjTypeNameOrBuilder getExtObjTypeNameOrBuilder() {
+            return extObjTypeName_ == null ? Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+        }
+
+        public static final int FIELD_DEFS_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private java.util.List<Grpccatalog.FieldDef> fieldDefs_;
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<Grpccatalog.FieldDef> getFieldDefsList() {
+            return fieldDefs_;
+        }
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<? extends Grpccatalog.FieldDefOrBuilder>
+        getFieldDefsOrBuilderList() {
+            return fieldDefs_;
+        }
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        @java.lang.Override
+        public int getFieldDefsCount() {
+            return fieldDefs_.size();
+        }
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.FieldDef getFieldDefs(int index) {
+            return fieldDefs_.get(index);
+        }
+        /**
+         * <code>repeated .FieldDef field_defs = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.FieldDefOrBuilder getFieldDefsOrBuilder(
+                int index) {
+            return fieldDefs_.get(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (extObjTypeName_ != null) {
+                output.writeMessage(1, getExtObjTypeName());
+            }
+            for (int i = 0; i < fieldDefs_.size(); i++) {
+                output.writeMessage(2, fieldDefs_.get(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (extObjTypeName_ != null) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(1, getExtObjTypeName());
+            }
+            for (int i = 0; i < fieldDefs_.size(); i++) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(2, fieldDefs_.get(i));
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ObjTypeDef)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ObjTypeDef other = (Grpccatalog.ObjTypeDef) obj;
+
+            if (hasExtObjTypeName() != other.hasExtObjTypeName()) return false;
+            if (hasExtObjTypeName()) {
+                if (!getExtObjTypeName()
+                        .equals(other.getExtObjTypeName())) return false;
+            }
+            if (!getFieldDefsList()
+                    .equals(other.getFieldDefsList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (hasExtObjTypeName()) {
+                hash = (37 * hash) + EXT_OBJ_TYPE_NAME_FIELD_NUMBER;
+                hash = (53 * hash) + getExtObjTypeName().hashCode();
+            }
+            if (getFieldDefsCount() > 0) {
+                hash = (37 * hash) + FIELD_DEFS_FIELD_NUMBER;
+                hash = (53 * hash) + getFieldDefsList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ObjTypeDef parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ObjTypeDef parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ObjTypeDef parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ObjTypeDef prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * A type definition has a extended type name and a list of field
+         * definitions.
+         * TODO(LATER): Add more information to parse the type.
+         * </pre>
+         *
+         * Protobuf type {@code ObjTypeDef}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ObjTypeDef)
+                Grpccatalog.ObjTypeDefOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ObjTypeDef_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ObjTypeDef_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ObjTypeDef.class, Grpccatalog.ObjTypeDef.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ObjTypeDef.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                extObjTypeName_ = null;
+                if (extObjTypeNameBuilder_ != null) {
+                    extObjTypeNameBuilder_.dispose();
+                    extObjTypeNameBuilder_ = null;
+                }
+                if (fieldDefsBuilder_ == null) {
+                    fieldDefs_ = java.util.Collections.emptyList();
+                } else {
+                    fieldDefs_ = null;
+                    fieldDefsBuilder_.clear();
+                }
+                bitField0_ = (bitField0_ & ~0x00000002);
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ObjTypeDef_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ObjTypeDef getDefaultInstanceForType() {
+                return Grpccatalog.ObjTypeDef.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ObjTypeDef build() {
+                Grpccatalog.ObjTypeDef result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ObjTypeDef buildPartial() {
+                Grpccatalog.ObjTypeDef result = new Grpccatalog.ObjTypeDef(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.ObjTypeDef result) {
+                if (fieldDefsBuilder_ == null) {
+                    if (((bitField0_ & 0x00000002) != 0)) {
+                        fieldDefs_ = java.util.Collections.unmodifiableList(fieldDefs_);
+                        bitField0_ = (bitField0_ & ~0x00000002);
+                    }
+                    result.fieldDefs_ = fieldDefs_;
+                } else {
+                    result.fieldDefs_ = fieldDefsBuilder_.build();
+                }
+            }
+
+            private void buildPartial0(Grpccatalog.ObjTypeDef result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.extObjTypeName_ = extObjTypeNameBuilder_ == null
+                            ? extObjTypeName_
+                            : extObjTypeNameBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ObjTypeDef) {
+                    return mergeFrom((Grpccatalog.ObjTypeDef)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ObjTypeDef other) {
+                if (other == Grpccatalog.ObjTypeDef.getDefaultInstance()) return this;
+                if (other.hasExtObjTypeName()) {
+                    mergeExtObjTypeName(other.getExtObjTypeName());
+                }
+                if (fieldDefsBuilder_ == null) {
+                    if (!other.fieldDefs_.isEmpty()) {
+                        if (fieldDefs_.isEmpty()) {
+                            fieldDefs_ = other.fieldDefs_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                        } else {
+                            ensureFieldDefsIsMutable();
+                            fieldDefs_.addAll(other.fieldDefs_);
+                        }
+                        onChanged();
+                    }
+                } else {
+                    if (!other.fieldDefs_.isEmpty()) {
+                        if (fieldDefsBuilder_.isEmpty()) {
+                            fieldDefsBuilder_.dispose();
+                            fieldDefsBuilder_ = null;
+                            fieldDefs_ = other.fieldDefs_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                            fieldDefsBuilder_ =
+                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
+                                            getFieldDefsFieldBuilder() : null;
+                        } else {
+                            fieldDefsBuilder_.addAllMessages(other.fieldDefs_);
+                        }
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                input.readMessage(
+                                        getExtObjTypeNameFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            case 18: {
+                                Grpccatalog.FieldDef m =
+                                        input.readMessage(
+                                                Grpccatalog.FieldDef.parser(),
+                                                extensionRegistry);
+                                if (fieldDefsBuilder_ == null) {
+                                    ensureFieldDefsIsMutable();
+                                    fieldDefs_.add(m);
+                                } else {
+                                    fieldDefsBuilder_.addMessage(m);
+                                }
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private Grpccatalog.ExtObjTypeName extObjTypeName_;
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExtObjTypeName, Grpccatalog.ExtObjTypeName.Builder, Grpccatalog.ExtObjTypeNameOrBuilder> extObjTypeNameBuilder_;
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             * @return Whether the extObjTypeName field is set.
+             */
+            public boolean hasExtObjTypeName() {
+                return ((bitField0_ & 0x00000001) != 0);
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             * @return The extObjTypeName.
+             */
+            public Grpccatalog.ExtObjTypeName getExtObjTypeName() {
+                if (extObjTypeNameBuilder_ == null) {
+                    return extObjTypeName_ == null ? Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+                } else {
+                    return extObjTypeNameBuilder_.getMessage();
+                }
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder setExtObjTypeName(Grpccatalog.ExtObjTypeName value) {
+                if (extObjTypeNameBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    extObjTypeName_ = value;
+                } else {
+                    extObjTypeNameBuilder_.setMessage(value);
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder setExtObjTypeName(
+                    Grpccatalog.ExtObjTypeName.Builder builderForValue) {
+                if (extObjTypeNameBuilder_ == null) {
+                    extObjTypeName_ = builderForValue.build();
+                } else {
+                    extObjTypeNameBuilder_.setMessage(builderForValue.build());
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder mergeExtObjTypeName(Grpccatalog.ExtObjTypeName value) {
+                if (extObjTypeNameBuilder_ == null) {
+                    if (((bitField0_ & 0x00000001) != 0) &&
+                            extObjTypeName_ != null &&
+                            extObjTypeName_ != Grpccatalog.ExtObjTypeName.getDefaultInstance()) {
+                        getExtObjTypeNameBuilder().mergeFrom(value);
+                    } else {
+                        extObjTypeName_ = value;
+                    }
+                } else {
+                    extObjTypeNameBuilder_.mergeFrom(value);
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder clearExtObjTypeName() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                extObjTypeName_ = null;
+                if (extObjTypeNameBuilder_ != null) {
+                    extObjTypeNameBuilder_.dispose();
+                    extObjTypeNameBuilder_ = null;
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Grpccatalog.ExtObjTypeName.Builder getExtObjTypeNameBuilder() {
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return getExtObjTypeNameFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Grpccatalog.ExtObjTypeNameOrBuilder getExtObjTypeNameOrBuilder() {
+                if (extObjTypeNameBuilder_ != null) {
+                    return extObjTypeNameBuilder_.getMessageOrBuilder();
+                } else {
+                    return extObjTypeName_ == null ?
+                            Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+                }
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExtObjTypeName, Grpccatalog.ExtObjTypeName.Builder, Grpccatalog.ExtObjTypeNameOrBuilder>
+            getExtObjTypeNameFieldBuilder() {
+                if (extObjTypeNameBuilder_ == null) {
+                    extObjTypeNameBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExtObjTypeName, Grpccatalog.ExtObjTypeName.Builder, Grpccatalog.ExtObjTypeNameOrBuilder>(
+                            getExtObjTypeName(),
+                            getParentForChildren(),
+                            isClean());
+                    extObjTypeName_ = null;
+                }
+                return extObjTypeNameBuilder_;
+            }
+
+            private java.util.List<Grpccatalog.FieldDef> fieldDefs_ =
+                    java.util.Collections.emptyList();
+            private void ensureFieldDefsIsMutable() {
+                if (!((bitField0_ & 0x00000002) != 0)) {
+                    fieldDefs_ = new java.util.ArrayList<Grpccatalog.FieldDef>(fieldDefs_);
+                    bitField0_ |= 0x00000002;
+                }
+            }
+
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.FieldDef, Grpccatalog.FieldDef.Builder, Grpccatalog.FieldDefOrBuilder> fieldDefsBuilder_;
+
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public java.util.List<Grpccatalog.FieldDef> getFieldDefsList() {
+                if (fieldDefsBuilder_ == null) {
+                    return java.util.Collections.unmodifiableList(fieldDefs_);
+                } else {
+                    return fieldDefsBuilder_.getMessageList();
+                }
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public int getFieldDefsCount() {
+                if (fieldDefsBuilder_ == null) {
+                    return fieldDefs_.size();
+                } else {
+                    return fieldDefsBuilder_.getCount();
+                }
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Grpccatalog.FieldDef getFieldDefs(int index) {
+                if (fieldDefsBuilder_ == null) {
+                    return fieldDefs_.get(index);
+                } else {
+                    return fieldDefsBuilder_.getMessage(index);
+                }
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder setFieldDefs(
+                    int index, Grpccatalog.FieldDef value) {
+                if (fieldDefsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.set(index, value);
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.setMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder setFieldDefs(
+                    int index, Grpccatalog.FieldDef.Builder builderForValue) {
+                if (fieldDefsBuilder_ == null) {
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.set(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.setMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder addFieldDefs(Grpccatalog.FieldDef value) {
+                if (fieldDefsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.add(value);
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.addMessage(value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder addFieldDefs(
+                    int index, Grpccatalog.FieldDef value) {
+                if (fieldDefsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.add(index, value);
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.addMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder addFieldDefs(
+                    Grpccatalog.FieldDef.Builder builderForValue) {
+                if (fieldDefsBuilder_ == null) {
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.add(builderForValue.build());
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.addMessage(builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder addFieldDefs(
+                    int index, Grpccatalog.FieldDef.Builder builderForValue) {
+                if (fieldDefsBuilder_ == null) {
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.add(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.addMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder addAllFieldDefs(
+                    java.lang.Iterable<? extends Grpccatalog.FieldDef> values) {
+                if (fieldDefsBuilder_ == null) {
+                    ensureFieldDefsIsMutable();
+                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                            values, fieldDefs_);
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.addAllMessages(values);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder clearFieldDefs() {
+                if (fieldDefsBuilder_ == null) {
+                    fieldDefs_ = java.util.Collections.emptyList();
+                    bitField0_ = (bitField0_ & ~0x00000002);
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Builder removeFieldDefs(int index) {
+                if (fieldDefsBuilder_ == null) {
+                    ensureFieldDefsIsMutable();
+                    fieldDefs_.remove(index);
+                    onChanged();
+                } else {
+                    fieldDefsBuilder_.remove(index);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Grpccatalog.FieldDef.Builder getFieldDefsBuilder(
+                    int index) {
+                return getFieldDefsFieldBuilder().getBuilder(index);
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Grpccatalog.FieldDefOrBuilder getFieldDefsOrBuilder(
+                    int index) {
+                if (fieldDefsBuilder_ == null) {
+                    return fieldDefs_.get(index);  } else {
+                    return fieldDefsBuilder_.getMessageOrBuilder(index);
+                }
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public java.util.List<? extends Grpccatalog.FieldDefOrBuilder>
+            getFieldDefsOrBuilderList() {
+                if (fieldDefsBuilder_ != null) {
+                    return fieldDefsBuilder_.getMessageOrBuilderList();
+                } else {
+                    return java.util.Collections.unmodifiableList(fieldDefs_);
+                }
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Grpccatalog.FieldDef.Builder addFieldDefsBuilder() {
+                return getFieldDefsFieldBuilder().addBuilder(
+                        Grpccatalog.FieldDef.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public Grpccatalog.FieldDef.Builder addFieldDefsBuilder(
+                    int index) {
+                return getFieldDefsFieldBuilder().addBuilder(
+                        index, Grpccatalog.FieldDef.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .FieldDef field_defs = 2;</code>
+             */
+            public java.util.List<Grpccatalog.FieldDef.Builder>
+            getFieldDefsBuilderList() {
+                return getFieldDefsFieldBuilder().getBuilderList();
+            }
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.FieldDef, Grpccatalog.FieldDef.Builder, Grpccatalog.FieldDefOrBuilder>
+            getFieldDefsFieldBuilder() {
+                if (fieldDefsBuilder_ == null) {
+                    fieldDefsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
+                            Grpccatalog.FieldDef, Grpccatalog.FieldDef.Builder, Grpccatalog.FieldDefOrBuilder>(
+                            fieldDefs_,
+                            ((bitField0_ & 0x00000002) != 0),
+                            getParentForChildren(),
+                            isClean());
+                    fieldDefs_ = null;
+                }
+                return fieldDefsBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ObjTypeDef)
+        }
+
+        // @@protoc_insertion_point(class_scope:ObjTypeDef)
+        private static final Grpccatalog.ObjTypeDef DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ObjTypeDef();
+        }
+
+        public static Grpccatalog.ObjTypeDef getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ObjTypeDef>
+                PARSER = new com.google.protobuf.AbstractParser<ObjTypeDef>() {
+            @java.lang.Override
+            public ObjTypeDef parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ObjTypeDef> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ObjTypeDef> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ObjTypeDef getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ChildrenOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:Children)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return Whether the extObjTypeName field is set.
+         */
+        boolean hasExtObjTypeName();
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return The extObjTypeName.
+         */
+        Grpccatalog.ExtObjTypeName getExtObjTypeName();
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         */
+        Grpccatalog.ExtObjTypeNameOrBuilder getExtObjTypeNameOrBuilder();
+
+        /**
+         * <code>repeated int64 oids = 2;</code>
+         * @return A list containing the oids.
+         */
+        java.util.List<java.lang.Long> getOidsList();
+        /**
+         * <code>repeated int64 oids = 2;</code>
+         * @return The count of oids.
+         */
+        int getOidsCount();
+        /**
+         * <code>repeated int64 oids = 2;</code>
+         * @param index The index of the element to return.
+         * @return The oids at the given index.
+         */
+        long getOids(int index);
+    }
+    /**
+     * <pre>
+     * Children consists of their extended type name and list of oids.
+     * </pre>
+     *
+     * Protobuf type {@code Children}
+     */
+    public static final class Children extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:Children)
+            ChildrenOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use Children.newBuilder() to construct.
+        private Children(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private Children() {
+            oids_ = emptyLongList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new Children();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_Children_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_Children_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.Children.class, Grpccatalog.Children.Builder.class);
+        }
+
+        public static final int EXT_OBJ_TYPE_NAME_FIELD_NUMBER = 1;
+        private Grpccatalog.ExtObjTypeName extObjTypeName_;
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return Whether the extObjTypeName field is set.
+         */
+        @java.lang.Override
+        public boolean hasExtObjTypeName() {
+            return extObjTypeName_ != null;
+        }
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         * @return The extObjTypeName.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExtObjTypeName getExtObjTypeName() {
+            return extObjTypeName_ == null ? Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+        }
+        /**
+         * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExtObjTypeNameOrBuilder getExtObjTypeNameOrBuilder() {
+            return extObjTypeName_ == null ? Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+        }
+
+        public static final int OIDS_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private com.google.protobuf.Internal.LongList oids_;
+        /**
+         * <code>repeated int64 oids = 2;</code>
+         * @return A list containing the oids.
+         */
+        @java.lang.Override
+        public java.util.List<java.lang.Long>
+        getOidsList() {
+            return oids_;
+        }
+        /**
+         * <code>repeated int64 oids = 2;</code>
+         * @return The count of oids.
+         */
+        public int getOidsCount() {
+            return oids_.size();
+        }
+        /**
+         * <code>repeated int64 oids = 2;</code>
+         * @param index The index of the element to return.
+         * @return The oids at the given index.
+         */
+        public long getOids(int index) {
+            return oids_.getLong(index);
+        }
+        private int oidsMemoizedSerializedSize = -1;
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            getSerializedSize();
+            if (extObjTypeName_ != null) {
+                output.writeMessage(1, getExtObjTypeName());
+            }
+            if (getOidsList().size() > 0) {
+                output.writeUInt32NoTag(18);
+                output.writeUInt32NoTag(oidsMemoizedSerializedSize);
+            }
+            for (int i = 0; i < oids_.size(); i++) {
+                output.writeInt64NoTag(oids_.getLong(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (extObjTypeName_ != null) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(1, getExtObjTypeName());
+            }
+            {
+                int dataSize = 0;
+                for (int i = 0; i < oids_.size(); i++) {
+                    dataSize += com.google.protobuf.CodedOutputStream
+                            .computeInt64SizeNoTag(oids_.getLong(i));
+                }
+                size += dataSize;
+                if (!getOidsList().isEmpty()) {
+                    size += 1;
+                    size += com.google.protobuf.CodedOutputStream
+                            .computeInt32SizeNoTag(dataSize);
+                }
+                oidsMemoizedSerializedSize = dataSize;
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.Children)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.Children other = (Grpccatalog.Children) obj;
+
+            if (hasExtObjTypeName() != other.hasExtObjTypeName()) return false;
+            if (hasExtObjTypeName()) {
+                if (!getExtObjTypeName()
+                        .equals(other.getExtObjTypeName())) return false;
+            }
+            if (!getOidsList()
+                    .equals(other.getOidsList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (hasExtObjTypeName()) {
+                hash = (37 * hash) + EXT_OBJ_TYPE_NAME_FIELD_NUMBER;
+                hash = (53 * hash) + getExtObjTypeName().hashCode();
+            }
+            if (getOidsCount() > 0) {
+                hash = (37 * hash) + OIDS_FIELD_NUMBER;
+                hash = (53 * hash) + getOidsList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.Children parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Children parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Children parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Children parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Children parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Children parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Children parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Children parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Children parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Children parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Children parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Children parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.Children prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Children consists of their extended type name and list of oids.
+         * </pre>
+         *
+         * Protobuf type {@code Children}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:Children)
+                Grpccatalog.ChildrenOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_Children_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_Children_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.Children.class, Grpccatalog.Children.Builder.class);
+            }
+
+            // Construct using Grpccatalog.Children.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                extObjTypeName_ = null;
+                if (extObjTypeNameBuilder_ != null) {
+                    extObjTypeNameBuilder_.dispose();
+                    extObjTypeNameBuilder_ = null;
+                }
+                oids_ = emptyLongList();
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_Children_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Children getDefaultInstanceForType() {
+                return Grpccatalog.Children.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Children build() {
+                Grpccatalog.Children result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Children buildPartial() {
+                Grpccatalog.Children result = new Grpccatalog.Children(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.Children result) {
+                if (((bitField0_ & 0x00000002) != 0)) {
+                    oids_.makeImmutable();
+                    bitField0_ = (bitField0_ & ~0x00000002);
+                }
+                result.oids_ = oids_;
+            }
+
+            private void buildPartial0(Grpccatalog.Children result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.extObjTypeName_ = extObjTypeNameBuilder_ == null
+                            ? extObjTypeName_
+                            : extObjTypeNameBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.Children) {
+                    return mergeFrom((Grpccatalog.Children)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.Children other) {
+                if (other == Grpccatalog.Children.getDefaultInstance()) return this;
+                if (other.hasExtObjTypeName()) {
+                    mergeExtObjTypeName(other.getExtObjTypeName());
+                }
+                if (!other.oids_.isEmpty()) {
+                    if (oids_.isEmpty()) {
+                        oids_ = other.oids_;
+                        bitField0_ = (bitField0_ & ~0x00000002);
+                    } else {
+                        ensureOidsIsMutable();
+                        oids_.addAll(other.oids_);
+                    }
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                input.readMessage(
+                                        getExtObjTypeNameFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            case 16: {
+                                long v = input.readInt64();
+                                ensureOidsIsMutable();
+                                oids_.addLong(v);
+                                break;
+                            } // case 16
+                            case 18: {
+                                int length = input.readRawVarint32();
+                                int limit = input.pushLimit(length);
+                                ensureOidsIsMutable();
+                                while (input.getBytesUntilLimit() > 0) {
+                                    oids_.addLong(input.readInt64());
+                                }
+                                input.popLimit(limit);
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private Grpccatalog.ExtObjTypeName extObjTypeName_;
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExtObjTypeName, Grpccatalog.ExtObjTypeName.Builder, Grpccatalog.ExtObjTypeNameOrBuilder> extObjTypeNameBuilder_;
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             * @return Whether the extObjTypeName field is set.
+             */
+            public boolean hasExtObjTypeName() {
+                return ((bitField0_ & 0x00000001) != 0);
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             * @return The extObjTypeName.
+             */
+            public Grpccatalog.ExtObjTypeName getExtObjTypeName() {
+                if (extObjTypeNameBuilder_ == null) {
+                    return extObjTypeName_ == null ? Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+                } else {
+                    return extObjTypeNameBuilder_.getMessage();
+                }
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder setExtObjTypeName(Grpccatalog.ExtObjTypeName value) {
+                if (extObjTypeNameBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    extObjTypeName_ = value;
+                } else {
+                    extObjTypeNameBuilder_.setMessage(value);
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder setExtObjTypeName(
+                    Grpccatalog.ExtObjTypeName.Builder builderForValue) {
+                if (extObjTypeNameBuilder_ == null) {
+                    extObjTypeName_ = builderForValue.build();
+                } else {
+                    extObjTypeNameBuilder_.setMessage(builderForValue.build());
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder mergeExtObjTypeName(Grpccatalog.ExtObjTypeName value) {
+                if (extObjTypeNameBuilder_ == null) {
+                    if (((bitField0_ & 0x00000001) != 0) &&
+                            extObjTypeName_ != null &&
+                            extObjTypeName_ != Grpccatalog.ExtObjTypeName.getDefaultInstance()) {
+                        getExtObjTypeNameBuilder().mergeFrom(value);
+                    } else {
+                        extObjTypeName_ = value;
+                    }
+                } else {
+                    extObjTypeNameBuilder_.mergeFrom(value);
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Builder clearExtObjTypeName() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                extObjTypeName_ = null;
+                if (extObjTypeNameBuilder_ != null) {
+                    extObjTypeNameBuilder_.dispose();
+                    extObjTypeNameBuilder_ = null;
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Grpccatalog.ExtObjTypeName.Builder getExtObjTypeNameBuilder() {
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return getExtObjTypeNameFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            public Grpccatalog.ExtObjTypeNameOrBuilder getExtObjTypeNameOrBuilder() {
+                if (extObjTypeNameBuilder_ != null) {
+                    return extObjTypeNameBuilder_.getMessageOrBuilder();
+                } else {
+                    return extObjTypeName_ == null ?
+                            Grpccatalog.ExtObjTypeName.getDefaultInstance() : extObjTypeName_;
+                }
+            }
+            /**
+             * <code>.ExtObjTypeName ext_obj_type_name = 1;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExtObjTypeName, Grpccatalog.ExtObjTypeName.Builder, Grpccatalog.ExtObjTypeNameOrBuilder>
+            getExtObjTypeNameFieldBuilder() {
+                if (extObjTypeNameBuilder_ == null) {
+                    extObjTypeNameBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExtObjTypeName, Grpccatalog.ExtObjTypeName.Builder, Grpccatalog.ExtObjTypeNameOrBuilder>(
+                            getExtObjTypeName(),
+                            getParentForChildren(),
+                            isClean());
+                    extObjTypeName_ = null;
+                }
+                return extObjTypeNameBuilder_;
+            }
+
+            private com.google.protobuf.Internal.LongList oids_ = emptyLongList();
+            private void ensureOidsIsMutable() {
+                if (!((bitField0_ & 0x00000002) != 0)) {
+                    oids_ = mutableCopy(oids_);
+                    bitField0_ |= 0x00000002;
+                }
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @return A list containing the oids.
+             */
+            public java.util.List<java.lang.Long>
+            getOidsList() {
+                return ((bitField0_ & 0x00000002) != 0) ?
+                        java.util.Collections.unmodifiableList(oids_) : oids_;
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @return The count of oids.
+             */
+            public int getOidsCount() {
+                return oids_.size();
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @param index The index of the element to return.
+             * @return The oids at the given index.
+             */
+            public long getOids(int index) {
+                return oids_.getLong(index);
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @param index The index to set the value at.
+             * @param value The oids to set.
+             * @return This builder for chaining.
+             */
+            public Builder setOids(
+                    int index, long value) {
+
+                ensureOidsIsMutable();
+                oids_.setLong(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @param value The oids to add.
+             * @return This builder for chaining.
+             */
+            public Builder addOids(long value) {
+
+                ensureOidsIsMutable();
+                oids_.addLong(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @param values The oids to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllOids(
+                    java.lang.Iterable<? extends java.lang.Long> values) {
+                ensureOidsIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, oids_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated int64 oids = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearOids() {
+                oids_ = emptyLongList();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:Children)
+        }
+
+        // @@protoc_insertion_point(class_scope:Children)
+        private static final Grpccatalog.Children DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.Children();
+        }
+
+        public static Grpccatalog.Children getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<Children>
+                PARSER = new com.google.protobuf.AbstractParser<Children>() {
+            @java.lang.Override
+            public Children parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<Children> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<Children> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.Children getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface WriteOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:Write)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.WriteType type = 1;</code>
+         * @return The enum numeric value on the wire for type.
+         */
+        int getTypeValue();
+        /**
+         * <code>.WriteType type = 1;</code>
+         * @return The type.
+         */
+        Grpccatalog.WriteType getType();
+
+        /**
+         * <code>bool is_leaf = 2;</code>
+         * @return The isLeaf.
+         */
+        boolean getIsLeaf();
+
+        /**
+         * <code>bytes write_value = 3;</code>
+         * @return The writeValue.
+         */
+        com.google.protobuf.ByteString getWriteValue();
+
+        /**
+         * <code>optional string trigger = 4;</code>
+         * @return Whether the trigger field is set.
+         */
+        boolean hasTrigger();
+        /**
+         * <code>optional string trigger = 4;</code>
+         * @return The trigger.
+         */
+        java.lang.String getTrigger();
+        /**
+         * <code>optional string trigger = 4;</code>
+         * @return The bytes for trigger.
+         */
+        com.google.protobuf.ByteString
+        getTriggerBytes();
+
+        /**
+         * <code>repeated string args = 5;</code>
+         * @return A list containing the args.
+         */
+        java.util.List<java.lang.String>
+        getArgsList();
+        /**
+         * <code>repeated string args = 5;</code>
+         * @return The count of args.
+         */
+        int getArgsCount();
+        /**
+         * <code>repeated string args = 5;</code>
+         * @param index The index of the element to return.
+         * @return The args at the given index.
+         */
+        java.lang.String getArgs(int index);
+        /**
+         * <code>repeated string args = 5;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the args at the given index.
+         */
+        com.google.protobuf.ByteString
+        getArgsBytes(int index);
+
+        /**
+         * <code>.PathExpr parse_tree = 6;</code>
+         * @return Whether the parseTree field is set.
+         */
+        boolean hasParseTree();
+        /**
+         * <code>.PathExpr parse_tree = 6;</code>
+         * @return The parseTree.
+         */
+        Grpccatalog.PathExpr getParseTree();
+        /**
+         * <code>.PathExpr parse_tree = 6;</code>
+         */
+        Grpccatalog.PathExprOrBuilder getParseTreeOrBuilder();
+
+        /**
+         * <code>string path_str = 7;</code>
+         * @return Whether the pathStr field is set.
+         */
+        boolean hasPathStr();
+        /**
+         * <code>string path_str = 7;</code>
+         * @return The pathStr.
+         */
+        java.lang.String getPathStr();
+        /**
+         * <code>string path_str = 7;</code>
+         * @return The bytes for pathStr.
+         */
+        com.google.protobuf.ByteString
+        getPathStrBytes();
+
+        public Grpccatalog.Write.PathCase getPathCase();
+    }
+    /**
+     * <pre>
+     * When we use OCC for concurrency control, we need to specify the
+     * delta/change of the object, which is change (merge, update) in the object
+     * attributes, addition, or removal of the object. parse tree can be
+     * optionally selected for removal as we still do not have a parser for path
+     * expression...
+     * write_values is the actual delta or value of the object. trigger is a stored
+     * procedure that has to be execute upon writing the object.
+     * TODO: remove parse_tree option after building a parser.
+     * </pre>
+     *
+     * Protobuf type {@code Write}
+     */
+    public static final class Write extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:Write)
+            WriteOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use Write.newBuilder() to construct.
+        private Write(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private Write() {
+            type_ = 0;
+            writeValue_ = com.google.protobuf.ByteString.EMPTY;
+            trigger_ = "";
+            args_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new Write();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_Write_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_Write_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.Write.class, Grpccatalog.Write.Builder.class);
+        }
+
+        private int bitField0_;
+        private int pathCase_ = 0;
+        private java.lang.Object path_;
+        public enum PathCase
+                implements com.google.protobuf.Internal.EnumLite,
+                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
+            PARSE_TREE(6),
+            PATH_STR(7),
+            PATH_NOT_SET(0);
+            private final int value;
+            private PathCase(int value) {
+                this.value = value;
+            }
+            /**
+             * @param value The number of the enum to look for.
+             * @return The enum associated with the given number.
+             * @deprecated Use {@link #forNumber(int)} instead.
+             */
+            @java.lang.Deprecated
+            public static PathCase valueOf(int value) {
+                return forNumber(value);
+            }
+
+            public static PathCase forNumber(int value) {
+                switch (value) {
+                    case 6: return PARSE_TREE;
+                    case 7: return PATH_STR;
+                    case 0: return PATH_NOT_SET;
+                    default: return null;
+                }
+            }
+            public int getNumber() {
+                return this.value;
+            }
+        };
+
+        public PathCase
+        getPathCase() {
+            return PathCase.forNumber(
+                    pathCase_);
+        }
+
+        public static final int TYPE_FIELD_NUMBER = 1;
+        private int type_ = 0;
+        /**
+         * <code>.WriteType type = 1;</code>
+         * @return The enum numeric value on the wire for type.
+         */
+        @java.lang.Override public int getTypeValue() {
+            return type_;
+        }
+        /**
+         * <code>.WriteType type = 1;</code>
+         * @return The type.
+         */
+        @java.lang.Override public Grpccatalog.WriteType getType() {
+            Grpccatalog.WriteType result = Grpccatalog.WriteType.forNumber(type_);
+            return result == null ? Grpccatalog.WriteType.UNRECOGNIZED : result;
+        }
+
+        public static final int IS_LEAF_FIELD_NUMBER = 2;
+        private boolean isLeaf_ = false;
+        /**
+         * <code>bool is_leaf = 2;</code>
+         * @return The isLeaf.
+         */
+        @java.lang.Override
+        public boolean getIsLeaf() {
+            return isLeaf_;
+        }
+
+        public static final int WRITE_VALUE_FIELD_NUMBER = 3;
+        private com.google.protobuf.ByteString writeValue_ = com.google.protobuf.ByteString.EMPTY;
+        /**
+         * <code>bytes write_value = 3;</code>
+         * @return The writeValue.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString getWriteValue() {
+            return writeValue_;
+        }
+
+        public static final int TRIGGER_FIELD_NUMBER = 4;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object trigger_ = "";
+        /**
+         * <code>optional string trigger = 4;</code>
+         * @return Whether the trigger field is set.
+         */
+        @java.lang.Override
+        public boolean hasTrigger() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional string trigger = 4;</code>
+         * @return The trigger.
+         */
+        @java.lang.Override
+        public java.lang.String getTrigger() {
+            java.lang.Object ref = trigger_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                trigger_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>optional string trigger = 4;</code>
+         * @return The bytes for trigger.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getTriggerBytes() {
+            java.lang.Object ref = trigger_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                trigger_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int ARGS_FIELD_NUMBER = 5;
+        @SuppressWarnings("serial")
+        private com.google.protobuf.LazyStringList args_;
+        /**
+         * <code>repeated string args = 5;</code>
+         * @return A list containing the args.
+         */
+        public com.google.protobuf.ProtocolStringList
+        getArgsList() {
+            return args_;
+        }
+        /**
+         * <code>repeated string args = 5;</code>
+         * @return The count of args.
+         */
+        public int getArgsCount() {
+            return args_.size();
+        }
+        /**
+         * <code>repeated string args = 5;</code>
+         * @param index The index of the element to return.
+         * @return The args at the given index.
+         */
+        public java.lang.String getArgs(int index) {
+            return args_.get(index);
+        }
+        /**
+         * <code>repeated string args = 5;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the args at the given index.
+         */
+        public com.google.protobuf.ByteString
+        getArgsBytes(int index) {
+            return args_.getByteString(index);
+        }
+
+        public static final int PARSE_TREE_FIELD_NUMBER = 6;
+        /**
+         * <code>.PathExpr parse_tree = 6;</code>
+         * @return Whether the parseTree field is set.
+         */
+        @java.lang.Override
+        public boolean hasParseTree() {
+            return pathCase_ == 6;
+        }
+        /**
+         * <code>.PathExpr parse_tree = 6;</code>
+         * @return The parseTree.
+         */
+        @java.lang.Override
+        public Grpccatalog.PathExpr getParseTree() {
+            if (pathCase_ == 6) {
+                return (Grpccatalog.PathExpr) path_;
+            }
+            return Grpccatalog.PathExpr.getDefaultInstance();
+        }
+        /**
+         * <code>.PathExpr parse_tree = 6;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.PathExprOrBuilder getParseTreeOrBuilder() {
+            if (pathCase_ == 6) {
+                return (Grpccatalog.PathExpr) path_;
+            }
+            return Grpccatalog.PathExpr.getDefaultInstance();
+        }
+
+        public static final int PATH_STR_FIELD_NUMBER = 7;
+        /**
+         * <code>string path_str = 7;</code>
+         * @return Whether the pathStr field is set.
+         */
+        public boolean hasPathStr() {
+            return pathCase_ == 7;
+        }
+        /**
+         * <code>string path_str = 7;</code>
+         * @return The pathStr.
+         */
+        public java.lang.String getPathStr() {
+            java.lang.Object ref = "";
+            if (pathCase_ == 7) {
+                ref = path_;
+            }
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                if (pathCase_ == 7) {
+                    path_ = s;
+                }
+                return s;
+            }
+        }
+        /**
+         * <code>string path_str = 7;</code>
+         * @return The bytes for pathStr.
+         */
+        public com.google.protobuf.ByteString
+        getPathStrBytes() {
+            java.lang.Object ref = "";
+            if (pathCase_ == 7) {
+                ref = path_;
+            }
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                if (pathCase_ == 7) {
+                    path_ = b;
+                }
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (type_ != Grpccatalog.WriteType.WRITE_TYPE_ADD.getNumber()) {
+                output.writeEnum(1, type_);
+            }
+            if (isLeaf_ != false) {
+                output.writeBool(2, isLeaf_);
+            }
+            if (!writeValue_.isEmpty()) {
+                output.writeBytes(3, writeValue_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 4, trigger_);
+            }
+            for (int i = 0; i < args_.size(); i++) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 5, args_.getRaw(i));
+            }
+            if (pathCase_ == 6) {
+                output.writeMessage(6, (Grpccatalog.PathExpr) path_);
+            }
+            if (pathCase_ == 7) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 7, path_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (type_ != Grpccatalog.WriteType.WRITE_TYPE_ADD.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(1, type_);
+            }
+            if (isLeaf_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(2, isLeaf_);
+            }
+            if (!writeValue_.isEmpty()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBytesSize(3, writeValue_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, trigger_);
+            }
+            {
+                int dataSize = 0;
+                for (int i = 0; i < args_.size(); i++) {
+                    dataSize += computeStringSizeNoTag(args_.getRaw(i));
+                }
+                size += dataSize;
+                size += 1 * getArgsList().size();
+            }
+            if (pathCase_ == 6) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(6, (Grpccatalog.PathExpr) path_);
+            }
+            if (pathCase_ == 7) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, path_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.Write)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.Write other = (Grpccatalog.Write) obj;
+
+            if (type_ != other.type_) return false;
+            if (getIsLeaf()
+                    != other.getIsLeaf()) return false;
+            if (!getWriteValue()
+                    .equals(other.getWriteValue())) return false;
+            if (hasTrigger() != other.hasTrigger()) return false;
+            if (hasTrigger()) {
+                if (!getTrigger()
+                        .equals(other.getTrigger())) return false;
+            }
+            if (!getArgsList()
+                    .equals(other.getArgsList())) return false;
+            if (!getPathCase().equals(other.getPathCase())) return false;
+            switch (pathCase_) {
+                case 6:
+                    if (!getParseTree()
+                            .equals(other.getParseTree())) return false;
+                    break;
+                case 7:
+                    if (!getPathStr()
+                            .equals(other.getPathStr())) return false;
+                    break;
+                case 0:
+                default:
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + TYPE_FIELD_NUMBER;
+            hash = (53 * hash) + type_;
+            hash = (37 * hash) + IS_LEAF_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getIsLeaf());
+            hash = (37 * hash) + WRITE_VALUE_FIELD_NUMBER;
+            hash = (53 * hash) + getWriteValue().hashCode();
+            if (hasTrigger()) {
+                hash = (37 * hash) + TRIGGER_FIELD_NUMBER;
+                hash = (53 * hash) + getTrigger().hashCode();
+            }
+            if (getArgsCount() > 0) {
+                hash = (37 * hash) + ARGS_FIELD_NUMBER;
+                hash = (53 * hash) + getArgsList().hashCode();
+            }
+            switch (pathCase_) {
+                case 6:
+                    hash = (37 * hash) + PARSE_TREE_FIELD_NUMBER;
+                    hash = (53 * hash) + getParseTree().hashCode();
+                    break;
+                case 7:
+                    hash = (37 * hash) + PATH_STR_FIELD_NUMBER;
+                    hash = (53 * hash) + getPathStr().hashCode();
+                    break;
+                case 0:
+                default:
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.Write parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Write parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Write parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Write parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Write parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Write parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Write parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Write parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Write parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Write parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Write parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Write parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.Write prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * When we use OCC for concurrency control, we need to specify the
+         * delta/change of the object, which is change (merge, update) in the object
+         * attributes, addition, or removal of the object. parse tree can be
+         * optionally selected for removal as we still do not have a parser for path
+         * expression...
+         * write_values is the actual delta or value of the object. trigger is a stored
+         * procedure that has to be execute upon writing the object.
+         * TODO: remove parse_tree option after building a parser.
+         * </pre>
+         *
+         * Protobuf type {@code Write}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:Write)
+                Grpccatalog.WriteOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_Write_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_Write_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.Write.class, Grpccatalog.Write.Builder.class);
+            }
+
+            // Construct using Grpccatalog.Write.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                type_ = 0;
+                isLeaf_ = false;
+                writeValue_ = com.google.protobuf.ByteString.EMPTY;
+                trigger_ = "";
+                args_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+                bitField0_ = (bitField0_ & ~0x00000010);
+                if (parseTreeBuilder_ != null) {
+                    parseTreeBuilder_.clear();
+                }
+                pathCase_ = 0;
+                path_ = null;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_Write_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Write getDefaultInstanceForType() {
+                return Grpccatalog.Write.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Write build() {
+                Grpccatalog.Write result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Write buildPartial() {
+                Grpccatalog.Write result = new Grpccatalog.Write(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                buildPartialOneofs(result);
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.Write result) {
+                if (((bitField0_ & 0x00000010) != 0)) {
+                    args_ = args_.getUnmodifiableView();
+                    bitField0_ = (bitField0_ & ~0x00000010);
+                }
+                result.args_ = args_;
+            }
+
+            private void buildPartial0(Grpccatalog.Write result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.type_ = type_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.isLeaf_ = isLeaf_;
+                }
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.writeValue_ = writeValue_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000008) != 0)) {
+                    result.trigger_ = trigger_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            private void buildPartialOneofs(Grpccatalog.Write result) {
+                result.pathCase_ = pathCase_;
+                result.path_ = this.path_;
+                if (pathCase_ == 6 &&
+                        parseTreeBuilder_ != null) {
+                    result.path_ = parseTreeBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.Write) {
+                    return mergeFrom((Grpccatalog.Write)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.Write other) {
+                if (other == Grpccatalog.Write.getDefaultInstance()) return this;
+                if (other.type_ != 0) {
+                    setTypeValue(other.getTypeValue());
+                }
+                if (other.getIsLeaf() != false) {
+                    setIsLeaf(other.getIsLeaf());
+                }
+                if (other.getWriteValue() != com.google.protobuf.ByteString.EMPTY) {
+                    setWriteValue(other.getWriteValue());
+                }
+                if (other.hasTrigger()) {
+                    trigger_ = other.trigger_;
+                    bitField0_ |= 0x00000008;
+                    onChanged();
+                }
+                if (!other.args_.isEmpty()) {
+                    if (args_.isEmpty()) {
+                        args_ = other.args_;
+                        bitField0_ = (bitField0_ & ~0x00000010);
+                    } else {
+                        ensureArgsIsMutable();
+                        args_.addAll(other.args_);
+                    }
+                    onChanged();
+                }
+                switch (other.getPathCase()) {
+                    case PARSE_TREE: {
+                        mergeParseTree(other.getParseTree());
+                        break;
+                    }
+                    case PATH_STR: {
+                        pathCase_ = 7;
+                        path_ = other.path_;
+                        onChanged();
+                        break;
+                    }
+                    case PATH_NOT_SET: {
+                        break;
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                type_ = input.readEnum();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                isLeaf_ = input.readBool();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            case 26: {
+                                writeValue_ = input.readBytes();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 26
+                            case 34: {
+                                trigger_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000008;
+                                break;
+                            } // case 34
+                            case 42: {
+                                java.lang.String s = input.readStringRequireUtf8();
+                                ensureArgsIsMutable();
+                                args_.add(s);
+                                break;
+                            } // case 42
+                            case 50: {
+                                input.readMessage(
+                                        getParseTreeFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                pathCase_ = 6;
+                                break;
+                            } // case 50
+                            case 58: {
+                                java.lang.String s = input.readStringRequireUtf8();
+                                pathCase_ = 7;
+                                path_ = s;
+                                break;
+                            } // case 58
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int pathCase_ = 0;
+            private java.lang.Object path_;
+            public PathCase
+            getPathCase() {
+                return PathCase.forNumber(
+                        pathCase_);
+            }
+
+            public Builder clearPath() {
+                pathCase_ = 0;
+                path_ = null;
+                onChanged();
+                return this;
+            }
+
+            private int bitField0_;
+
+            private int type_ = 0;
+            /**
+             * <code>.WriteType type = 1;</code>
+             * @return The enum numeric value on the wire for type.
+             */
+            @java.lang.Override public int getTypeValue() {
+                return type_;
+            }
+            /**
+             * <code>.WriteType type = 1;</code>
+             * @param value The enum numeric value on the wire for type to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTypeValue(int value) {
+                type_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.WriteType type = 1;</code>
+             * @return The type.
+             */
+            @java.lang.Override
+            public Grpccatalog.WriteType getType() {
+                Grpccatalog.WriteType result = Grpccatalog.WriteType.forNumber(type_);
+                return result == null ? Grpccatalog.WriteType.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.WriteType type = 1;</code>
+             * @param value The type to set.
+             * @return This builder for chaining.
+             */
+            public Builder setType(Grpccatalog.WriteType value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                type_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.WriteType type = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearType() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                type_ = 0;
+                onChanged();
+                return this;
+            }
+
+            private boolean isLeaf_ ;
+            /**
+             * <code>bool is_leaf = 2;</code>
+             * @return The isLeaf.
+             */
+            @java.lang.Override
+            public boolean getIsLeaf() {
+                return isLeaf_;
+            }
+            /**
+             * <code>bool is_leaf = 2;</code>
+             * @param value The isLeaf to set.
+             * @return This builder for chaining.
+             */
+            public Builder setIsLeaf(boolean value) {
+
+                isLeaf_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool is_leaf = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearIsLeaf() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                isLeaf_ = false;
+                onChanged();
+                return this;
+            }
+
+            private com.google.protobuf.ByteString writeValue_ = com.google.protobuf.ByteString.EMPTY;
+            /**
+             * <code>bytes write_value = 3;</code>
+             * @return The writeValue.
+             */
+            @java.lang.Override
+            public com.google.protobuf.ByteString getWriteValue() {
+                return writeValue_;
+            }
+            /**
+             * <code>bytes write_value = 3;</code>
+             * @param value The writeValue to set.
+             * @return This builder for chaining.
+             */
+            public Builder setWriteValue(com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                writeValue_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bytes write_value = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearWriteValue() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                writeValue_ = getDefaultInstance().getWriteValue();
+                onChanged();
+                return this;
+            }
+
+            private java.lang.Object trigger_ = "";
+            /**
+             * <code>optional string trigger = 4;</code>
+             * @return Whether the trigger field is set.
+             */
+            public boolean hasTrigger() {
+                return ((bitField0_ & 0x00000008) != 0);
+            }
+            /**
+             * <code>optional string trigger = 4;</code>
+             * @return The trigger.
+             */
+            public java.lang.String getTrigger() {
+                java.lang.Object ref = trigger_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    trigger_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>optional string trigger = 4;</code>
+             * @return The bytes for trigger.
+             */
+            public com.google.protobuf.ByteString
+            getTriggerBytes() {
+                java.lang.Object ref = trigger_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    trigger_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>optional string trigger = 4;</code>
+             * @param value The trigger to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTrigger(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                trigger_ = value;
+                bitField0_ |= 0x00000008;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional string trigger = 4;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearTrigger() {
+                trigger_ = getDefaultInstance().getTrigger();
+                bitField0_ = (bitField0_ & ~0x00000008);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional string trigger = 4;</code>
+             * @param value The bytes for trigger to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTriggerBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                trigger_ = value;
+                bitField0_ |= 0x00000008;
+                onChanged();
+                return this;
+            }
+
+            private com.google.protobuf.LazyStringList args_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+            private void ensureArgsIsMutable() {
+                if (!((bitField0_ & 0x00000010) != 0)) {
+                    args_ = new com.google.protobuf.LazyStringArrayList(args_);
+                    bitField0_ |= 0x00000010;
+                }
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @return A list containing the args.
+             */
+            public com.google.protobuf.ProtocolStringList
+            getArgsList() {
+                return args_.getUnmodifiableView();
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @return The count of args.
+             */
+            public int getArgsCount() {
+                return args_.size();
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @param index The index of the element to return.
+             * @return The args at the given index.
+             */
+            public java.lang.String getArgs(int index) {
+                return args_.get(index);
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @param index The index of the value to return.
+             * @return The bytes of the args at the given index.
+             */
+            public com.google.protobuf.ByteString
+            getArgsBytes(int index) {
+                return args_.getByteString(index);
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @param index The index to set the value at.
+             * @param value The args to set.
+             * @return This builder for chaining.
+             */
+            public Builder setArgs(
+                    int index, java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureArgsIsMutable();
+                args_.set(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @param value The args to add.
+             * @return This builder for chaining.
+             */
+            public Builder addArgs(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureArgsIsMutable();
+                args_.add(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @param values The args to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllArgs(
+                    java.lang.Iterable<java.lang.String> values) {
+                ensureArgsIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, args_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearArgs() {
+                args_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+                bitField0_ = (bitField0_ & ~0x00000010);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string args = 5;</code>
+             * @param value The bytes of the args to add.
+             * @return This builder for chaining.
+             */
+            public Builder addArgsBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                ensureArgsIsMutable();
+                args_.add(value);
+                onChanged();
+                return this;
+            }
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.PathExpr, Grpccatalog.PathExpr.Builder, Grpccatalog.PathExprOrBuilder> parseTreeBuilder_;
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             * @return Whether the parseTree field is set.
+             */
+            @java.lang.Override
+            public boolean hasParseTree() {
+                return pathCase_ == 6;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             * @return The parseTree.
+             */
+            @java.lang.Override
+            public Grpccatalog.PathExpr getParseTree() {
+                if (parseTreeBuilder_ == null) {
+                    if (pathCase_ == 6) {
+                        return (Grpccatalog.PathExpr) path_;
+                    }
+                    return Grpccatalog.PathExpr.getDefaultInstance();
+                } else {
+                    if (pathCase_ == 6) {
+                        return parseTreeBuilder_.getMessage();
+                    }
+                    return Grpccatalog.PathExpr.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            public Builder setParseTree(Grpccatalog.PathExpr value) {
+                if (parseTreeBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    path_ = value;
+                    onChanged();
+                } else {
+                    parseTreeBuilder_.setMessage(value);
+                }
+                pathCase_ = 6;
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            public Builder setParseTree(
+                    Grpccatalog.PathExpr.Builder builderForValue) {
+                if (parseTreeBuilder_ == null) {
+                    path_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    parseTreeBuilder_.setMessage(builderForValue.build());
+                }
+                pathCase_ = 6;
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            public Builder mergeParseTree(Grpccatalog.PathExpr value) {
+                if (parseTreeBuilder_ == null) {
+                    if (pathCase_ == 6 &&
+                            path_ != Grpccatalog.PathExpr.getDefaultInstance()) {
+                        path_ = Grpccatalog.PathExpr.newBuilder((Grpccatalog.PathExpr) path_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        path_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (pathCase_ == 6) {
+                        parseTreeBuilder_.mergeFrom(value);
+                    } else {
+                        parseTreeBuilder_.setMessage(value);
+                    }
+                }
+                pathCase_ = 6;
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            public Builder clearParseTree() {
+                if (parseTreeBuilder_ == null) {
+                    if (pathCase_ == 6) {
+                        pathCase_ = 0;
+                        path_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (pathCase_ == 6) {
+                        pathCase_ = 0;
+                        path_ = null;
+                    }
+                    parseTreeBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            public Grpccatalog.PathExpr.Builder getParseTreeBuilder() {
+                return getParseTreeFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.PathExprOrBuilder getParseTreeOrBuilder() {
+                if ((pathCase_ == 6) && (parseTreeBuilder_ != null)) {
+                    return parseTreeBuilder_.getMessageOrBuilder();
+                } else {
+                    if (pathCase_ == 6) {
+                        return (Grpccatalog.PathExpr) path_;
+                    }
+                    return Grpccatalog.PathExpr.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.PathExpr parse_tree = 6;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.PathExpr, Grpccatalog.PathExpr.Builder, Grpccatalog.PathExprOrBuilder>
+            getParseTreeFieldBuilder() {
+                if (parseTreeBuilder_ == null) {
+                    if (!(pathCase_ == 6)) {
+                        path_ = Grpccatalog.PathExpr.getDefaultInstance();
+                    }
+                    parseTreeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.PathExpr, Grpccatalog.PathExpr.Builder, Grpccatalog.PathExprOrBuilder>(
+                            (Grpccatalog.PathExpr) path_,
+                            getParentForChildren(),
+                            isClean());
+                    path_ = null;
+                }
+                pathCase_ = 6;
+                onChanged();
+                return parseTreeBuilder_;
+            }
+
+            /**
+             * <code>string path_str = 7;</code>
+             * @return Whether the pathStr field is set.
+             */
+            @java.lang.Override
+            public boolean hasPathStr() {
+                return pathCase_ == 7;
+            }
+            /**
+             * <code>string path_str = 7;</code>
+             * @return The pathStr.
+             */
+            @java.lang.Override
+            public java.lang.String getPathStr() {
+                java.lang.Object ref = "";
+                if (pathCase_ == 7) {
+                    ref = path_;
+                }
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    if (pathCase_ == 7) {
+                        path_ = s;
+                    }
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string path_str = 7;</code>
+             * @return The bytes for pathStr.
+             */
+            @java.lang.Override
+            public com.google.protobuf.ByteString
+            getPathStrBytes() {
+                java.lang.Object ref = "";
+                if (pathCase_ == 7) {
+                    ref = path_;
+                }
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    if (pathCase_ == 7) {
+                        path_ = b;
+                    }
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string path_str = 7;</code>
+             * @param value The pathStr to set.
+             * @return This builder for chaining.
+             */
+            public Builder setPathStr(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                pathCase_ = 7;
+                path_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string path_str = 7;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearPathStr() {
+                if (pathCase_ == 7) {
+                    pathCase_ = 0;
+                    path_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+            /**
+             * <code>string path_str = 7;</code>
+             * @param value The bytes for pathStr to set.
+             * @return This builder for chaining.
+             */
+            public Builder setPathStrBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                pathCase_ = 7;
+                path_ = value;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:Write)
+        }
+
+        // @@protoc_insertion_point(class_scope:Write)
+        private static final Grpccatalog.Write DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.Write();
+        }
+
+        public static Grpccatalog.Write getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<Write>
+                PARSER = new com.google.protobuf.AbstractParser<Write>() {
+            @java.lang.Override
+            public Write parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<Write> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<Write> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.Write getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface PathExprOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:PathExpr)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        java.util.List<Grpccatalog.Predicate>
+        getPredsList();
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        Grpccatalog.Predicate getPreds(int index);
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        int getPredsCount();
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        java.util.List<? extends Grpccatalog.PredicateOrBuilder>
+        getPredsOrBuilderList();
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        Grpccatalog.PredicateOrBuilder getPredsOrBuilder(
+                int index);
+
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @return A list containing the lockModes.
+         */
+        java.util.List<Grpccatalog.LockMode> getLockModesList();
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @return The count of lockModes.
+         */
+        int getLockModesCount();
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @param index The index of the element to return.
+         * @return The lockModes at the given index.
+         */
+        Grpccatalog.LockMode getLockModes(int index);
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @return A list containing the enum numeric values on the wire for lockModes.
+         */
+        java.util.List<java.lang.Integer>
+        getLockModesValueList();
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @param index The index of the value to return.
+         * @return The enum numeric value on the wire of lockModes at the given index.
+         */
+        int getLockModesValue(int index);
+
+        /**
+         * <code>optional .ExprNode optional_pred = 3;</code>
+         * @return Whether the optionalPred field is set.
+         */
+        boolean hasOptionalPred();
+        /**
+         * <code>optional .ExprNode optional_pred = 3;</code>
+         * @return The optionalPred.
+         */
+        Grpccatalog.ExprNode getOptionalPred();
+        /**
+         * <code>optional .ExprNode optional_pred = 3;</code>
+         */
+        Grpccatalog.ExprNodeOrBuilder getOptionalPredOrBuilder();
+    }
+    /**
+     * <pre>
+     * Parse tree representation of the query path expression.
+     * Path experession is a list of predicates, followed by an
+     * optional one. vid is optional and if absent, latest version
+     * is used
+     * </pre>
+     *
+     * Protobuf type {@code PathExpr}
+     */
+    public static final class PathExpr extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:PathExpr)
+            PathExprOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use PathExpr.newBuilder() to construct.
+        private PathExpr(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private PathExpr() {
+            preds_ = java.util.Collections.emptyList();
+            lockModes_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new PathExpr();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_PathExpr_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_PathExpr_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.PathExpr.class, Grpccatalog.PathExpr.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int PREDS_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private java.util.List<Grpccatalog.Predicate> preds_;
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        @java.lang.Override
+        public java.util.List<Grpccatalog.Predicate> getPredsList() {
+            return preds_;
+        }
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        @java.lang.Override
+        public java.util.List<? extends Grpccatalog.PredicateOrBuilder>
+        getPredsOrBuilderList() {
+            return preds_;
+        }
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        @java.lang.Override
+        public int getPredsCount() {
+            return preds_.size();
+        }
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.Predicate getPreds(int index) {
+            return preds_.get(index);
+        }
+        /**
+         * <code>repeated .Predicate preds = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.PredicateOrBuilder getPredsOrBuilder(
+                int index) {
+            return preds_.get(index);
+        }
+
+        public static final int LOCK_MODES_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private java.util.List<java.lang.Integer> lockModes_;
+        private static final com.google.protobuf.Internal.ListAdapter.Converter<
+                java.lang.Integer, Grpccatalog.LockMode> lockModes_converter_ =
+                new com.google.protobuf.Internal.ListAdapter.Converter<
+                        java.lang.Integer, Grpccatalog.LockMode>() {
+                    public Grpccatalog.LockMode convert(java.lang.Integer from) {
+                        Grpccatalog.LockMode result = Grpccatalog.LockMode.forNumber(from);
+                        return result == null ? Grpccatalog.LockMode.UNRECOGNIZED : result;
+                    }
+                };
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @return A list containing the lockModes.
+         */
+        @java.lang.Override
+        public java.util.List<Grpccatalog.LockMode> getLockModesList() {
+            return new com.google.protobuf.Internal.ListAdapter<
+                    java.lang.Integer, Grpccatalog.LockMode>(lockModes_, lockModes_converter_);
+        }
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @return The count of lockModes.
+         */
+        @java.lang.Override
+        public int getLockModesCount() {
+            return lockModes_.size();
+        }
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @param index The index of the element to return.
+         * @return The lockModes at the given index.
+         */
+        @java.lang.Override
+        public Grpccatalog.LockMode getLockModes(int index) {
+            return lockModes_converter_.convert(lockModes_.get(index));
+        }
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @return A list containing the enum numeric values on the wire for lockModes.
+         */
+        @java.lang.Override
+        public java.util.List<java.lang.Integer>
+        getLockModesValueList() {
+            return lockModes_;
+        }
+        /**
+         * <code>repeated .LockMode lock_modes = 2;</code>
+         * @param index The index of the value to return.
+         * @return The enum numeric value on the wire of lockModes at the given index.
+         */
+        @java.lang.Override
+        public int getLockModesValue(int index) {
+            return lockModes_.get(index);
+        }
+        private int lockModesMemoizedSerializedSize;
+
+        public static final int OPTIONAL_PRED_FIELD_NUMBER = 3;
+        private Grpccatalog.ExprNode optionalPred_;
+        /**
+         * <code>optional .ExprNode optional_pred = 3;</code>
+         * @return Whether the optionalPred field is set.
+         */
+        @java.lang.Override
+        public boolean hasOptionalPred() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional .ExprNode optional_pred = 3;</code>
+         * @return The optionalPred.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNode getOptionalPred() {
+            return optionalPred_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : optionalPred_;
+        }
+        /**
+         * <code>optional .ExprNode optional_pred = 3;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNodeOrBuilder getOptionalPredOrBuilder() {
+            return optionalPred_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : optionalPred_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            getSerializedSize();
+            for (int i = 0; i < preds_.size(); i++) {
+                output.writeMessage(1, preds_.get(i));
+            }
+            if (getLockModesList().size() > 0) {
+                output.writeUInt32NoTag(18);
+                output.writeUInt32NoTag(lockModesMemoizedSerializedSize);
+            }
+            for (int i = 0; i < lockModes_.size(); i++) {
+                output.writeEnumNoTag(lockModes_.get(i));
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeMessage(3, getOptionalPred());
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            for (int i = 0; i < preds_.size(); i++) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(1, preds_.get(i));
+            }
+            {
+                int dataSize = 0;
+                for (int i = 0; i < lockModes_.size(); i++) {
+                    dataSize += com.google.protobuf.CodedOutputStream
+                            .computeEnumSizeNoTag(lockModes_.get(i));
+                }
+                size += dataSize;
+                if (!getLockModesList().isEmpty()) {  size += 1;
+                    size += com.google.protobuf.CodedOutputStream
+                            .computeUInt32SizeNoTag(dataSize);
+                }lockModesMemoizedSerializedSize = dataSize;
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(3, getOptionalPred());
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.PathExpr)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.PathExpr other = (Grpccatalog.PathExpr) obj;
+
+            if (!getPredsList()
+                    .equals(other.getPredsList())) return false;
+            if (!lockModes_.equals(other.lockModes_)) return false;
+            if (hasOptionalPred() != other.hasOptionalPred()) return false;
+            if (hasOptionalPred()) {
+                if (!getOptionalPred()
+                        .equals(other.getOptionalPred())) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (getPredsCount() > 0) {
+                hash = (37 * hash) + PREDS_FIELD_NUMBER;
+                hash = (53 * hash) + getPredsList().hashCode();
+            }
+            if (getLockModesCount() > 0) {
+                hash = (37 * hash) + LOCK_MODES_FIELD_NUMBER;
+                hash = (53 * hash) + lockModes_.hashCode();
+            }
+            if (hasOptionalPred()) {
+                hash = (37 * hash) + OPTIONAL_PRED_FIELD_NUMBER;
+                hash = (53 * hash) + getOptionalPred().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.PathExpr parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PathExpr parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PathExpr parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.PathExpr parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PathExpr parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PathExpr parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.PathExpr prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Parse tree representation of the query path expression.
+         * Path experession is a list of predicates, followed by an
+         * optional one. vid is optional and if absent, latest version
+         * is used
+         * </pre>
+         *
+         * Protobuf type {@code PathExpr}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:PathExpr)
+                Grpccatalog.PathExprOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_PathExpr_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_PathExpr_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.PathExpr.class, Grpccatalog.PathExpr.Builder.class);
+            }
+
+            // Construct using Grpccatalog.PathExpr.newBuilder()
+            private Builder() {
+                maybeForceBuilderInitialization();
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+                maybeForceBuilderInitialization();
+            }
+            private void maybeForceBuilderInitialization() {
+                if (com.google.protobuf.GeneratedMessageV3
+                        .alwaysUseFieldBuilders) {
+                    getPredsFieldBuilder();
+                    getOptionalPredFieldBuilder();
+                }
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                if (predsBuilder_ == null) {
+                    preds_ = java.util.Collections.emptyList();
+                } else {
+                    preds_ = null;
+                    predsBuilder_.clear();
+                }
+                bitField0_ = (bitField0_ & ~0x00000001);
+                lockModes_ = java.util.Collections.emptyList();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                optionalPred_ = null;
+                if (optionalPredBuilder_ != null) {
+                    optionalPredBuilder_.dispose();
+                    optionalPredBuilder_ = null;
+                }
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_PathExpr_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PathExpr getDefaultInstanceForType() {
+                return Grpccatalog.PathExpr.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PathExpr build() {
+                Grpccatalog.PathExpr result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PathExpr buildPartial() {
+                Grpccatalog.PathExpr result = new Grpccatalog.PathExpr(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.PathExpr result) {
+                if (predsBuilder_ == null) {
+                    if (((bitField0_ & 0x00000001) != 0)) {
+                        preds_ = java.util.Collections.unmodifiableList(preds_);
+                        bitField0_ = (bitField0_ & ~0x00000001);
+                    }
+                    result.preds_ = preds_;
+                } else {
+                    result.preds_ = predsBuilder_.build();
+                }
+                if (((bitField0_ & 0x00000002) != 0)) {
+                    lockModes_ = java.util.Collections.unmodifiableList(lockModes_);
+                    bitField0_ = (bitField0_ & ~0x00000002);
+                }
+                result.lockModes_ = lockModes_;
+            }
+
+            private void buildPartial0(Grpccatalog.PathExpr result) {
+                int from_bitField0_ = bitField0_;
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.optionalPred_ = optionalPredBuilder_ == null
+                            ? optionalPred_
+                            : optionalPredBuilder_.build();
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.PathExpr) {
+                    return mergeFrom((Grpccatalog.PathExpr)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.PathExpr other) {
+                if (other == Grpccatalog.PathExpr.getDefaultInstance()) return this;
+                if (predsBuilder_ == null) {
+                    if (!other.preds_.isEmpty()) {
+                        if (preds_.isEmpty()) {
+                            preds_ = other.preds_;
+                            bitField0_ = (bitField0_ & ~0x00000001);
+                        } else {
+                            ensurePredsIsMutable();
+                            preds_.addAll(other.preds_);
+                        }
+                        onChanged();
+                    }
+                } else {
+                    if (!other.preds_.isEmpty()) {
+                        if (predsBuilder_.isEmpty()) {
+                            predsBuilder_.dispose();
+                            predsBuilder_ = null;
+                            preds_ = other.preds_;
+                            bitField0_ = (bitField0_ & ~0x00000001);
+                            predsBuilder_ =
+                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
+                                            getPredsFieldBuilder() : null;
+                        } else {
+                            predsBuilder_.addAllMessages(other.preds_);
+                        }
+                    }
+                }
+                if (!other.lockModes_.isEmpty()) {
+                    if (lockModes_.isEmpty()) {
+                        lockModes_ = other.lockModes_;
+                        bitField0_ = (bitField0_ & ~0x00000002);
+                    } else {
+                        ensureLockModesIsMutable();
+                        lockModes_.addAll(other.lockModes_);
+                    }
+                    onChanged();
+                }
+                if (other.hasOptionalPred()) {
+                    mergeOptionalPred(other.getOptionalPred());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                Grpccatalog.Predicate m =
+                                        input.readMessage(
+                                                Grpccatalog.Predicate.parser(),
+                                                extensionRegistry);
+                                if (predsBuilder_ == null) {
+                                    ensurePredsIsMutable();
+                                    preds_.add(m);
+                                } else {
+                                    predsBuilder_.addMessage(m);
+                                }
+                                break;
+                            } // case 10
+                            case 16: {
+                                int tmpRaw = input.readEnum();
+                                ensureLockModesIsMutable();
+                                lockModes_.add(tmpRaw);
+                                break;
+                            } // case 16
+                            case 18: {
+                                int length = input.readRawVarint32();
+                                int oldLimit = input.pushLimit(length);
+                                while(input.getBytesUntilLimit() > 0) {
+                                    int tmpRaw = input.readEnum();
+                                    ensureLockModesIsMutable();
+                                    lockModes_.add(tmpRaw);
+                                }
+                                input.popLimit(oldLimit);
+                                break;
+                            } // case 18
+                            case 26: {
+                                input.readMessage(
+                                        getOptionalPredFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 26
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.util.List<Grpccatalog.Predicate> preds_ =
+                    java.util.Collections.emptyList();
+            private void ensurePredsIsMutable() {
+                if (!((bitField0_ & 0x00000001) != 0)) {
+                    preds_ = new java.util.ArrayList<Grpccatalog.Predicate>(preds_);
+                    bitField0_ |= 0x00000001;
+                }
+            }
+
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.Predicate, Grpccatalog.Predicate.Builder, Grpccatalog.PredicateOrBuilder> predsBuilder_;
+
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public java.util.List<Grpccatalog.Predicate> getPredsList() {
+                if (predsBuilder_ == null) {
+                    return java.util.Collections.unmodifiableList(preds_);
+                } else {
+                    return predsBuilder_.getMessageList();
+                }
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public int getPredsCount() {
+                if (predsBuilder_ == null) {
+                    return preds_.size();
+                } else {
+                    return predsBuilder_.getCount();
+                }
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Grpccatalog.Predicate getPreds(int index) {
+                if (predsBuilder_ == null) {
+                    return preds_.get(index);
+                } else {
+                    return predsBuilder_.getMessage(index);
+                }
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder setPreds(
+                    int index, Grpccatalog.Predicate value) {
+                if (predsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensurePredsIsMutable();
+                    preds_.set(index, value);
+                    onChanged();
+                } else {
+                    predsBuilder_.setMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder setPreds(
+                    int index, Grpccatalog.Predicate.Builder builderForValue) {
+                if (predsBuilder_ == null) {
+                    ensurePredsIsMutable();
+                    preds_.set(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    predsBuilder_.setMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder addPreds(Grpccatalog.Predicate value) {
+                if (predsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensurePredsIsMutable();
+                    preds_.add(value);
+                    onChanged();
+                } else {
+                    predsBuilder_.addMessage(value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder addPreds(
+                    int index, Grpccatalog.Predicate value) {
+                if (predsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensurePredsIsMutable();
+                    preds_.add(index, value);
+                    onChanged();
+                } else {
+                    predsBuilder_.addMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder addPreds(
+                    Grpccatalog.Predicate.Builder builderForValue) {
+                if (predsBuilder_ == null) {
+                    ensurePredsIsMutable();
+                    preds_.add(builderForValue.build());
+                    onChanged();
+                } else {
+                    predsBuilder_.addMessage(builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder addPreds(
+                    int index, Grpccatalog.Predicate.Builder builderForValue) {
+                if (predsBuilder_ == null) {
+                    ensurePredsIsMutable();
+                    preds_.add(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    predsBuilder_.addMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder addAllPreds(
+                    java.lang.Iterable<? extends Grpccatalog.Predicate> values) {
+                if (predsBuilder_ == null) {
+                    ensurePredsIsMutable();
+                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                            values, preds_);
+                    onChanged();
+                } else {
+                    predsBuilder_.addAllMessages(values);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder clearPreds() {
+                if (predsBuilder_ == null) {
+                    preds_ = java.util.Collections.emptyList();
+                    bitField0_ = (bitField0_ & ~0x00000001);
+                    onChanged();
+                } else {
+                    predsBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Builder removePreds(int index) {
+                if (predsBuilder_ == null) {
+                    ensurePredsIsMutable();
+                    preds_.remove(index);
+                    onChanged();
+                } else {
+                    predsBuilder_.remove(index);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Grpccatalog.Predicate.Builder getPredsBuilder(
+                    int index) {
+                return getPredsFieldBuilder().getBuilder(index);
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Grpccatalog.PredicateOrBuilder getPredsOrBuilder(
+                    int index) {
+                if (predsBuilder_ == null) {
+                    return preds_.get(index);  } else {
+                    return predsBuilder_.getMessageOrBuilder(index);
+                }
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public java.util.List<? extends Grpccatalog.PredicateOrBuilder>
+            getPredsOrBuilderList() {
+                if (predsBuilder_ != null) {
+                    return predsBuilder_.getMessageOrBuilderList();
+                } else {
+                    return java.util.Collections.unmodifiableList(preds_);
+                }
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Grpccatalog.Predicate.Builder addPredsBuilder() {
+                return getPredsFieldBuilder().addBuilder(
+                        Grpccatalog.Predicate.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public Grpccatalog.Predicate.Builder addPredsBuilder(
+                    int index) {
+                return getPredsFieldBuilder().addBuilder(
+                        index, Grpccatalog.Predicate.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .Predicate preds = 1;</code>
+             */
+            public java.util.List<Grpccatalog.Predicate.Builder>
+            getPredsBuilderList() {
+                return getPredsFieldBuilder().getBuilderList();
+            }
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.Predicate, Grpccatalog.Predicate.Builder, Grpccatalog.PredicateOrBuilder>
+            getPredsFieldBuilder() {
+                if (predsBuilder_ == null) {
+                    predsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
+                            Grpccatalog.Predicate, Grpccatalog.Predicate.Builder, Grpccatalog.PredicateOrBuilder>(
+                            preds_,
+                            ((bitField0_ & 0x00000001) != 0),
+                            getParentForChildren(),
+                            isClean());
+                    preds_ = null;
+                }
+                return predsBuilder_;
+            }
+
+            private java.util.List<java.lang.Integer> lockModes_ =
+                    java.util.Collections.emptyList();
+            private void ensureLockModesIsMutable() {
+                if (!((bitField0_ & 0x00000002) != 0)) {
+                    lockModes_ = new java.util.ArrayList<java.lang.Integer>(lockModes_);
+                    bitField0_ |= 0x00000002;
+                }
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @return A list containing the lockModes.
+             */
+            public java.util.List<Grpccatalog.LockMode> getLockModesList() {
+                return new com.google.protobuf.Internal.ListAdapter<
+                        java.lang.Integer, Grpccatalog.LockMode>(lockModes_, lockModes_converter_);
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @return The count of lockModes.
+             */
+            public int getLockModesCount() {
+                return lockModes_.size();
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param index The index of the element to return.
+             * @return The lockModes at the given index.
+             */
+            public Grpccatalog.LockMode getLockModes(int index) {
+                return lockModes_converter_.convert(lockModes_.get(index));
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param index The index to set the value at.
+             * @param value The lockModes to set.
+             * @return This builder for chaining.
+             */
+            public Builder setLockModes(
+                    int index, Grpccatalog.LockMode value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                ensureLockModesIsMutable();
+                lockModes_.set(index, value.getNumber());
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param value The lockModes to add.
+             * @return This builder for chaining.
+             */
+            public Builder addLockModes(Grpccatalog.LockMode value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                ensureLockModesIsMutable();
+                lockModes_.add(value.getNumber());
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param values The lockModes to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllLockModes(
+                    java.lang.Iterable<? extends Grpccatalog.LockMode> values) {
+                ensureLockModesIsMutable();
+                for (Grpccatalog.LockMode value : values) {
+                    lockModes_.add(value.getNumber());
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearLockModes() {
+                lockModes_ = java.util.Collections.emptyList();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @return A list containing the enum numeric values on the wire for lockModes.
+             */
+            public java.util.List<java.lang.Integer>
+            getLockModesValueList() {
+                return java.util.Collections.unmodifiableList(lockModes_);
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param index The index of the value to return.
+             * @return The enum numeric value on the wire of lockModes at the given index.
+             */
+            public int getLockModesValue(int index) {
+                return lockModes_.get(index);
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param index The index to set the value at.
+             * @param value The enum numeric value on the wire for lockModes to set.
+             * @return This builder for chaining.
+             */
+            public Builder setLockModesValue(
+                    int index, int value) {
+                ensureLockModesIsMutable();
+                lockModes_.set(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param value The enum numeric value on the wire for lockModes to add.
+             * @return This builder for chaining.
+             */
+            public Builder addLockModesValue(int value) {
+                ensureLockModesIsMutable();
+                lockModes_.add(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated .LockMode lock_modes = 2;</code>
+             * @param values The enum numeric values on the wire for lockModes to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllLockModesValue(
+                    java.lang.Iterable<java.lang.Integer> values) {
+                ensureLockModesIsMutable();
+                for (int value : values) {
+                    lockModes_.add(value);
+                }
+                onChanged();
+                return this;
+            }
+
+            private Grpccatalog.ExprNode optionalPred_;
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder> optionalPredBuilder_;
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             * @return Whether the optionalPred field is set.
+             */
+            public boolean hasOptionalPred() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             * @return The optionalPred.
+             */
+            public Grpccatalog.ExprNode getOptionalPred() {
+                if (optionalPredBuilder_ == null) {
+                    return optionalPred_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : optionalPred_;
+                } else {
+                    return optionalPredBuilder_.getMessage();
+                }
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            public Builder setOptionalPred(Grpccatalog.ExprNode value) {
+                if (optionalPredBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    optionalPred_ = value;
+                } else {
+                    optionalPredBuilder_.setMessage(value);
+                }
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            public Builder setOptionalPred(
+                    Grpccatalog.ExprNode.Builder builderForValue) {
+                if (optionalPredBuilder_ == null) {
+                    optionalPred_ = builderForValue.build();
+                } else {
+                    optionalPredBuilder_.setMessage(builderForValue.build());
+                }
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            public Builder mergeOptionalPred(Grpccatalog.ExprNode value) {
+                if (optionalPredBuilder_ == null) {
+                    if (((bitField0_ & 0x00000004) != 0) &&
+                            optionalPred_ != null &&
+                            optionalPred_ != Grpccatalog.ExprNode.getDefaultInstance()) {
+                        getOptionalPredBuilder().mergeFrom(value);
+                    } else {
+                        optionalPred_ = value;
+                    }
+                } else {
+                    optionalPredBuilder_.mergeFrom(value);
+                }
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            public Builder clearOptionalPred() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                optionalPred_ = null;
+                if (optionalPredBuilder_ != null) {
+                    optionalPredBuilder_.dispose();
+                    optionalPredBuilder_ = null;
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            public Grpccatalog.ExprNode.Builder getOptionalPredBuilder() {
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return getOptionalPredFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            public Grpccatalog.ExprNodeOrBuilder getOptionalPredOrBuilder() {
+                if (optionalPredBuilder_ != null) {
+                    return optionalPredBuilder_.getMessageOrBuilder();
+                } else {
+                    return optionalPred_ == null ?
+                            Grpccatalog.ExprNode.getDefaultInstance() : optionalPred_;
+                }
+            }
+            /**
+             * <code>optional .ExprNode optional_pred = 3;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>
+            getOptionalPredFieldBuilder() {
+                if (optionalPredBuilder_ == null) {
+                    optionalPredBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>(
+                            getOptionalPred(),
+                            getParentForChildren(),
+                            isClean());
+                    optionalPred_ = null;
+                }
+                return optionalPredBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:PathExpr)
+        }
+
+        // @@protoc_insertion_point(class_scope:PathExpr)
+        private static final Grpccatalog.PathExpr DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.PathExpr();
+        }
+
+        public static Grpccatalog.PathExpr getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<PathExpr>
+                PARSER = new com.google.protobuf.AbstractParser<PathExpr>() {
+            @java.lang.Override
+            public PathExpr parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<PathExpr> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<PathExpr> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.PathExpr getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface PredicateOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:Predicate)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExprNode expr_node = 1;</code>
+         * @return Whether the exprNode field is set.
+         */
+        boolean hasExprNode();
+        /**
+         * <code>.ExprNode expr_node = 1;</code>
+         * @return The exprNode.
+         */
+        Grpccatalog.ExprNode getExprNode();
+        /**
+         * <code>.ExprNode expr_node = 1;</code>
+         */
+        Grpccatalog.ExprNodeOrBuilder getExprNodeOrBuilder();
+
+        /**
+         * <code>.Wildcard wildcard = 2;</code>
+         * @return Whether the wildcard field is set.
+         */
+        boolean hasWildcard();
+        /**
+         * <code>.Wildcard wildcard = 2;</code>
+         * @return The enum numeric value on the wire for wildcard.
+         */
+        int getWildcardValue();
+        /**
+         * <code>.Wildcard wildcard = 2;</code>
+         * @return The wildcard.
+         */
+        Grpccatalog.Wildcard getWildcard();
+
+        public Grpccatalog.Predicate.PredCase getPredCase();
+    }
+    /**
+     * <pre>
+     * A predicate is either an expression, oid, or a wildcard.
+     * </pre>
+     *
+     * Protobuf type {@code Predicate}
+     */
+    public static final class Predicate extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:Predicate)
+            PredicateOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use Predicate.newBuilder() to construct.
+        private Predicate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private Predicate() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new Predicate();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_Predicate_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_Predicate_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.Predicate.class, Grpccatalog.Predicate.Builder.class);
+        }
+
+        private int predCase_ = 0;
+        private java.lang.Object pred_;
+        public enum PredCase
+                implements com.google.protobuf.Internal.EnumLite,
+                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
+            EXPR_NODE(1),
+            WILDCARD(2),
+            PRED_NOT_SET(0);
+            private final int value;
+            private PredCase(int value) {
+                this.value = value;
+            }
+            /**
+             * @param value The number of the enum to look for.
+             * @return The enum associated with the given number.
+             * @deprecated Use {@link #forNumber(int)} instead.
+             */
+            @java.lang.Deprecated
+            public static PredCase valueOf(int value) {
+                return forNumber(value);
+            }
+
+            public static PredCase forNumber(int value) {
+                switch (value) {
+                    case 1: return EXPR_NODE;
+                    case 2: return WILDCARD;
+                    case 0: return PRED_NOT_SET;
+                    default: return null;
+                }
+            }
+            public int getNumber() {
+                return this.value;
+            }
+        };
+
+        public PredCase
+        getPredCase() {
+            return PredCase.forNumber(
+                    predCase_);
+        }
+
+        public static final int EXPR_NODE_FIELD_NUMBER = 1;
+        /**
+         * <code>.ExprNode expr_node = 1;</code>
+         * @return Whether the exprNode field is set.
+         */
+        @java.lang.Override
+        public boolean hasExprNode() {
+            return predCase_ == 1;
+        }
+        /**
+         * <code>.ExprNode expr_node = 1;</code>
+         * @return The exprNode.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNode getExprNode() {
+            if (predCase_ == 1) {
+                return (Grpccatalog.ExprNode) pred_;
+            }
+            return Grpccatalog.ExprNode.getDefaultInstance();
+        }
+        /**
+         * <code>.ExprNode expr_node = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNodeOrBuilder getExprNodeOrBuilder() {
+            if (predCase_ == 1) {
+                return (Grpccatalog.ExprNode) pred_;
+            }
+            return Grpccatalog.ExprNode.getDefaultInstance();
+        }
+
+        public static final int WILDCARD_FIELD_NUMBER = 2;
+        /**
+         * <code>.Wildcard wildcard = 2;</code>
+         * @return Whether the wildcard field is set.
+         */
+        public boolean hasWildcard() {
+            return predCase_ == 2;
+        }
+        /**
+         * <code>.Wildcard wildcard = 2;</code>
+         * @return The enum numeric value on the wire for wildcard.
+         */
+        public int getWildcardValue() {
+            if (predCase_ == 2) {
+                return (java.lang.Integer) pred_;
+            }
+            return 0;
+        }
+        /**
+         * <code>.Wildcard wildcard = 2;</code>
+         * @return The wildcard.
+         */
+        public Grpccatalog.Wildcard getWildcard() {
+            if (predCase_ == 2) {
+                Grpccatalog.Wildcard result = Grpccatalog.Wildcard.forNumber(
+                        (java.lang.Integer) pred_);
+                return result == null ? Grpccatalog.Wildcard.UNRECOGNIZED : result;
+            }
+            return Grpccatalog.Wildcard.WILDCARD_ANY;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (predCase_ == 1) {
+                output.writeMessage(1, (Grpccatalog.ExprNode) pred_);
+            }
+            if (predCase_ == 2) {
+                output.writeEnum(2, ((java.lang.Integer) pred_));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (predCase_ == 1) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(1, (Grpccatalog.ExprNode) pred_);
+            }
+            if (predCase_ == 2) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(2, ((java.lang.Integer) pred_));
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.Predicate)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.Predicate other = (Grpccatalog.Predicate) obj;
+
+            if (!getPredCase().equals(other.getPredCase())) return false;
+            switch (predCase_) {
+                case 1:
+                    if (!getExprNode()
+                            .equals(other.getExprNode())) return false;
+                    break;
+                case 2:
+                    if (getWildcardValue()
+                            != other.getWildcardValue()) return false;
+                    break;
+                case 0:
+                default:
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            switch (predCase_) {
+                case 1:
+                    hash = (37 * hash) + EXPR_NODE_FIELD_NUMBER;
+                    hash = (53 * hash) + getExprNode().hashCode();
+                    break;
+                case 2:
+                    hash = (37 * hash) + WILDCARD_FIELD_NUMBER;
+                    hash = (53 * hash) + getWildcardValue();
+                    break;
+                case 0:
+                default:
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.Predicate parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Predicate parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.Predicate parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Predicate parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Predicate parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.Predicate parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.Predicate prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * A predicate is either an expression, oid, or a wildcard.
+         * </pre>
+         *
+         * Protobuf type {@code Predicate}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:Predicate)
+                Grpccatalog.PredicateOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_Predicate_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_Predicate_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.Predicate.class, Grpccatalog.Predicate.Builder.class);
+            }
+
+            // Construct using Grpccatalog.Predicate.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                if (exprNodeBuilder_ != null) {
+                    exprNodeBuilder_.clear();
+                }
+                predCase_ = 0;
+                pred_ = null;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_Predicate_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Predicate getDefaultInstanceForType() {
+                return Grpccatalog.Predicate.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Predicate build() {
+                Grpccatalog.Predicate result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.Predicate buildPartial() {
+                Grpccatalog.Predicate result = new Grpccatalog.Predicate(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                buildPartialOneofs(result);
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.Predicate result) {
+                int from_bitField0_ = bitField0_;
+            }
+
+            private void buildPartialOneofs(Grpccatalog.Predicate result) {
+                result.predCase_ = predCase_;
+                result.pred_ = this.pred_;
+                if (predCase_ == 1 &&
+                        exprNodeBuilder_ != null) {
+                    result.pred_ = exprNodeBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.Predicate) {
+                    return mergeFrom((Grpccatalog.Predicate)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.Predicate other) {
+                if (other == Grpccatalog.Predicate.getDefaultInstance()) return this;
+                switch (other.getPredCase()) {
+                    case EXPR_NODE: {
+                        mergeExprNode(other.getExprNode());
+                        break;
+                    }
+                    case WILDCARD: {
+                        setWildcardValue(other.getWildcardValue());
+                        break;
+                    }
+                    case PRED_NOT_SET: {
+                        break;
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                input.readMessage(
+                                        getExprNodeFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                predCase_ = 1;
+                                break;
+                            } // case 10
+                            case 16: {
+                                int rawValue = input.readEnum();
+                                predCase_ = 2;
+                                pred_ = rawValue;
+                                break;
+                            } // case 16
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int predCase_ = 0;
+            private java.lang.Object pred_;
+            public PredCase
+            getPredCase() {
+                return PredCase.forNumber(
+                        predCase_);
+            }
+
+            public Builder clearPred() {
+                predCase_ = 0;
+                pred_ = null;
+                onChanged();
+                return this;
+            }
+
+            private int bitField0_;
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder> exprNodeBuilder_;
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             * @return Whether the exprNode field is set.
+             */
+            @java.lang.Override
+            public boolean hasExprNode() {
+                return predCase_ == 1;
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             * @return The exprNode.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprNode getExprNode() {
+                if (exprNodeBuilder_ == null) {
+                    if (predCase_ == 1) {
+                        return (Grpccatalog.ExprNode) pred_;
+                    }
+                    return Grpccatalog.ExprNode.getDefaultInstance();
+                } else {
+                    if (predCase_ == 1) {
+                        return exprNodeBuilder_.getMessage();
+                    }
+                    return Grpccatalog.ExprNode.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            public Builder setExprNode(Grpccatalog.ExprNode value) {
+                if (exprNodeBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    pred_ = value;
+                    onChanged();
+                } else {
+                    exprNodeBuilder_.setMessage(value);
+                }
+                predCase_ = 1;
+                return this;
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            public Builder setExprNode(
+                    Grpccatalog.ExprNode.Builder builderForValue) {
+                if (exprNodeBuilder_ == null) {
+                    pred_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    exprNodeBuilder_.setMessage(builderForValue.build());
+                }
+                predCase_ = 1;
+                return this;
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            public Builder mergeExprNode(Grpccatalog.ExprNode value) {
+                if (exprNodeBuilder_ == null) {
+                    if (predCase_ == 1 &&
+                            pred_ != Grpccatalog.ExprNode.getDefaultInstance()) {
+                        pred_ = Grpccatalog.ExprNode.newBuilder((Grpccatalog.ExprNode) pred_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        pred_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (predCase_ == 1) {
+                        exprNodeBuilder_.mergeFrom(value);
+                    } else {
+                        exprNodeBuilder_.setMessage(value);
+                    }
+                }
+                predCase_ = 1;
+                return this;
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            public Builder clearExprNode() {
+                if (exprNodeBuilder_ == null) {
+                    if (predCase_ == 1) {
+                        predCase_ = 0;
+                        pred_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (predCase_ == 1) {
+                        predCase_ = 0;
+                        pred_ = null;
+                    }
+                    exprNodeBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            public Grpccatalog.ExprNode.Builder getExprNodeBuilder() {
+                return getExprNodeFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprNodeOrBuilder getExprNodeOrBuilder() {
+                if ((predCase_ == 1) && (exprNodeBuilder_ != null)) {
+                    return exprNodeBuilder_.getMessageOrBuilder();
+                } else {
+                    if (predCase_ == 1) {
+                        return (Grpccatalog.ExprNode) pred_;
+                    }
+                    return Grpccatalog.ExprNode.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprNode expr_node = 1;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>
+            getExprNodeFieldBuilder() {
+                if (exprNodeBuilder_ == null) {
+                    if (!(predCase_ == 1)) {
+                        pred_ = Grpccatalog.ExprNode.getDefaultInstance();
+                    }
+                    exprNodeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>(
+                            (Grpccatalog.ExprNode) pred_,
+                            getParentForChildren(),
+                            isClean());
+                    pred_ = null;
+                }
+                predCase_ = 1;
+                onChanged();
+                return exprNodeBuilder_;
+            }
+
+            /**
+             * <code>.Wildcard wildcard = 2;</code>
+             * @return Whether the wildcard field is set.
+             */
+            @java.lang.Override
+            public boolean hasWildcard() {
+                return predCase_ == 2;
+            }
+            /**
+             * <code>.Wildcard wildcard = 2;</code>
+             * @return The enum numeric value on the wire for wildcard.
+             */
+            @java.lang.Override
+            public int getWildcardValue() {
+                if (predCase_ == 2) {
+                    return ((java.lang.Integer) pred_).intValue();
+                }
+                return 0;
+            }
+            /**
+             * <code>.Wildcard wildcard = 2;</code>
+             * @param value The enum numeric value on the wire for wildcard to set.
+             * @return This builder for chaining.
+             */
+            public Builder setWildcardValue(int value) {
+                predCase_ = 2;
+                pred_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.Wildcard wildcard = 2;</code>
+             * @return The wildcard.
+             */
+            @java.lang.Override
+            public Grpccatalog.Wildcard getWildcard() {
+                if (predCase_ == 2) {
+                    Grpccatalog.Wildcard result = Grpccatalog.Wildcard.forNumber(
+                            (java.lang.Integer) pred_);
+                    return result == null ? Grpccatalog.Wildcard.UNRECOGNIZED : result;
+                }
+                return Grpccatalog.Wildcard.WILDCARD_ANY;
+            }
+            /**
+             * <code>.Wildcard wildcard = 2;</code>
+             * @param value The wildcard to set.
+             * @return This builder for chaining.
+             */
+            public Builder setWildcard(Grpccatalog.Wildcard value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                predCase_ = 2;
+                pred_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.Wildcard wildcard = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearWildcard() {
+                if (predCase_ == 2) {
+                    predCase_ = 0;
+                    pred_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:Predicate)
+        }
+
+        // @@protoc_insertion_point(class_scope:Predicate)
+        private static final Grpccatalog.Predicate DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.Predicate();
+        }
+
+        public static Grpccatalog.Predicate getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<Predicate>
+                PARSER = new com.google.protobuf.AbstractParser<Predicate>() {
+            @java.lang.Override
+            public Predicate parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<Predicate> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<Predicate> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.Predicate getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExprOpOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExprOp)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExprOpType op_type = 1;</code>
+         * @return The enum numeric value on the wire for opType.
+         */
+        int getOpTypeValue();
+        /**
+         * <code>.ExprOpType op_type = 1;</code>
+         * @return The opType.
+         */
+        Grpccatalog.ExprOpType getOpType();
+
+        /**
+         * <code>.ExprNode right = 2;</code>
+         * @return Whether the right field is set.
+         */
+        boolean hasRight();
+        /**
+         * <code>.ExprNode right = 2;</code>
+         * @return The right.
+         */
+        Grpccatalog.ExprNode getRight();
+        /**
+         * <code>.ExprNode right = 2;</code>
+         */
+        Grpccatalog.ExprNodeOrBuilder getRightOrBuilder();
+
+        /**
+         * <code>optional .ExprNode left = 3;</code>
+         * @return Whether the left field is set.
+         */
+        boolean hasLeft();
+        /**
+         * <code>optional .ExprNode left = 3;</code>
+         * @return The left.
+         */
+        Grpccatalog.ExprNode getLeft();
+        /**
+         * <code>optional .ExprNode left = 3;</code>
+         */
+        Grpccatalog.ExprNodeOrBuilder getLeftOrBuilder();
+    }
+    /**
+     * <pre>
+     * Expression node where the highest level operator is binary/unary.
+     * Left is absent if the operator is unary.
+     * </pre>
+     *
+     * Protobuf type {@code ExprOp}
+     */
+    public static final class ExprOp extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExprOp)
+            ExprOpOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExprOp.newBuilder() to construct.
+        private ExprOp(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExprOp() {
+            opType_ = 0;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExprOp();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExprOp_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExprOp_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExprOp.class, Grpccatalog.ExprOp.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int OP_TYPE_FIELD_NUMBER = 1;
+        private int opType_ = 0;
+        /**
+         * <code>.ExprOpType op_type = 1;</code>
+         * @return The enum numeric value on the wire for opType.
+         */
+        @java.lang.Override public int getOpTypeValue() {
+            return opType_;
+        }
+        /**
+         * <code>.ExprOpType op_type = 1;</code>
+         * @return The opType.
+         */
+        @java.lang.Override public Grpccatalog.ExprOpType getOpType() {
+            Grpccatalog.ExprOpType result = Grpccatalog.ExprOpType.forNumber(opType_);
+            return result == null ? Grpccatalog.ExprOpType.UNRECOGNIZED : result;
+        }
+
+        public static final int RIGHT_FIELD_NUMBER = 2;
+        private Grpccatalog.ExprNode right_;
+        /**
+         * <code>.ExprNode right = 2;</code>
+         * @return Whether the right field is set.
+         */
+        @java.lang.Override
+        public boolean hasRight() {
+            return right_ != null;
+        }
+        /**
+         * <code>.ExprNode right = 2;</code>
+         * @return The right.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNode getRight() {
+            return right_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : right_;
+        }
+        /**
+         * <code>.ExprNode right = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNodeOrBuilder getRightOrBuilder() {
+            return right_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : right_;
+        }
+
+        public static final int LEFT_FIELD_NUMBER = 3;
+        private Grpccatalog.ExprNode left_;
+        /**
+         * <code>optional .ExprNode left = 3;</code>
+         * @return Whether the left field is set.
+         */
+        @java.lang.Override
+        public boolean hasLeft() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional .ExprNode left = 3;</code>
+         * @return The left.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNode getLeft() {
+            return left_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : left_;
+        }
+        /**
+         * <code>optional .ExprNode left = 3;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNodeOrBuilder getLeftOrBuilder() {
+            return left_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : left_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (opType_ != Grpccatalog.ExprOpType.EXPR_OP_TYPE_LESS.getNumber()) {
+                output.writeEnum(1, opType_);
+            }
+            if (right_ != null) {
+                output.writeMessage(2, getRight());
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeMessage(3, getLeft());
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (opType_ != Grpccatalog.ExprOpType.EXPR_OP_TYPE_LESS.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(1, opType_);
+            }
+            if (right_ != null) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(2, getRight());
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(3, getLeft());
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExprOp)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExprOp other = (Grpccatalog.ExprOp) obj;
+
+            if (opType_ != other.opType_) return false;
+            if (hasRight() != other.hasRight()) return false;
+            if (hasRight()) {
+                if (!getRight()
+                        .equals(other.getRight())) return false;
+            }
+            if (hasLeft() != other.hasLeft()) return false;
+            if (hasLeft()) {
+                if (!getLeft()
+                        .equals(other.getLeft())) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + OP_TYPE_FIELD_NUMBER;
+            hash = (53 * hash) + opType_;
+            if (hasRight()) {
+                hash = (37 * hash) + RIGHT_FIELD_NUMBER;
+                hash = (53 * hash) + getRight().hashCode();
+            }
+            if (hasLeft()) {
+                hash = (37 * hash) + LEFT_FIELD_NUMBER;
+                hash = (53 * hash) + getLeft().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExprOp parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprOp parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprOp parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprOp parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprOp parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprOp parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExprOp prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Expression node where the highest level operator is binary/unary.
+         * Left is absent if the operator is unary.
+         * </pre>
+         *
+         * Protobuf type {@code ExprOp}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExprOp)
+                Grpccatalog.ExprOpOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExprOp_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExprOp_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExprOp.class, Grpccatalog.ExprOp.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExprOp.newBuilder()
+            private Builder() {
+                maybeForceBuilderInitialization();
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+                maybeForceBuilderInitialization();
+            }
+            private void maybeForceBuilderInitialization() {
+                if (com.google.protobuf.GeneratedMessageV3
+                        .alwaysUseFieldBuilders) {
+                    getRightFieldBuilder();
+                    getLeftFieldBuilder();
+                }
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                opType_ = 0;
+                right_ = null;
+                if (rightBuilder_ != null) {
+                    rightBuilder_.dispose();
+                    rightBuilder_ = null;
+                }
+                left_ = null;
+                if (leftBuilder_ != null) {
+                    leftBuilder_.dispose();
+                    leftBuilder_ = null;
+                }
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExprOp_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprOp getDefaultInstanceForType() {
+                return Grpccatalog.ExprOp.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprOp build() {
+                Grpccatalog.ExprOp result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprOp buildPartial() {
+                Grpccatalog.ExprOp result = new Grpccatalog.ExprOp(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ExprOp result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.opType_ = opType_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.right_ = rightBuilder_ == null
+                            ? right_
+                            : rightBuilder_.build();
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.left_ = leftBuilder_ == null
+                            ? left_
+                            : leftBuilder_.build();
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExprOp) {
+                    return mergeFrom((Grpccatalog.ExprOp)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExprOp other) {
+                if (other == Grpccatalog.ExprOp.getDefaultInstance()) return this;
+                if (other.opType_ != 0) {
+                    setOpTypeValue(other.getOpTypeValue());
+                }
+                if (other.hasRight()) {
+                    mergeRight(other.getRight());
+                }
+                if (other.hasLeft()) {
+                    mergeLeft(other.getLeft());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                opType_ = input.readEnum();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 18: {
+                                input.readMessage(
+                                        getRightFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 18
+                            case 26: {
+                                input.readMessage(
+                                        getLeftFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 26
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private int opType_ = 0;
+            /**
+             * <code>.ExprOpType op_type = 1;</code>
+             * @return The enum numeric value on the wire for opType.
+             */
+            @java.lang.Override public int getOpTypeValue() {
+                return opType_;
+            }
+            /**
+             * <code>.ExprOpType op_type = 1;</code>
+             * @param value The enum numeric value on the wire for opType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setOpTypeValue(int value) {
+                opType_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprOpType op_type = 1;</code>
+             * @return The opType.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprOpType getOpType() {
+                Grpccatalog.ExprOpType result = Grpccatalog.ExprOpType.forNumber(opType_);
+                return result == null ? Grpccatalog.ExprOpType.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.ExprOpType op_type = 1;</code>
+             * @param value The opType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setOpType(Grpccatalog.ExprOpType value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                opType_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprOpType op_type = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearOpType() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                opType_ = 0;
+                onChanged();
+                return this;
+            }
+
+            private Grpccatalog.ExprNode right_;
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder> rightBuilder_;
+            /**
+             * <code>.ExprNode right = 2;</code>
+             * @return Whether the right field is set.
+             */
+            public boolean hasRight() {
+                return ((bitField0_ & 0x00000002) != 0);
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             * @return The right.
+             */
+            public Grpccatalog.ExprNode getRight() {
+                if (rightBuilder_ == null) {
+                    return right_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : right_;
+                } else {
+                    return rightBuilder_.getMessage();
+                }
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            public Builder setRight(Grpccatalog.ExprNode value) {
+                if (rightBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    right_ = value;
+                } else {
+                    rightBuilder_.setMessage(value);
+                }
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            public Builder setRight(
+                    Grpccatalog.ExprNode.Builder builderForValue) {
+                if (rightBuilder_ == null) {
+                    right_ = builderForValue.build();
+                } else {
+                    rightBuilder_.setMessage(builderForValue.build());
+                }
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            public Builder mergeRight(Grpccatalog.ExprNode value) {
+                if (rightBuilder_ == null) {
+                    if (((bitField0_ & 0x00000002) != 0) &&
+                            right_ != null &&
+                            right_ != Grpccatalog.ExprNode.getDefaultInstance()) {
+                        getRightBuilder().mergeFrom(value);
+                    } else {
+                        right_ = value;
+                    }
+                } else {
+                    rightBuilder_.mergeFrom(value);
+                }
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            public Builder clearRight() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                right_ = null;
+                if (rightBuilder_ != null) {
+                    rightBuilder_.dispose();
+                    rightBuilder_ = null;
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            public Grpccatalog.ExprNode.Builder getRightBuilder() {
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return getRightFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            public Grpccatalog.ExprNodeOrBuilder getRightOrBuilder() {
+                if (rightBuilder_ != null) {
+                    return rightBuilder_.getMessageOrBuilder();
+                } else {
+                    return right_ == null ?
+                            Grpccatalog.ExprNode.getDefaultInstance() : right_;
+                }
+            }
+            /**
+             * <code>.ExprNode right = 2;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>
+            getRightFieldBuilder() {
+                if (rightBuilder_ == null) {
+                    rightBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>(
+                            getRight(),
+                            getParentForChildren(),
+                            isClean());
+                    right_ = null;
+                }
+                return rightBuilder_;
+            }
+
+            private Grpccatalog.ExprNode left_;
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder> leftBuilder_;
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             * @return Whether the left field is set.
+             */
+            public boolean hasLeft() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             * @return The left.
+             */
+            public Grpccatalog.ExprNode getLeft() {
+                if (leftBuilder_ == null) {
+                    return left_ == null ? Grpccatalog.ExprNode.getDefaultInstance() : left_;
+                } else {
+                    return leftBuilder_.getMessage();
+                }
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            public Builder setLeft(Grpccatalog.ExprNode value) {
+                if (leftBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    left_ = value;
+                } else {
+                    leftBuilder_.setMessage(value);
+                }
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            public Builder setLeft(
+                    Grpccatalog.ExprNode.Builder builderForValue) {
+                if (leftBuilder_ == null) {
+                    left_ = builderForValue.build();
+                } else {
+                    leftBuilder_.setMessage(builderForValue.build());
+                }
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            public Builder mergeLeft(Grpccatalog.ExprNode value) {
+                if (leftBuilder_ == null) {
+                    if (((bitField0_ & 0x00000004) != 0) &&
+                            left_ != null &&
+                            left_ != Grpccatalog.ExprNode.getDefaultInstance()) {
+                        getLeftBuilder().mergeFrom(value);
+                    } else {
+                        left_ = value;
+                    }
+                } else {
+                    leftBuilder_.mergeFrom(value);
+                }
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            public Builder clearLeft() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                left_ = null;
+                if (leftBuilder_ != null) {
+                    leftBuilder_.dispose();
+                    leftBuilder_ = null;
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            public Grpccatalog.ExprNode.Builder getLeftBuilder() {
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return getLeftFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            public Grpccatalog.ExprNodeOrBuilder getLeftOrBuilder() {
+                if (leftBuilder_ != null) {
+                    return leftBuilder_.getMessageOrBuilder();
+                } else {
+                    return left_ == null ?
+                            Grpccatalog.ExprNode.getDefaultInstance() : left_;
+                }
+            }
+            /**
+             * <code>optional .ExprNode left = 3;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>
+            getLeftFieldBuilder() {
+                if (leftBuilder_ == null) {
+                    leftBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>(
+                            getLeft(),
+                            getParentForChildren(),
+                            isClean());
+                    left_ = null;
+                }
+                return leftBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExprOp)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExprOp)
+        private static final Grpccatalog.ExprOp DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExprOp();
+        }
+
+        public static Grpccatalog.ExprOp getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExprOp>
+                PARSER = new com.google.protobuf.AbstractParser<ExprOp>() {
+            @java.lang.Override
+            public ExprOp parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExprOp> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExprOp> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExprOp getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExprBoolOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExprBool)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExprBoolType op_type = 1;</code>
+         * @return The enum numeric value on the wire for opType.
+         */
+        int getOpTypeValue();
+        /**
+         * <code>.ExprBoolType op_type = 1;</code>
+         * @return The opType.
+         */
+        Grpccatalog.ExprBoolType getOpType();
+
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        java.util.List<Grpccatalog.ExprNode>
+        getArgsList();
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        Grpccatalog.ExprNode getArgs(int index);
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        int getArgsCount();
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        java.util.List<? extends Grpccatalog.ExprNodeOrBuilder>
+        getArgsOrBuilderList();
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        Grpccatalog.ExprNodeOrBuilder getArgsOrBuilder(
+                int index);
+    }
+    /**
+     * <pre>
+     * Expression node where the highest level operator is a boolean
+     * operator.
+     * </pre>
+     *
+     * Protobuf type {@code ExprBool}
+     */
+    public static final class ExprBool extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExprBool)
+            ExprBoolOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExprBool.newBuilder() to construct.
+        private ExprBool(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExprBool() {
+            opType_ = 0;
+            args_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExprBool();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExprBool_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExprBool_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExprBool.class, Grpccatalog.ExprBool.Builder.class);
+        }
+
+        public static final int OP_TYPE_FIELD_NUMBER = 1;
+        private int opType_ = 0;
+        /**
+         * <code>.ExprBoolType op_type = 1;</code>
+         * @return The enum numeric value on the wire for opType.
+         */
+        @java.lang.Override public int getOpTypeValue() {
+            return opType_;
+        }
+        /**
+         * <code>.ExprBoolType op_type = 1;</code>
+         * @return The opType.
+         */
+        @java.lang.Override public Grpccatalog.ExprBoolType getOpType() {
+            Grpccatalog.ExprBoolType result = Grpccatalog.ExprBoolType.forNumber(opType_);
+            return result == null ? Grpccatalog.ExprBoolType.UNRECOGNIZED : result;
+        }
+
+        public static final int ARGS_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private java.util.List<Grpccatalog.ExprNode> args_;
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<Grpccatalog.ExprNode> getArgsList() {
+            return args_;
+        }
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<? extends Grpccatalog.ExprNodeOrBuilder>
+        getArgsOrBuilderList() {
+            return args_;
+        }
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        @java.lang.Override
+        public int getArgsCount() {
+            return args_.size();
+        }
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNode getArgs(int index) {
+            return args_.get(index);
+        }
+        /**
+         * <code>repeated .ExprNode args = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprNodeOrBuilder getArgsOrBuilder(
+                int index) {
+            return args_.get(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (opType_ != Grpccatalog.ExprBoolType.EXPR_BOOL_TYPE_OR.getNumber()) {
+                output.writeEnum(1, opType_);
+            }
+            for (int i = 0; i < args_.size(); i++) {
+                output.writeMessage(2, args_.get(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (opType_ != Grpccatalog.ExprBoolType.EXPR_BOOL_TYPE_OR.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(1, opType_);
+            }
+            for (int i = 0; i < args_.size(); i++) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(2, args_.get(i));
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExprBool)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExprBool other = (Grpccatalog.ExprBool) obj;
+
+            if (opType_ != other.opType_) return false;
+            if (!getArgsList()
+                    .equals(other.getArgsList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + OP_TYPE_FIELD_NUMBER;
+            hash = (53 * hash) + opType_;
+            if (getArgsCount() > 0) {
+                hash = (37 * hash) + ARGS_FIELD_NUMBER;
+                hash = (53 * hash) + getArgsList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExprBool parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprBool parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprBool parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprBool parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprBool parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprBool parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExprBool prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Expression node where the highest level operator is a boolean
+         * operator.
+         * </pre>
+         *
+         * Protobuf type {@code ExprBool}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExprBool)
+                Grpccatalog.ExprBoolOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExprBool_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExprBool_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExprBool.class, Grpccatalog.ExprBool.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExprBool.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                opType_ = 0;
+                if (argsBuilder_ == null) {
+                    args_ = java.util.Collections.emptyList();
+                } else {
+                    args_ = null;
+                    argsBuilder_.clear();
+                }
+                bitField0_ = (bitField0_ & ~0x00000002);
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExprBool_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprBool getDefaultInstanceForType() {
+                return Grpccatalog.ExprBool.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprBool build() {
+                Grpccatalog.ExprBool result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprBool buildPartial() {
+                Grpccatalog.ExprBool result = new Grpccatalog.ExprBool(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.ExprBool result) {
+                if (argsBuilder_ == null) {
+                    if (((bitField0_ & 0x00000002) != 0)) {
+                        args_ = java.util.Collections.unmodifiableList(args_);
+                        bitField0_ = (bitField0_ & ~0x00000002);
+                    }
+                    result.args_ = args_;
+                } else {
+                    result.args_ = argsBuilder_.build();
+                }
+            }
+
+            private void buildPartial0(Grpccatalog.ExprBool result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.opType_ = opType_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExprBool) {
+                    return mergeFrom((Grpccatalog.ExprBool)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExprBool other) {
+                if (other == Grpccatalog.ExprBool.getDefaultInstance()) return this;
+                if (other.opType_ != 0) {
+                    setOpTypeValue(other.getOpTypeValue());
+                }
+                if (argsBuilder_ == null) {
+                    if (!other.args_.isEmpty()) {
+                        if (args_.isEmpty()) {
+                            args_ = other.args_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                        } else {
+                            ensureArgsIsMutable();
+                            args_.addAll(other.args_);
+                        }
+                        onChanged();
+                    }
+                } else {
+                    if (!other.args_.isEmpty()) {
+                        if (argsBuilder_.isEmpty()) {
+                            argsBuilder_.dispose();
+                            argsBuilder_ = null;
+                            args_ = other.args_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                            argsBuilder_ =
+                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
+                                            getArgsFieldBuilder() : null;
+                        } else {
+                            argsBuilder_.addAllMessages(other.args_);
+                        }
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                opType_ = input.readEnum();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 18: {
+                                Grpccatalog.ExprNode m =
+                                        input.readMessage(
+                                                Grpccatalog.ExprNode.parser(),
+                                                extensionRegistry);
+                                if (argsBuilder_ == null) {
+                                    ensureArgsIsMutable();
+                                    args_.add(m);
+                                } else {
+                                    argsBuilder_.addMessage(m);
+                                }
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private int opType_ = 0;
+            /**
+             * <code>.ExprBoolType op_type = 1;</code>
+             * @return The enum numeric value on the wire for opType.
+             */
+            @java.lang.Override public int getOpTypeValue() {
+                return opType_;
+            }
+            /**
+             * <code>.ExprBoolType op_type = 1;</code>
+             * @param value The enum numeric value on the wire for opType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setOpTypeValue(int value) {
+                opType_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprBoolType op_type = 1;</code>
+             * @return The opType.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprBoolType getOpType() {
+                Grpccatalog.ExprBoolType result = Grpccatalog.ExprBoolType.forNumber(opType_);
+                return result == null ? Grpccatalog.ExprBoolType.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.ExprBoolType op_type = 1;</code>
+             * @param value The opType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setOpType(Grpccatalog.ExprBoolType value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                opType_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprBoolType op_type = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearOpType() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                opType_ = 0;
+                onChanged();
+                return this;
+            }
+
+            private java.util.List<Grpccatalog.ExprNode> args_ =
+                    java.util.Collections.emptyList();
+            private void ensureArgsIsMutable() {
+                if (!((bitField0_ & 0x00000002) != 0)) {
+                    args_ = new java.util.ArrayList<Grpccatalog.ExprNode>(args_);
+                    bitField0_ |= 0x00000002;
+                }
+            }
+
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder> argsBuilder_;
+
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public java.util.List<Grpccatalog.ExprNode> getArgsList() {
+                if (argsBuilder_ == null) {
+                    return java.util.Collections.unmodifiableList(args_);
+                } else {
+                    return argsBuilder_.getMessageList();
+                }
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public int getArgsCount() {
+                if (argsBuilder_ == null) {
+                    return args_.size();
+                } else {
+                    return argsBuilder_.getCount();
+                }
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Grpccatalog.ExprNode getArgs(int index) {
+                if (argsBuilder_ == null) {
+                    return args_.get(index);
+                } else {
+                    return argsBuilder_.getMessage(index);
+                }
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder setArgs(
+                    int index, Grpccatalog.ExprNode value) {
+                if (argsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureArgsIsMutable();
+                    args_.set(index, value);
+                    onChanged();
+                } else {
+                    argsBuilder_.setMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder setArgs(
+                    int index, Grpccatalog.ExprNode.Builder builderForValue) {
+                if (argsBuilder_ == null) {
+                    ensureArgsIsMutable();
+                    args_.set(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    argsBuilder_.setMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder addArgs(Grpccatalog.ExprNode value) {
+                if (argsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureArgsIsMutable();
+                    args_.add(value);
+                    onChanged();
+                } else {
+                    argsBuilder_.addMessage(value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder addArgs(
+                    int index, Grpccatalog.ExprNode value) {
+                if (argsBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureArgsIsMutable();
+                    args_.add(index, value);
+                    onChanged();
+                } else {
+                    argsBuilder_.addMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder addArgs(
+                    Grpccatalog.ExprNode.Builder builderForValue) {
+                if (argsBuilder_ == null) {
+                    ensureArgsIsMutable();
+                    args_.add(builderForValue.build());
+                    onChanged();
+                } else {
+                    argsBuilder_.addMessage(builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder addArgs(
+                    int index, Grpccatalog.ExprNode.Builder builderForValue) {
+                if (argsBuilder_ == null) {
+                    ensureArgsIsMutable();
+                    args_.add(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    argsBuilder_.addMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder addAllArgs(
+                    java.lang.Iterable<? extends Grpccatalog.ExprNode> values) {
+                if (argsBuilder_ == null) {
+                    ensureArgsIsMutable();
+                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                            values, args_);
+                    onChanged();
+                } else {
+                    argsBuilder_.addAllMessages(values);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder clearArgs() {
+                if (argsBuilder_ == null) {
+                    args_ = java.util.Collections.emptyList();
+                    bitField0_ = (bitField0_ & ~0x00000002);
+                    onChanged();
+                } else {
+                    argsBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Builder removeArgs(int index) {
+                if (argsBuilder_ == null) {
+                    ensureArgsIsMutable();
+                    args_.remove(index);
+                    onChanged();
+                } else {
+                    argsBuilder_.remove(index);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Grpccatalog.ExprNode.Builder getArgsBuilder(
+                    int index) {
+                return getArgsFieldBuilder().getBuilder(index);
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Grpccatalog.ExprNodeOrBuilder getArgsOrBuilder(
+                    int index) {
+                if (argsBuilder_ == null) {
+                    return args_.get(index);  } else {
+                    return argsBuilder_.getMessageOrBuilder(index);
+                }
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public java.util.List<? extends Grpccatalog.ExprNodeOrBuilder>
+            getArgsOrBuilderList() {
+                if (argsBuilder_ != null) {
+                    return argsBuilder_.getMessageOrBuilderList();
+                } else {
+                    return java.util.Collections.unmodifiableList(args_);
+                }
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Grpccatalog.ExprNode.Builder addArgsBuilder() {
+                return getArgsFieldBuilder().addBuilder(
+                        Grpccatalog.ExprNode.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public Grpccatalog.ExprNode.Builder addArgsBuilder(
+                    int index) {
+                return getArgsFieldBuilder().addBuilder(
+                        index, Grpccatalog.ExprNode.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .ExprNode args = 2;</code>
+             */
+            public java.util.List<Grpccatalog.ExprNode.Builder>
+            getArgsBuilderList() {
+                return getArgsFieldBuilder().getBuilderList();
+            }
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>
+            getArgsFieldBuilder() {
+                if (argsBuilder_ == null) {
+                    argsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
+                            Grpccatalog.ExprNode, Grpccatalog.ExprNode.Builder, Grpccatalog.ExprNodeOrBuilder>(
+                            args_,
+                            ((bitField0_ & 0x00000002) != 0),
+                            getParentForChildren(),
+                            isClean());
+                    args_ = null;
+                }
+                return argsBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExprBool)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExprBool)
+        private static final Grpccatalog.ExprBool DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExprBool();
+        }
+
+        public static Grpccatalog.ExprBool getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExprBool>
+                PARSER = new com.google.protobuf.AbstractParser<ExprBool>() {
+            @java.lang.Override
+            public ExprBool parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExprBool> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExprBool> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExprBool getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExprConstOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExprConst)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExprConstType const_type = 1;</code>
+         * @return The enum numeric value on the wire for constType.
+         */
+        int getConstTypeValue();
+        /**
+         * <code>.ExprConstType const_type = 1;</code>
+         * @return The constType.
+         */
+        Grpccatalog.ExprConstType getConstType();
+
+        /**
+         * <code>string string_val = 2;</code>
+         * @return Whether the stringVal field is set.
+         */
+        boolean hasStringVal();
+        /**
+         * <code>string string_val = 2;</code>
+         * @return The stringVal.
+         */
+        java.lang.String getStringVal();
+        /**
+         * <code>string string_val = 2;</code>
+         * @return The bytes for stringVal.
+         */
+        com.google.protobuf.ByteString
+        getStringValBytes();
+
+        /**
+         * <code>int32 int32_val = 3;</code>
+         * @return Whether the int32Val field is set.
+         */
+        boolean hasInt32Val();
+        /**
+         * <code>int32 int32_val = 3;</code>
+         * @return The int32Val.
+         */
+        int getInt32Val();
+
+        /**
+         * <code>int64 int64_val = 4;</code>
+         * @return Whether the int64Val field is set.
+         */
+        boolean hasInt64Val();
+        /**
+         * <code>int64 int64_val = 4;</code>
+         * @return The int64Val.
+         */
+        long getInt64Val();
+
+        /**
+         * <code>double double_val = 5;</code>
+         * @return Whether the doubleVal field is set.
+         */
+        boolean hasDoubleVal();
+        /**
+         * <code>double double_val = 5;</code>
+         * @return The doubleVal.
+         */
+        double getDoubleVal();
+
+        /**
+         * <code>bool bool_val = 6;</code>
+         * @return Whether the boolVal field is set.
+         */
+        boolean hasBoolVal();
+        /**
+         * <code>bool bool_val = 6;</code>
+         * @return The boolVal.
+         */
+        boolean getBoolVal();
+
+        public Grpccatalog.ExprConst.ValueCase getValueCase();
+    }
+    /**
+     * <pre>
+     * Expression node that is a constant.
+     * </pre>
+     *
+     * Protobuf type {@code ExprConst}
+     */
+    public static final class ExprConst extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExprConst)
+            ExprConstOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExprConst.newBuilder() to construct.
+        private ExprConst(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExprConst() {
+            constType_ = 0;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExprConst();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExprConst_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExprConst_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExprConst.class, Grpccatalog.ExprConst.Builder.class);
+        }
+
+        private int valueCase_ = 0;
+        private java.lang.Object value_;
+        public enum ValueCase
+                implements com.google.protobuf.Internal.EnumLite,
+                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
+            STRING_VAL(2),
+            INT32_VAL(3),
+            INT64_VAL(4),
+            DOUBLE_VAL(5),
+            BOOL_VAL(6),
+            VALUE_NOT_SET(0);
+            private final int value;
+            private ValueCase(int value) {
+                this.value = value;
+            }
+            /**
+             * @param value The number of the enum to look for.
+             * @return The enum associated with the given number.
+             * @deprecated Use {@link #forNumber(int)} instead.
+             */
+            @java.lang.Deprecated
+            public static ValueCase valueOf(int value) {
+                return forNumber(value);
+            }
+
+            public static ValueCase forNumber(int value) {
+                switch (value) {
+                    case 2: return STRING_VAL;
+                    case 3: return INT32_VAL;
+                    case 4: return INT64_VAL;
+                    case 5: return DOUBLE_VAL;
+                    case 6: return BOOL_VAL;
+                    case 0: return VALUE_NOT_SET;
+                    default: return null;
+                }
+            }
+            public int getNumber() {
+                return this.value;
+            }
+        };
+
+        public ValueCase
+        getValueCase() {
+            return ValueCase.forNumber(
+                    valueCase_);
+        }
+
+        public static final int CONST_TYPE_FIELD_NUMBER = 1;
+        private int constType_ = 0;
+        /**
+         * <code>.ExprConstType const_type = 1;</code>
+         * @return The enum numeric value on the wire for constType.
+         */
+        @java.lang.Override public int getConstTypeValue() {
+            return constType_;
+        }
+        /**
+         * <code>.ExprConstType const_type = 1;</code>
+         * @return The constType.
+         */
+        @java.lang.Override public Grpccatalog.ExprConstType getConstType() {
+            Grpccatalog.ExprConstType result = Grpccatalog.ExprConstType.forNumber(constType_);
+            return result == null ? Grpccatalog.ExprConstType.UNRECOGNIZED : result;
+        }
+
+        public static final int STRING_VAL_FIELD_NUMBER = 2;
+        /**
+         * <code>string string_val = 2;</code>
+         * @return Whether the stringVal field is set.
+         */
+        public boolean hasStringVal() {
+            return valueCase_ == 2;
+        }
+        /**
+         * <code>string string_val = 2;</code>
+         * @return The stringVal.
+         */
+        public java.lang.String getStringVal() {
+            java.lang.Object ref = "";
+            if (valueCase_ == 2) {
+                ref = value_;
+            }
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                if (valueCase_ == 2) {
+                    value_ = s;
+                }
+                return s;
+            }
+        }
+        /**
+         * <code>string string_val = 2;</code>
+         * @return The bytes for stringVal.
+         */
+        public com.google.protobuf.ByteString
+        getStringValBytes() {
+            java.lang.Object ref = "";
+            if (valueCase_ == 2) {
+                ref = value_;
+            }
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                if (valueCase_ == 2) {
+                    value_ = b;
+                }
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int INT32_VAL_FIELD_NUMBER = 3;
+        /**
+         * <code>int32 int32_val = 3;</code>
+         * @return Whether the int32Val field is set.
+         */
+        @java.lang.Override
+        public boolean hasInt32Val() {
+            return valueCase_ == 3;
+        }
+        /**
+         * <code>int32 int32_val = 3;</code>
+         * @return The int32Val.
+         */
+        @java.lang.Override
+        public int getInt32Val() {
+            if (valueCase_ == 3) {
+                return (java.lang.Integer) value_;
+            }
+            return 0;
+        }
+
+        public static final int INT64_VAL_FIELD_NUMBER = 4;
+        /**
+         * <code>int64 int64_val = 4;</code>
+         * @return Whether the int64Val field is set.
+         */
+        @java.lang.Override
+        public boolean hasInt64Val() {
+            return valueCase_ == 4;
+        }
+        /**
+         * <code>int64 int64_val = 4;</code>
+         * @return The int64Val.
+         */
+        @java.lang.Override
+        public long getInt64Val() {
+            if (valueCase_ == 4) {
+                return (java.lang.Long) value_;
+            }
+            return 0L;
+        }
+
+        public static final int DOUBLE_VAL_FIELD_NUMBER = 5;
+        /**
+         * <code>double double_val = 5;</code>
+         * @return Whether the doubleVal field is set.
+         */
+        @java.lang.Override
+        public boolean hasDoubleVal() {
+            return valueCase_ == 5;
+        }
+        /**
+         * <code>double double_val = 5;</code>
+         * @return The doubleVal.
+         */
+        @java.lang.Override
+        public double getDoubleVal() {
+            if (valueCase_ == 5) {
+                return (java.lang.Double) value_;
+            }
+            return 0D;
+        }
+
+        public static final int BOOL_VAL_FIELD_NUMBER = 6;
+        /**
+         * <code>bool bool_val = 6;</code>
+         * @return Whether the boolVal field is set.
+         */
+        @java.lang.Override
+        public boolean hasBoolVal() {
+            return valueCase_ == 6;
+        }
+        /**
+         * <code>bool bool_val = 6;</code>
+         * @return The boolVal.
+         */
+        @java.lang.Override
+        public boolean getBoolVal() {
+            if (valueCase_ == 6) {
+                return (java.lang.Boolean) value_;
+            }
+            return false;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (constType_ != Grpccatalog.ExprConstType.EXPR_CONST_TYPE_STRING.getNumber()) {
+                output.writeEnum(1, constType_);
+            }
+            if (valueCase_ == 2) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
+            }
+            if (valueCase_ == 3) {
+                output.writeInt32(
+                        3, (int)((java.lang.Integer) value_));
+            }
+            if (valueCase_ == 4) {
+                output.writeInt64(
+                        4, (long)((java.lang.Long) value_));
+            }
+            if (valueCase_ == 5) {
+                output.writeDouble(
+                        5, (double)((java.lang.Double) value_));
+            }
+            if (valueCase_ == 6) {
+                output.writeBool(
+                        6, (boolean)((java.lang.Boolean) value_));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (constType_ != Grpccatalog.ExprConstType.EXPR_CONST_TYPE_STRING.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(1, constType_);
+            }
+            if (valueCase_ == 2) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
+            }
+            if (valueCase_ == 3) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeInt32Size(
+                                3, (int)((java.lang.Integer) value_));
+            }
+            if (valueCase_ == 4) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeInt64Size(
+                                4, (long)((java.lang.Long) value_));
+            }
+            if (valueCase_ == 5) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeDoubleSize(
+                                5, (double)((java.lang.Double) value_));
+            }
+            if (valueCase_ == 6) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(
+                                6, (boolean)((java.lang.Boolean) value_));
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExprConst)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExprConst other = (Grpccatalog.ExprConst) obj;
+
+            if (constType_ != other.constType_) return false;
+            if (!getValueCase().equals(other.getValueCase())) return false;
+            switch (valueCase_) {
+                case 2:
+                    if (!getStringVal()
+                            .equals(other.getStringVal())) return false;
+                    break;
+                case 3:
+                    if (getInt32Val()
+                            != other.getInt32Val()) return false;
+                    break;
+                case 4:
+                    if (getInt64Val()
+                            != other.getInt64Val()) return false;
+                    break;
+                case 5:
+                    if (java.lang.Double.doubleToLongBits(getDoubleVal())
+                            != java.lang.Double.doubleToLongBits(
+                            other.getDoubleVal())) return false;
+                    break;
+                case 6:
+                    if (getBoolVal()
+                            != other.getBoolVal()) return false;
+                    break;
+                case 0:
+                default:
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + CONST_TYPE_FIELD_NUMBER;
+            hash = (53 * hash) + constType_;
+            switch (valueCase_) {
+                case 2:
+                    hash = (37 * hash) + STRING_VAL_FIELD_NUMBER;
+                    hash = (53 * hash) + getStringVal().hashCode();
+                    break;
+                case 3:
+                    hash = (37 * hash) + INT32_VAL_FIELD_NUMBER;
+                    hash = (53 * hash) + getInt32Val();
+                    break;
+                case 4:
+                    hash = (37 * hash) + INT64_VAL_FIELD_NUMBER;
+                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                            getInt64Val());
+                    break;
+                case 5:
+                    hash = (37 * hash) + DOUBLE_VAL_FIELD_NUMBER;
+                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                            java.lang.Double.doubleToLongBits(getDoubleVal()));
+                    break;
+                case 6:
+                    hash = (37 * hash) + BOOL_VAL_FIELD_NUMBER;
+                    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                            getBoolVal());
+                    break;
+                case 0:
+                default:
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExprConst parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprConst parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprConst parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprConst parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprConst parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprConst parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExprConst prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Expression node that is a constant.
+         * </pre>
+         *
+         * Protobuf type {@code ExprConst}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExprConst)
+                Grpccatalog.ExprConstOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExprConst_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExprConst_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExprConst.class, Grpccatalog.ExprConst.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExprConst.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                constType_ = 0;
+                valueCase_ = 0;
+                value_ = null;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExprConst_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprConst getDefaultInstanceForType() {
+                return Grpccatalog.ExprConst.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprConst build() {
+                Grpccatalog.ExprConst result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprConst buildPartial() {
+                Grpccatalog.ExprConst result = new Grpccatalog.ExprConst(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                buildPartialOneofs(result);
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ExprConst result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.constType_ = constType_;
+                }
+            }
+
+            private void buildPartialOneofs(Grpccatalog.ExprConst result) {
+                result.valueCase_ = valueCase_;
+                result.value_ = this.value_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExprConst) {
+                    return mergeFrom((Grpccatalog.ExprConst)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExprConst other) {
+                if (other == Grpccatalog.ExprConst.getDefaultInstance()) return this;
+                if (other.constType_ != 0) {
+                    setConstTypeValue(other.getConstTypeValue());
+                }
+                switch (other.getValueCase()) {
+                    case STRING_VAL: {
+                        valueCase_ = 2;
+                        value_ = other.value_;
+                        onChanged();
+                        break;
+                    }
+                    case INT32_VAL: {
+                        setInt32Val(other.getInt32Val());
+                        break;
+                    }
+                    case INT64_VAL: {
+                        setInt64Val(other.getInt64Val());
+                        break;
+                    }
+                    case DOUBLE_VAL: {
+                        setDoubleVal(other.getDoubleVal());
+                        break;
+                    }
+                    case BOOL_VAL: {
+                        setBoolVal(other.getBoolVal());
+                        break;
+                    }
+                    case VALUE_NOT_SET: {
+                        break;
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                constType_ = input.readEnum();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 18: {
+                                java.lang.String s = input.readStringRequireUtf8();
+                                valueCase_ = 2;
+                                value_ = s;
+                                break;
+                            } // case 18
+                            case 24: {
+                                value_ = input.readInt32();
+                                valueCase_ = 3;
+                                break;
+                            } // case 24
+                            case 32: {
+                                value_ = input.readInt64();
+                                valueCase_ = 4;
+                                break;
+                            } // case 32
+                            case 41: {
+                                value_ = input.readDouble();
+                                valueCase_ = 5;
+                                break;
+                            } // case 41
+                            case 48: {
+                                value_ = input.readBool();
+                                valueCase_ = 6;
+                                break;
+                            } // case 48
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int valueCase_ = 0;
+            private java.lang.Object value_;
+            public ValueCase
+            getValueCase() {
+                return ValueCase.forNumber(
+                        valueCase_);
+            }
+
+            public Builder clearValue() {
+                valueCase_ = 0;
+                value_ = null;
+                onChanged();
+                return this;
+            }
+
+            private int bitField0_;
+
+            private int constType_ = 0;
+            /**
+             * <code>.ExprConstType const_type = 1;</code>
+             * @return The enum numeric value on the wire for constType.
+             */
+            @java.lang.Override public int getConstTypeValue() {
+                return constType_;
+            }
+            /**
+             * <code>.ExprConstType const_type = 1;</code>
+             * @param value The enum numeric value on the wire for constType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setConstTypeValue(int value) {
+                constType_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprConstType const_type = 1;</code>
+             * @return The constType.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprConstType getConstType() {
+                Grpccatalog.ExprConstType result = Grpccatalog.ExprConstType.forNumber(constType_);
+                return result == null ? Grpccatalog.ExprConstType.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.ExprConstType const_type = 1;</code>
+             * @param value The constType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setConstType(Grpccatalog.ExprConstType value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                constType_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ExprConstType const_type = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearConstType() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                constType_ = 0;
+                onChanged();
+                return this;
+            }
+
+            /**
+             * <code>string string_val = 2;</code>
+             * @return Whether the stringVal field is set.
+             */
+            @java.lang.Override
+            public boolean hasStringVal() {
+                return valueCase_ == 2;
+            }
+            /**
+             * <code>string string_val = 2;</code>
+             * @return The stringVal.
+             */
+            @java.lang.Override
+            public java.lang.String getStringVal() {
+                java.lang.Object ref = "";
+                if (valueCase_ == 2) {
+                    ref = value_;
+                }
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    if (valueCase_ == 2) {
+                        value_ = s;
+                    }
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string string_val = 2;</code>
+             * @return The bytes for stringVal.
+             */
+            @java.lang.Override
+            public com.google.protobuf.ByteString
+            getStringValBytes() {
+                java.lang.Object ref = "";
+                if (valueCase_ == 2) {
+                    ref = value_;
+                }
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    if (valueCase_ == 2) {
+                        value_ = b;
+                    }
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string string_val = 2;</code>
+             * @param value The stringVal to set.
+             * @return This builder for chaining.
+             */
+            public Builder setStringVal(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                valueCase_ = 2;
+                value_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string string_val = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearStringVal() {
+                if (valueCase_ == 2) {
+                    valueCase_ = 0;
+                    value_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+            /**
+             * <code>string string_val = 2;</code>
+             * @param value The bytes for stringVal to set.
+             * @return This builder for chaining.
+             */
+            public Builder setStringValBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                valueCase_ = 2;
+                value_ = value;
+                onChanged();
+                return this;
+            }
+
+            /**
+             * <code>int32 int32_val = 3;</code>
+             * @return Whether the int32Val field is set.
+             */
+            public boolean hasInt32Val() {
+                return valueCase_ == 3;
+            }
+            /**
+             * <code>int32 int32_val = 3;</code>
+             * @return The int32Val.
+             */
+            public int getInt32Val() {
+                if (valueCase_ == 3) {
+                    return (java.lang.Integer) value_;
+                }
+                return 0;
+            }
+            /**
+             * <code>int32 int32_val = 3;</code>
+             * @param value The int32Val to set.
+             * @return This builder for chaining.
+             */
+            public Builder setInt32Val(int value) {
+
+                valueCase_ = 3;
+                value_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>int32 int32_val = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearInt32Val() {
+                if (valueCase_ == 3) {
+                    valueCase_ = 0;
+                    value_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+
+            /**
+             * <code>int64 int64_val = 4;</code>
+             * @return Whether the int64Val field is set.
+             */
+            public boolean hasInt64Val() {
+                return valueCase_ == 4;
+            }
+            /**
+             * <code>int64 int64_val = 4;</code>
+             * @return The int64Val.
+             */
+            public long getInt64Val() {
+                if (valueCase_ == 4) {
+                    return (java.lang.Long) value_;
+                }
+                return 0L;
+            }
+            /**
+             * <code>int64 int64_val = 4;</code>
+             * @param value The int64Val to set.
+             * @return This builder for chaining.
+             */
+            public Builder setInt64Val(long value) {
+
+                valueCase_ = 4;
+                value_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>int64 int64_val = 4;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearInt64Val() {
+                if (valueCase_ == 4) {
+                    valueCase_ = 0;
+                    value_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+
+            /**
+             * <code>double double_val = 5;</code>
+             * @return Whether the doubleVal field is set.
+             */
+            public boolean hasDoubleVal() {
+                return valueCase_ == 5;
+            }
+            /**
+             * <code>double double_val = 5;</code>
+             * @return The doubleVal.
+             */
+            public double getDoubleVal() {
+                if (valueCase_ == 5) {
+                    return (java.lang.Double) value_;
+                }
+                return 0D;
+            }
+            /**
+             * <code>double double_val = 5;</code>
+             * @param value The doubleVal to set.
+             * @return This builder for chaining.
+             */
+            public Builder setDoubleVal(double value) {
+
+                valueCase_ = 5;
+                value_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>double double_val = 5;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearDoubleVal() {
+                if (valueCase_ == 5) {
+                    valueCase_ = 0;
+                    value_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+
+            /**
+             * <code>bool bool_val = 6;</code>
+             * @return Whether the boolVal field is set.
+             */
+            public boolean hasBoolVal() {
+                return valueCase_ == 6;
+            }
+            /**
+             * <code>bool bool_val = 6;</code>
+             * @return The boolVal.
+             */
+            public boolean getBoolVal() {
+                if (valueCase_ == 6) {
+                    return (java.lang.Boolean) value_;
+                }
+                return false;
+            }
+            /**
+             * <code>bool bool_val = 6;</code>
+             * @param value The boolVal to set.
+             * @return This builder for chaining.
+             */
+            public Builder setBoolVal(boolean value) {
+
+                valueCase_ = 6;
+                value_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool bool_val = 6;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearBoolVal() {
+                if (valueCase_ == 6) {
+                    valueCase_ = 0;
+                    value_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExprConst)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExprConst)
+        private static final Grpccatalog.ExprConst DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExprConst();
+        }
+
+        public static Grpccatalog.ExprConst getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExprConst>
+                PARSER = new com.google.protobuf.AbstractParser<ExprConst>() {
+            @java.lang.Override
+            public ExprConst parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExprConst> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExprConst> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExprConst getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExprFieldRefOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExprFieldRef)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @return A list containing the fieldRefs.
+         */
+        java.util.List<java.lang.String>
+        getFieldRefsList();
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @return The count of fieldRefs.
+         */
+        int getFieldRefsCount();
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @param index The index of the element to return.
+         * @return The fieldRefs at the given index.
+         */
+        java.lang.String getFieldRefs(int index);
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the fieldRefs at the given index.
+         */
+        com.google.protobuf.ByteString
+        getFieldRefsBytes(int index);
+    }
+    /**
+     * <pre>
+     * Expression node that is a field reference.
+     * </pre>
+     *
+     * Protobuf type {@code ExprFieldRef}
+     */
+    public static final class ExprFieldRef extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExprFieldRef)
+            ExprFieldRefOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExprFieldRef.newBuilder() to construct.
+        private ExprFieldRef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExprFieldRef() {
+            fieldRefs_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExprFieldRef();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExprFieldRef_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExprFieldRef_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExprFieldRef.class, Grpccatalog.ExprFieldRef.Builder.class);
+        }
+
+        public static final int FIELD_REFS_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private com.google.protobuf.LazyStringList fieldRefs_;
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @return A list containing the fieldRefs.
+         */
+        public com.google.protobuf.ProtocolStringList
+        getFieldRefsList() {
+            return fieldRefs_;
+        }
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @return The count of fieldRefs.
+         */
+        public int getFieldRefsCount() {
+            return fieldRefs_.size();
+        }
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @param index The index of the element to return.
+         * @return The fieldRefs at the given index.
+         */
+        public java.lang.String getFieldRefs(int index) {
+            return fieldRefs_.get(index);
+        }
+        /**
+         * <code>repeated string field_refs = 1;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the fieldRefs at the given index.
+         */
+        public com.google.protobuf.ByteString
+        getFieldRefsBytes(int index) {
+            return fieldRefs_.getByteString(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            for (int i = 0; i < fieldRefs_.size(); i++) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, fieldRefs_.getRaw(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            {
+                int dataSize = 0;
+                for (int i = 0; i < fieldRefs_.size(); i++) {
+                    dataSize += computeStringSizeNoTag(fieldRefs_.getRaw(i));
+                }
+                size += dataSize;
+                size += 1 * getFieldRefsList().size();
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExprFieldRef)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExprFieldRef other = (Grpccatalog.ExprFieldRef) obj;
+
+            if (!getFieldRefsList()
+                    .equals(other.getFieldRefsList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (getFieldRefsCount() > 0) {
+                hash = (37 * hash) + FIELD_REFS_FIELD_NUMBER;
+                hash = (53 * hash) + getFieldRefsList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprFieldRef parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprFieldRef parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprFieldRef parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExprFieldRef prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Expression node that is a field reference.
+         * </pre>
+         *
+         * Protobuf type {@code ExprFieldRef}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExprFieldRef)
+                Grpccatalog.ExprFieldRefOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExprFieldRef_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExprFieldRef_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExprFieldRef.class, Grpccatalog.ExprFieldRef.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExprFieldRef.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                fieldRefs_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+                bitField0_ = (bitField0_ & ~0x00000001);
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExprFieldRef_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprFieldRef getDefaultInstanceForType() {
+                return Grpccatalog.ExprFieldRef.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprFieldRef build() {
+                Grpccatalog.ExprFieldRef result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprFieldRef buildPartial() {
+                Grpccatalog.ExprFieldRef result = new Grpccatalog.ExprFieldRef(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.ExprFieldRef result) {
+                if (((bitField0_ & 0x00000001) != 0)) {
+                    fieldRefs_ = fieldRefs_.getUnmodifiableView();
+                    bitField0_ = (bitField0_ & ~0x00000001);
+                }
+                result.fieldRefs_ = fieldRefs_;
+            }
+
+            private void buildPartial0(Grpccatalog.ExprFieldRef result) {
+                int from_bitField0_ = bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExprFieldRef) {
+                    return mergeFrom((Grpccatalog.ExprFieldRef)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExprFieldRef other) {
+                if (other == Grpccatalog.ExprFieldRef.getDefaultInstance()) return this;
+                if (!other.fieldRefs_.isEmpty()) {
+                    if (fieldRefs_.isEmpty()) {
+                        fieldRefs_ = other.fieldRefs_;
+                        bitField0_ = (bitField0_ & ~0x00000001);
+                    } else {
+                        ensureFieldRefsIsMutable();
+                        fieldRefs_.addAll(other.fieldRefs_);
+                    }
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                java.lang.String s = input.readStringRequireUtf8();
+                                ensureFieldRefsIsMutable();
+                                fieldRefs_.add(s);
+                                break;
+                            } // case 10
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private com.google.protobuf.LazyStringList fieldRefs_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+            private void ensureFieldRefsIsMutable() {
+                if (!((bitField0_ & 0x00000001) != 0)) {
+                    fieldRefs_ = new com.google.protobuf.LazyStringArrayList(fieldRefs_);
+                    bitField0_ |= 0x00000001;
+                }
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @return A list containing the fieldRefs.
+             */
+            public com.google.protobuf.ProtocolStringList
+            getFieldRefsList() {
+                return fieldRefs_.getUnmodifiableView();
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @return The count of fieldRefs.
+             */
+            public int getFieldRefsCount() {
+                return fieldRefs_.size();
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @param index The index of the element to return.
+             * @return The fieldRefs at the given index.
+             */
+            public java.lang.String getFieldRefs(int index) {
+                return fieldRefs_.get(index);
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @param index The index of the value to return.
+             * @return The bytes of the fieldRefs at the given index.
+             */
+            public com.google.protobuf.ByteString
+            getFieldRefsBytes(int index) {
+                return fieldRefs_.getByteString(index);
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @param index The index to set the value at.
+             * @param value The fieldRefs to set.
+             * @return This builder for chaining.
+             */
+            public Builder setFieldRefs(
+                    int index, java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureFieldRefsIsMutable();
+                fieldRefs_.set(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @param value The fieldRefs to add.
+             * @return This builder for chaining.
+             */
+            public Builder addFieldRefs(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureFieldRefsIsMutable();
+                fieldRefs_.add(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @param values The fieldRefs to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllFieldRefs(
+                    java.lang.Iterable<java.lang.String> values) {
+                ensureFieldRefsIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, fieldRefs_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearFieldRefs() {
+                fieldRefs_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string field_refs = 1;</code>
+             * @param value The bytes of the fieldRefs to add.
+             * @return This builder for chaining.
+             */
+            public Builder addFieldRefsBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                ensureFieldRefsIsMutable();
+                fieldRefs_.add(value);
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExprFieldRef)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExprFieldRef)
+        private static final Grpccatalog.ExprFieldRef DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExprFieldRef();
+        }
+
+        public static Grpccatalog.ExprFieldRef getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExprFieldRef>
+                PARSER = new com.google.protobuf.AbstractParser<ExprFieldRef>() {
+            @java.lang.Override
+            public ExprFieldRef parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExprFieldRef> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExprFieldRef> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExprFieldRef getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExprNodeOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExprNode)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ExprOp expr_op = 1;</code>
+         * @return Whether the exprOp field is set.
+         */
+        boolean hasExprOp();
+        /**
+         * <code>.ExprOp expr_op = 1;</code>
+         * @return The exprOp.
+         */
+        Grpccatalog.ExprOp getExprOp();
+        /**
+         * <code>.ExprOp expr_op = 1;</code>
+         */
+        Grpccatalog.ExprOpOrBuilder getExprOpOrBuilder();
+
+        /**
+         * <code>.ExprBool expr_bool = 2;</code>
+         * @return Whether the exprBool field is set.
+         */
+        boolean hasExprBool();
+        /**
+         * <code>.ExprBool expr_bool = 2;</code>
+         * @return The exprBool.
+         */
+        Grpccatalog.ExprBool getExprBool();
+        /**
+         * <code>.ExprBool expr_bool = 2;</code>
+         */
+        Grpccatalog.ExprBoolOrBuilder getExprBoolOrBuilder();
+
+        /**
+         * <code>.ExprConst expr_const = 3;</code>
+         * @return Whether the exprConst field is set.
+         */
+        boolean hasExprConst();
+        /**
+         * <code>.ExprConst expr_const = 3;</code>
+         * @return The exprConst.
+         */
+        Grpccatalog.ExprConst getExprConst();
+        /**
+         * <code>.ExprConst expr_const = 3;</code>
+         */
+        Grpccatalog.ExprConstOrBuilder getExprConstOrBuilder();
+
+        /**
+         * <code>.ExprFieldRef expr_field_ref = 4;</code>
+         * @return Whether the exprFieldRef field is set.
+         */
+        boolean hasExprFieldRef();
+        /**
+         * <code>.ExprFieldRef expr_field_ref = 4;</code>
+         * @return The exprFieldRef.
+         */
+        Grpccatalog.ExprFieldRef getExprFieldRef();
+        /**
+         * <code>.ExprFieldRef expr_field_ref = 4;</code>
+         */
+        Grpccatalog.ExprFieldRefOrBuilder getExprFieldRefOrBuilder();
+
+        public Grpccatalog.ExprNode.NodeCase getNodeCase();
+    }
+    /**
+     * <pre>
+     * General expression node.
+     * </pre>
+     *
+     * Protobuf type {@code ExprNode}
+     */
+    public static final class ExprNode extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExprNode)
+            ExprNodeOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExprNode.newBuilder() to construct.
+        private ExprNode(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExprNode() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExprNode();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExprNode_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExprNode_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExprNode.class, Grpccatalog.ExprNode.Builder.class);
+        }
+
+        private int nodeCase_ = 0;
+        private java.lang.Object node_;
+        public enum NodeCase
+                implements com.google.protobuf.Internal.EnumLite,
+                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
+            EXPR_OP(1),
+            EXPR_BOOL(2),
+            EXPR_CONST(3),
+            EXPR_FIELD_REF(4),
+            NODE_NOT_SET(0);
+            private final int value;
+            private NodeCase(int value) {
+                this.value = value;
+            }
+            /**
+             * @param value The number of the enum to look for.
+             * @return The enum associated with the given number.
+             * @deprecated Use {@link #forNumber(int)} instead.
+             */
+            @java.lang.Deprecated
+            public static NodeCase valueOf(int value) {
+                return forNumber(value);
+            }
+
+            public static NodeCase forNumber(int value) {
+                switch (value) {
+                    case 1: return EXPR_OP;
+                    case 2: return EXPR_BOOL;
+                    case 3: return EXPR_CONST;
+                    case 4: return EXPR_FIELD_REF;
+                    case 0: return NODE_NOT_SET;
+                    default: return null;
+                }
+            }
+            public int getNumber() {
+                return this.value;
+            }
+        };
+
+        public NodeCase
+        getNodeCase() {
+            return NodeCase.forNumber(
+                    nodeCase_);
+        }
+
+        public static final int EXPR_OP_FIELD_NUMBER = 1;
+        /**
+         * <code>.ExprOp expr_op = 1;</code>
+         * @return Whether the exprOp field is set.
+         */
+        @java.lang.Override
+        public boolean hasExprOp() {
+            return nodeCase_ == 1;
+        }
+        /**
+         * <code>.ExprOp expr_op = 1;</code>
+         * @return The exprOp.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprOp getExprOp() {
+            if (nodeCase_ == 1) {
+                return (Grpccatalog.ExprOp) node_;
+            }
+            return Grpccatalog.ExprOp.getDefaultInstance();
+        }
+        /**
+         * <code>.ExprOp expr_op = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprOpOrBuilder getExprOpOrBuilder() {
+            if (nodeCase_ == 1) {
+                return (Grpccatalog.ExprOp) node_;
+            }
+            return Grpccatalog.ExprOp.getDefaultInstance();
+        }
+
+        public static final int EXPR_BOOL_FIELD_NUMBER = 2;
+        /**
+         * <code>.ExprBool expr_bool = 2;</code>
+         * @return Whether the exprBool field is set.
+         */
+        @java.lang.Override
+        public boolean hasExprBool() {
+            return nodeCase_ == 2;
+        }
+        /**
+         * <code>.ExprBool expr_bool = 2;</code>
+         * @return The exprBool.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprBool getExprBool() {
+            if (nodeCase_ == 2) {
+                return (Grpccatalog.ExprBool) node_;
+            }
+            return Grpccatalog.ExprBool.getDefaultInstance();
+        }
+        /**
+         * <code>.ExprBool expr_bool = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprBoolOrBuilder getExprBoolOrBuilder() {
+            if (nodeCase_ == 2) {
+                return (Grpccatalog.ExprBool) node_;
+            }
+            return Grpccatalog.ExprBool.getDefaultInstance();
+        }
+
+        public static final int EXPR_CONST_FIELD_NUMBER = 3;
+        /**
+         * <code>.ExprConst expr_const = 3;</code>
+         * @return Whether the exprConst field is set.
+         */
+        @java.lang.Override
+        public boolean hasExprConst() {
+            return nodeCase_ == 3;
+        }
+        /**
+         * <code>.ExprConst expr_const = 3;</code>
+         * @return The exprConst.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprConst getExprConst() {
+            if (nodeCase_ == 3) {
+                return (Grpccatalog.ExprConst) node_;
+            }
+            return Grpccatalog.ExprConst.getDefaultInstance();
+        }
+        /**
+         * <code>.ExprConst expr_const = 3;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprConstOrBuilder getExprConstOrBuilder() {
+            if (nodeCase_ == 3) {
+                return (Grpccatalog.ExprConst) node_;
+            }
+            return Grpccatalog.ExprConst.getDefaultInstance();
+        }
+
+        public static final int EXPR_FIELD_REF_FIELD_NUMBER = 4;
+        /**
+         * <code>.ExprFieldRef expr_field_ref = 4;</code>
+         * @return Whether the exprFieldRef field is set.
+         */
+        @java.lang.Override
+        public boolean hasExprFieldRef() {
+            return nodeCase_ == 4;
+        }
+        /**
+         * <code>.ExprFieldRef expr_field_ref = 4;</code>
+         * @return The exprFieldRef.
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprFieldRef getExprFieldRef() {
+            if (nodeCase_ == 4) {
+                return (Grpccatalog.ExprFieldRef) node_;
+            }
+            return Grpccatalog.ExprFieldRef.getDefaultInstance();
+        }
+        /**
+         * <code>.ExprFieldRef expr_field_ref = 4;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ExprFieldRefOrBuilder getExprFieldRefOrBuilder() {
+            if (nodeCase_ == 4) {
+                return (Grpccatalog.ExprFieldRef) node_;
+            }
+            return Grpccatalog.ExprFieldRef.getDefaultInstance();
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (nodeCase_ == 1) {
+                output.writeMessage(1, (Grpccatalog.ExprOp) node_);
+            }
+            if (nodeCase_ == 2) {
+                output.writeMessage(2, (Grpccatalog.ExprBool) node_);
+            }
+            if (nodeCase_ == 3) {
+                output.writeMessage(3, (Grpccatalog.ExprConst) node_);
+            }
+            if (nodeCase_ == 4) {
+                output.writeMessage(4, (Grpccatalog.ExprFieldRef) node_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (nodeCase_ == 1) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(1, (Grpccatalog.ExprOp) node_);
+            }
+            if (nodeCase_ == 2) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(2, (Grpccatalog.ExprBool) node_);
+            }
+            if (nodeCase_ == 3) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(3, (Grpccatalog.ExprConst) node_);
+            }
+            if (nodeCase_ == 4) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(4, (Grpccatalog.ExprFieldRef) node_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExprNode)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExprNode other = (Grpccatalog.ExprNode) obj;
+
+            if (!getNodeCase().equals(other.getNodeCase())) return false;
+            switch (nodeCase_) {
+                case 1:
+                    if (!getExprOp()
+                            .equals(other.getExprOp())) return false;
+                    break;
+                case 2:
+                    if (!getExprBool()
+                            .equals(other.getExprBool())) return false;
+                    break;
+                case 3:
+                    if (!getExprConst()
+                            .equals(other.getExprConst())) return false;
+                    break;
+                case 4:
+                    if (!getExprFieldRef()
+                            .equals(other.getExprFieldRef())) return false;
+                    break;
+                case 0:
+                default:
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            switch (nodeCase_) {
+                case 1:
+                    hash = (37 * hash) + EXPR_OP_FIELD_NUMBER;
+                    hash = (53 * hash) + getExprOp().hashCode();
+                    break;
+                case 2:
+                    hash = (37 * hash) + EXPR_BOOL_FIELD_NUMBER;
+                    hash = (53 * hash) + getExprBool().hashCode();
+                    break;
+                case 3:
+                    hash = (37 * hash) + EXPR_CONST_FIELD_NUMBER;
+                    hash = (53 * hash) + getExprConst().hashCode();
+                    break;
+                case 4:
+                    hash = (37 * hash) + EXPR_FIELD_REF_FIELD_NUMBER;
+                    hash = (53 * hash) + getExprFieldRef().hashCode();
+                    break;
+                case 0:
+                default:
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExprNode parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprNode parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExprNode parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprNode parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprNode parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExprNode parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExprNode prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * General expression node.
+         * </pre>
+         *
+         * Protobuf type {@code ExprNode}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExprNode)
+                Grpccatalog.ExprNodeOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExprNode_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExprNode_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExprNode.class, Grpccatalog.ExprNode.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExprNode.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                if (exprOpBuilder_ != null) {
+                    exprOpBuilder_.clear();
+                }
+                if (exprBoolBuilder_ != null) {
+                    exprBoolBuilder_.clear();
+                }
+                if (exprConstBuilder_ != null) {
+                    exprConstBuilder_.clear();
+                }
+                if (exprFieldRefBuilder_ != null) {
+                    exprFieldRefBuilder_.clear();
+                }
+                nodeCase_ = 0;
+                node_ = null;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExprNode_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprNode getDefaultInstanceForType() {
+                return Grpccatalog.ExprNode.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprNode build() {
+                Grpccatalog.ExprNode result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExprNode buildPartial() {
+                Grpccatalog.ExprNode result = new Grpccatalog.ExprNode(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                buildPartialOneofs(result);
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ExprNode result) {
+                int from_bitField0_ = bitField0_;
+            }
+
+            private void buildPartialOneofs(Grpccatalog.ExprNode result) {
+                result.nodeCase_ = nodeCase_;
+                result.node_ = this.node_;
+                if (nodeCase_ == 1 &&
+                        exprOpBuilder_ != null) {
+                    result.node_ = exprOpBuilder_.build();
+                }
+                if (nodeCase_ == 2 &&
+                        exprBoolBuilder_ != null) {
+                    result.node_ = exprBoolBuilder_.build();
+                }
+                if (nodeCase_ == 3 &&
+                        exprConstBuilder_ != null) {
+                    result.node_ = exprConstBuilder_.build();
+                }
+                if (nodeCase_ == 4 &&
+                        exprFieldRefBuilder_ != null) {
+                    result.node_ = exprFieldRefBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExprNode) {
+                    return mergeFrom((Grpccatalog.ExprNode)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExprNode other) {
+                if (other == Grpccatalog.ExprNode.getDefaultInstance()) return this;
+                switch (other.getNodeCase()) {
+                    case EXPR_OP: {
+                        mergeExprOp(other.getExprOp());
+                        break;
+                    }
+                    case EXPR_BOOL: {
+                        mergeExprBool(other.getExprBool());
+                        break;
+                    }
+                    case EXPR_CONST: {
+                        mergeExprConst(other.getExprConst());
+                        break;
+                    }
+                    case EXPR_FIELD_REF: {
+                        mergeExprFieldRef(other.getExprFieldRef());
+                        break;
+                    }
+                    case NODE_NOT_SET: {
+                        break;
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                input.readMessage(
+                                        getExprOpFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                nodeCase_ = 1;
+                                break;
+                            } // case 10
+                            case 18: {
+                                input.readMessage(
+                                        getExprBoolFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                nodeCase_ = 2;
+                                break;
+                            } // case 18
+                            case 26: {
+                                input.readMessage(
+                                        getExprConstFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                nodeCase_ = 3;
+                                break;
+                            } // case 26
+                            case 34: {
+                                input.readMessage(
+                                        getExprFieldRefFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                nodeCase_ = 4;
+                                break;
+                            } // case 34
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int nodeCase_ = 0;
+            private java.lang.Object node_;
+            public NodeCase
+            getNodeCase() {
+                return NodeCase.forNumber(
+                        nodeCase_);
+            }
+
+            public Builder clearNode() {
+                nodeCase_ = 0;
+                node_ = null;
+                onChanged();
+                return this;
+            }
+
+            private int bitField0_;
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprOp, Grpccatalog.ExprOp.Builder, Grpccatalog.ExprOpOrBuilder> exprOpBuilder_;
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             * @return Whether the exprOp field is set.
+             */
+            @java.lang.Override
+            public boolean hasExprOp() {
+                return nodeCase_ == 1;
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             * @return The exprOp.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprOp getExprOp() {
+                if (exprOpBuilder_ == null) {
+                    if (nodeCase_ == 1) {
+                        return (Grpccatalog.ExprOp) node_;
+                    }
+                    return Grpccatalog.ExprOp.getDefaultInstance();
+                } else {
+                    if (nodeCase_ == 1) {
+                        return exprOpBuilder_.getMessage();
+                    }
+                    return Grpccatalog.ExprOp.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            public Builder setExprOp(Grpccatalog.ExprOp value) {
+                if (exprOpBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    node_ = value;
+                    onChanged();
+                } else {
+                    exprOpBuilder_.setMessage(value);
+                }
+                nodeCase_ = 1;
+                return this;
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            public Builder setExprOp(
+                    Grpccatalog.ExprOp.Builder builderForValue) {
+                if (exprOpBuilder_ == null) {
+                    node_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    exprOpBuilder_.setMessage(builderForValue.build());
+                }
+                nodeCase_ = 1;
+                return this;
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            public Builder mergeExprOp(Grpccatalog.ExprOp value) {
+                if (exprOpBuilder_ == null) {
+                    if (nodeCase_ == 1 &&
+                            node_ != Grpccatalog.ExprOp.getDefaultInstance()) {
+                        node_ = Grpccatalog.ExprOp.newBuilder((Grpccatalog.ExprOp) node_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        node_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (nodeCase_ == 1) {
+                        exprOpBuilder_.mergeFrom(value);
+                    } else {
+                        exprOpBuilder_.setMessage(value);
+                    }
+                }
+                nodeCase_ = 1;
+                return this;
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            public Builder clearExprOp() {
+                if (exprOpBuilder_ == null) {
+                    if (nodeCase_ == 1) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (nodeCase_ == 1) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                    }
+                    exprOpBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            public Grpccatalog.ExprOp.Builder getExprOpBuilder() {
+                return getExprOpFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprOpOrBuilder getExprOpOrBuilder() {
+                if ((nodeCase_ == 1) && (exprOpBuilder_ != null)) {
+                    return exprOpBuilder_.getMessageOrBuilder();
+                } else {
+                    if (nodeCase_ == 1) {
+                        return (Grpccatalog.ExprOp) node_;
+                    }
+                    return Grpccatalog.ExprOp.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprOp expr_op = 1;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprOp, Grpccatalog.ExprOp.Builder, Grpccatalog.ExprOpOrBuilder>
+            getExprOpFieldBuilder() {
+                if (exprOpBuilder_ == null) {
+                    if (!(nodeCase_ == 1)) {
+                        node_ = Grpccatalog.ExprOp.getDefaultInstance();
+                    }
+                    exprOpBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprOp, Grpccatalog.ExprOp.Builder, Grpccatalog.ExprOpOrBuilder>(
+                            (Grpccatalog.ExprOp) node_,
+                            getParentForChildren(),
+                            isClean());
+                    node_ = null;
+                }
+                nodeCase_ = 1;
+                onChanged();
+                return exprOpBuilder_;
+            }
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprBool, Grpccatalog.ExprBool.Builder, Grpccatalog.ExprBoolOrBuilder> exprBoolBuilder_;
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             * @return Whether the exprBool field is set.
+             */
+            @java.lang.Override
+            public boolean hasExprBool() {
+                return nodeCase_ == 2;
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             * @return The exprBool.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprBool getExprBool() {
+                if (exprBoolBuilder_ == null) {
+                    if (nodeCase_ == 2) {
+                        return (Grpccatalog.ExprBool) node_;
+                    }
+                    return Grpccatalog.ExprBool.getDefaultInstance();
+                } else {
+                    if (nodeCase_ == 2) {
+                        return exprBoolBuilder_.getMessage();
+                    }
+                    return Grpccatalog.ExprBool.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            public Builder setExprBool(Grpccatalog.ExprBool value) {
+                if (exprBoolBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    node_ = value;
+                    onChanged();
+                } else {
+                    exprBoolBuilder_.setMessage(value);
+                }
+                nodeCase_ = 2;
+                return this;
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            public Builder setExprBool(
+                    Grpccatalog.ExprBool.Builder builderForValue) {
+                if (exprBoolBuilder_ == null) {
+                    node_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    exprBoolBuilder_.setMessage(builderForValue.build());
+                }
+                nodeCase_ = 2;
+                return this;
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            public Builder mergeExprBool(Grpccatalog.ExprBool value) {
+                if (exprBoolBuilder_ == null) {
+                    if (nodeCase_ == 2 &&
+                            node_ != Grpccatalog.ExprBool.getDefaultInstance()) {
+                        node_ = Grpccatalog.ExprBool.newBuilder((Grpccatalog.ExprBool) node_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        node_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (nodeCase_ == 2) {
+                        exprBoolBuilder_.mergeFrom(value);
+                    } else {
+                        exprBoolBuilder_.setMessage(value);
+                    }
+                }
+                nodeCase_ = 2;
+                return this;
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            public Builder clearExprBool() {
+                if (exprBoolBuilder_ == null) {
+                    if (nodeCase_ == 2) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (nodeCase_ == 2) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                    }
+                    exprBoolBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            public Grpccatalog.ExprBool.Builder getExprBoolBuilder() {
+                return getExprBoolFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprBoolOrBuilder getExprBoolOrBuilder() {
+                if ((nodeCase_ == 2) && (exprBoolBuilder_ != null)) {
+                    return exprBoolBuilder_.getMessageOrBuilder();
+                } else {
+                    if (nodeCase_ == 2) {
+                        return (Grpccatalog.ExprBool) node_;
+                    }
+                    return Grpccatalog.ExprBool.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprBool expr_bool = 2;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprBool, Grpccatalog.ExprBool.Builder, Grpccatalog.ExprBoolOrBuilder>
+            getExprBoolFieldBuilder() {
+                if (exprBoolBuilder_ == null) {
+                    if (!(nodeCase_ == 2)) {
+                        node_ = Grpccatalog.ExprBool.getDefaultInstance();
+                    }
+                    exprBoolBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprBool, Grpccatalog.ExprBool.Builder, Grpccatalog.ExprBoolOrBuilder>(
+                            (Grpccatalog.ExprBool) node_,
+                            getParentForChildren(),
+                            isClean());
+                    node_ = null;
+                }
+                nodeCase_ = 2;
+                onChanged();
+                return exprBoolBuilder_;
+            }
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprConst, Grpccatalog.ExprConst.Builder, Grpccatalog.ExprConstOrBuilder> exprConstBuilder_;
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             * @return Whether the exprConst field is set.
+             */
+            @java.lang.Override
+            public boolean hasExprConst() {
+                return nodeCase_ == 3;
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             * @return The exprConst.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprConst getExprConst() {
+                if (exprConstBuilder_ == null) {
+                    if (nodeCase_ == 3) {
+                        return (Grpccatalog.ExprConst) node_;
+                    }
+                    return Grpccatalog.ExprConst.getDefaultInstance();
+                } else {
+                    if (nodeCase_ == 3) {
+                        return exprConstBuilder_.getMessage();
+                    }
+                    return Grpccatalog.ExprConst.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            public Builder setExprConst(Grpccatalog.ExprConst value) {
+                if (exprConstBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    node_ = value;
+                    onChanged();
+                } else {
+                    exprConstBuilder_.setMessage(value);
+                }
+                nodeCase_ = 3;
+                return this;
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            public Builder setExprConst(
+                    Grpccatalog.ExprConst.Builder builderForValue) {
+                if (exprConstBuilder_ == null) {
+                    node_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    exprConstBuilder_.setMessage(builderForValue.build());
+                }
+                nodeCase_ = 3;
+                return this;
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            public Builder mergeExprConst(Grpccatalog.ExprConst value) {
+                if (exprConstBuilder_ == null) {
+                    if (nodeCase_ == 3 &&
+                            node_ != Grpccatalog.ExprConst.getDefaultInstance()) {
+                        node_ = Grpccatalog.ExprConst.newBuilder((Grpccatalog.ExprConst) node_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        node_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (nodeCase_ == 3) {
+                        exprConstBuilder_.mergeFrom(value);
+                    } else {
+                        exprConstBuilder_.setMessage(value);
+                    }
+                }
+                nodeCase_ = 3;
+                return this;
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            public Builder clearExprConst() {
+                if (exprConstBuilder_ == null) {
+                    if (nodeCase_ == 3) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (nodeCase_ == 3) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                    }
+                    exprConstBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            public Grpccatalog.ExprConst.Builder getExprConstBuilder() {
+                return getExprConstFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprConstOrBuilder getExprConstOrBuilder() {
+                if ((nodeCase_ == 3) && (exprConstBuilder_ != null)) {
+                    return exprConstBuilder_.getMessageOrBuilder();
+                } else {
+                    if (nodeCase_ == 3) {
+                        return (Grpccatalog.ExprConst) node_;
+                    }
+                    return Grpccatalog.ExprConst.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprConst expr_const = 3;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprConst, Grpccatalog.ExprConst.Builder, Grpccatalog.ExprConstOrBuilder>
+            getExprConstFieldBuilder() {
+                if (exprConstBuilder_ == null) {
+                    if (!(nodeCase_ == 3)) {
+                        node_ = Grpccatalog.ExprConst.getDefaultInstance();
+                    }
+                    exprConstBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprConst, Grpccatalog.ExprConst.Builder, Grpccatalog.ExprConstOrBuilder>(
+                            (Grpccatalog.ExprConst) node_,
+                            getParentForChildren(),
+                            isClean());
+                    node_ = null;
+                }
+                nodeCase_ = 3;
+                onChanged();
+                return exprConstBuilder_;
+            }
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprFieldRef, Grpccatalog.ExprFieldRef.Builder, Grpccatalog.ExprFieldRefOrBuilder> exprFieldRefBuilder_;
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             * @return Whether the exprFieldRef field is set.
+             */
+            @java.lang.Override
+            public boolean hasExprFieldRef() {
+                return nodeCase_ == 4;
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             * @return The exprFieldRef.
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprFieldRef getExprFieldRef() {
+                if (exprFieldRefBuilder_ == null) {
+                    if (nodeCase_ == 4) {
+                        return (Grpccatalog.ExprFieldRef) node_;
+                    }
+                    return Grpccatalog.ExprFieldRef.getDefaultInstance();
+                } else {
+                    if (nodeCase_ == 4) {
+                        return exprFieldRefBuilder_.getMessage();
+                    }
+                    return Grpccatalog.ExprFieldRef.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            public Builder setExprFieldRef(Grpccatalog.ExprFieldRef value) {
+                if (exprFieldRefBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    node_ = value;
+                    onChanged();
+                } else {
+                    exprFieldRefBuilder_.setMessage(value);
+                }
+                nodeCase_ = 4;
+                return this;
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            public Builder setExprFieldRef(
+                    Grpccatalog.ExprFieldRef.Builder builderForValue) {
+                if (exprFieldRefBuilder_ == null) {
+                    node_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    exprFieldRefBuilder_.setMessage(builderForValue.build());
+                }
+                nodeCase_ = 4;
+                return this;
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            public Builder mergeExprFieldRef(Grpccatalog.ExprFieldRef value) {
+                if (exprFieldRefBuilder_ == null) {
+                    if (nodeCase_ == 4 &&
+                            node_ != Grpccatalog.ExprFieldRef.getDefaultInstance()) {
+                        node_ = Grpccatalog.ExprFieldRef.newBuilder((Grpccatalog.ExprFieldRef) node_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        node_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (nodeCase_ == 4) {
+                        exprFieldRefBuilder_.mergeFrom(value);
+                    } else {
+                        exprFieldRefBuilder_.setMessage(value);
+                    }
+                }
+                nodeCase_ = 4;
+                return this;
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            public Builder clearExprFieldRef() {
+                if (exprFieldRefBuilder_ == null) {
+                    if (nodeCase_ == 4) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (nodeCase_ == 4) {
+                        nodeCase_ = 0;
+                        node_ = null;
+                    }
+                    exprFieldRefBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            public Grpccatalog.ExprFieldRef.Builder getExprFieldRefBuilder() {
+                return getExprFieldRefFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.ExprFieldRefOrBuilder getExprFieldRefOrBuilder() {
+                if ((nodeCase_ == 4) && (exprFieldRefBuilder_ != null)) {
+                    return exprFieldRefBuilder_.getMessageOrBuilder();
+                } else {
+                    if (nodeCase_ == 4) {
+                        return (Grpccatalog.ExprFieldRef) node_;
+                    }
+                    return Grpccatalog.ExprFieldRef.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.ExprFieldRef expr_field_ref = 4;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ExprFieldRef, Grpccatalog.ExprFieldRef.Builder, Grpccatalog.ExprFieldRefOrBuilder>
+            getExprFieldRefFieldBuilder() {
+                if (exprFieldRefBuilder_ == null) {
+                    if (!(nodeCase_ == 4)) {
+                        node_ = Grpccatalog.ExprFieldRef.getDefaultInstance();
+                    }
+                    exprFieldRefBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ExprFieldRef, Grpccatalog.ExprFieldRef.Builder, Grpccatalog.ExprFieldRefOrBuilder>(
+                            (Grpccatalog.ExprFieldRef) node_,
+                            getParentForChildren(),
+                            isClean());
+                    node_ = null;
+                }
+                nodeCase_ = 4;
+                onChanged();
+                return exprFieldRefBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExprNode)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExprNode)
+        private static final Grpccatalog.ExprNode DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExprNode();
+        }
+
+        public static Grpccatalog.ExprNode getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExprNode>
+                PARSER = new com.google.protobuf.AbstractParser<ExprNode>() {
+            @java.lang.Override
+            public ExprNode parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExprNode> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExprNode> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExprNode getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface StartTxnRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:StartTxnRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.TxnMode txn_mode = 1;</code>
+         * @return The enum numeric value on the wire for txnMode.
+         */
+        int getTxnModeValue();
+        /**
+         * <code>.TxnMode txn_mode = 1;</code>
+         * @return The txnMode.
+         */
+        Grpccatalog.TxnMode getTxnMode();
+
+        /**
+         * <code>optional uint64 read_vid = 2;</code>
+         * @return Whether the readVid field is set.
+         */
+        boolean hasReadVid();
+        /**
+         * <code>optional uint64 read_vid = 2;</code>
+         * @return The readVid.
+         */
+        long getReadVid();
+    }
+    /**
+     * <pre>
+     * Start transaction in either READ or READ_WRITE mode.
+     * TODO txn_mode is ignored for now, will support READ only txn in the future
+     * </pre>
+     *
+     * Protobuf type {@code StartTxnRequest}
+     */
+    public static final class StartTxnRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:StartTxnRequest)
+            StartTxnRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use StartTxnRequest.newBuilder() to construct.
+        private StartTxnRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private StartTxnRequest() {
+            txnMode_ = 0;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new StartTxnRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_StartTxnRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_StartTxnRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.StartTxnRequest.class, Grpccatalog.StartTxnRequest.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int TXN_MODE_FIELD_NUMBER = 1;
+        private int txnMode_ = 0;
+        /**
+         * <code>.TxnMode txn_mode = 1;</code>
+         * @return The enum numeric value on the wire for txnMode.
+         */
+        @java.lang.Override public int getTxnModeValue() {
+            return txnMode_;
+        }
+        /**
+         * <code>.TxnMode txn_mode = 1;</code>
+         * @return The txnMode.
+         */
+        @java.lang.Override public Grpccatalog.TxnMode getTxnMode() {
+            Grpccatalog.TxnMode result = Grpccatalog.TxnMode.forNumber(txnMode_);
+            return result == null ? Grpccatalog.TxnMode.UNRECOGNIZED : result;
+        }
+
+        public static final int READ_VID_FIELD_NUMBER = 2;
+        private long readVid_ = 0L;
+        /**
+         * <code>optional uint64 read_vid = 2;</code>
+         * @return Whether the readVid field is set.
+         */
+        @java.lang.Override
+        public boolean hasReadVid() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional uint64 read_vid = 2;</code>
+         * @return The readVid.
+         */
+        @java.lang.Override
+        public long getReadVid() {
+            return readVid_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (txnMode_ != Grpccatalog.TxnMode.TXN_MODE_READ_ONLY.getNumber()) {
+                output.writeEnum(1, txnMode_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeUInt64(2, readVid_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (txnMode_ != Grpccatalog.TxnMode.TXN_MODE_READ_ONLY.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(1, txnMode_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, readVid_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.StartTxnRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.StartTxnRequest other = (Grpccatalog.StartTxnRequest) obj;
+
+            if (txnMode_ != other.txnMode_) return false;
+            if (hasReadVid() != other.hasReadVid()) return false;
+            if (hasReadVid()) {
+                if (getReadVid()
+                        != other.getReadVid()) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + TXN_MODE_FIELD_NUMBER;
+            hash = (53 * hash) + txnMode_;
+            if (hasReadVid()) {
+                hash = (37 * hash) + READ_VID_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                        getReadVid());
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.StartTxnRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.StartTxnRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.StartTxnRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Start transaction in either READ or READ_WRITE mode.
+         * TODO txn_mode is ignored for now, will support READ only txn in the future
+         * </pre>
+         *
+         * Protobuf type {@code StartTxnRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:StartTxnRequest)
+                Grpccatalog.StartTxnRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_StartTxnRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_StartTxnRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.StartTxnRequest.class, Grpccatalog.StartTxnRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.StartTxnRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                txnMode_ = 0;
+                readVid_ = 0L;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_StartTxnRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.StartTxnRequest getDefaultInstanceForType() {
+                return Grpccatalog.StartTxnRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.StartTxnRequest build() {
+                Grpccatalog.StartTxnRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.StartTxnRequest buildPartial() {
+                Grpccatalog.StartTxnRequest result = new Grpccatalog.StartTxnRequest(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.StartTxnRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.txnMode_ = txnMode_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.readVid_ = readVid_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.StartTxnRequest) {
+                    return mergeFrom((Grpccatalog.StartTxnRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.StartTxnRequest other) {
+                if (other == Grpccatalog.StartTxnRequest.getDefaultInstance()) return this;
+                if (other.txnMode_ != 0) {
+                    setTxnModeValue(other.getTxnModeValue());
+                }
+                if (other.hasReadVid()) {
+                    setReadVid(other.getReadVid());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                txnMode_ = input.readEnum();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                readVid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private int txnMode_ = 0;
+            /**
+             * <code>.TxnMode txn_mode = 1;</code>
+             * @return The enum numeric value on the wire for txnMode.
+             */
+            @java.lang.Override public int getTxnModeValue() {
+                return txnMode_;
+            }
+            /**
+             * <code>.TxnMode txn_mode = 1;</code>
+             * @param value The enum numeric value on the wire for txnMode to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTxnModeValue(int value) {
+                txnMode_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.TxnMode txn_mode = 1;</code>
+             * @return The txnMode.
+             */
+            @java.lang.Override
+            public Grpccatalog.TxnMode getTxnMode() {
+                Grpccatalog.TxnMode result = Grpccatalog.TxnMode.forNumber(txnMode_);
+                return result == null ? Grpccatalog.TxnMode.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.TxnMode txn_mode = 1;</code>
+             * @param value The txnMode to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTxnMode(Grpccatalog.TxnMode value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000001;
+                txnMode_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.TxnMode txn_mode = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearTxnMode() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                txnMode_ = 0;
+                onChanged();
+                return this;
+            }
+
+            private long readVid_ ;
+            /**
+             * <code>optional uint64 read_vid = 2;</code>
+             * @return Whether the readVid field is set.
+             */
+            @java.lang.Override
+            public boolean hasReadVid() {
+                return ((bitField0_ & 0x00000002) != 0);
+            }
+            /**
+             * <code>optional uint64 read_vid = 2;</code>
+             * @return The readVid.
+             */
+            @java.lang.Override
+            public long getReadVid() {
+                return readVid_;
+            }
+            /**
+             * <code>optional uint64 read_vid = 2;</code>
+             * @param value The readVid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setReadVid(long value) {
+
+                readVid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional uint64 read_vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearReadVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                readVid_ = 0L;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:StartTxnRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:StartTxnRequest)
+        private static final Grpccatalog.StartTxnRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.StartTxnRequest();
+        }
+
+        public static Grpccatalog.StartTxnRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<StartTxnRequest>
+                PARSER = new com.google.protobuf.AbstractParser<StartTxnRequest>() {
+            @java.lang.Override
+            public StartTxnRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<StartTxnRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<StartTxnRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.StartTxnRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface StartTxnResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:StartTxnResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        long getVid();
+
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return Whether the txnId field is set.
+         */
+        boolean hasTxnId();
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return The txnId.
+         */
+        long getTxnId();
+    }
+    /**
+     * <pre>
+     * Whether operation was successful and the vid of the version at which
+     * the transaction is to be performed and txn_id of the txn object.
+     * </pre>
+     *
+     * Protobuf type {@code StartTxnResponse}
+     */
+    public static final class StartTxnResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:StartTxnResponse)
+            StartTxnResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use StartTxnResponse.newBuilder() to construct.
+        private StartTxnResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private StartTxnResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new StartTxnResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_StartTxnResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_StartTxnResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.StartTxnResponse.class, Grpccatalog.StartTxnResponse.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        public static final int VID_FIELD_NUMBER = 2;
+        private long vid_ = 0L;
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        public static final int TXN_ID_FIELD_NUMBER = 3;
+        private long txnId_ = 0L;
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return Whether the txnId field is set.
+         */
+        @java.lang.Override
+        public boolean hasTxnId() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return The txnId.
+         */
+        @java.lang.Override
+        public long getTxnId() {
+            return txnId_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            if (vid_ != 0L) {
+                output.writeUInt64(2, vid_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeUInt64(3, txnId_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            if (vid_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, vid_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(3, txnId_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.StartTxnResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.StartTxnResponse other = (Grpccatalog.StartTxnResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (getVid()
+                    != other.getVid()) return false;
+            if (hasTxnId() != other.hasTxnId()) return false;
+            if (hasTxnId()) {
+                if (getTxnId()
+                        != other.getTxnId()) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (37 * hash) + VID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getVid());
+            if (hasTxnId()) {
+                hash = (37 * hash) + TXN_ID_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                        getTxnId());
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.StartTxnResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.StartTxnResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.StartTxnResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether operation was successful and the vid of the version at which
+         * the transaction is to be performed and txn_id of the txn object.
+         * </pre>
+         *
+         * Protobuf type {@code StartTxnResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:StartTxnResponse)
+                Grpccatalog.StartTxnResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_StartTxnResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_StartTxnResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.StartTxnResponse.class, Grpccatalog.StartTxnResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.StartTxnResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                vid_ = 0L;
+                txnId_ = 0L;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_StartTxnResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.StartTxnResponse getDefaultInstanceForType() {
+                return Grpccatalog.StartTxnResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.StartTxnResponse build() {
+                Grpccatalog.StartTxnResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.StartTxnResponse buildPartial() {
+                Grpccatalog.StartTxnResponse result = new Grpccatalog.StartTxnResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.StartTxnResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.vid_ = vid_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.txnId_ = txnId_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.StartTxnResponse) {
+                    return mergeFrom((Grpccatalog.StartTxnResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.StartTxnResponse other) {
+                if (other == Grpccatalog.StartTxnResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                if (other.getVid() != 0L) {
+                    setVid(other.getVid());
+                }
+                if (other.hasTxnId()) {
+                    setTxnId(other.getTxnId());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            case 24: {
+                                txnId_ = input.readUInt64();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 24
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private long txnId_ ;
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @return Whether the txnId field is set.
+             */
+            @java.lang.Override
+            public boolean hasTxnId() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @return The txnId.
+             */
+            @java.lang.Override
+            public long getTxnId() {
+                return txnId_;
+            }
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @param value The txnId to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTxnId(long value) {
+
+                txnId_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearTxnId() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                txnId_ = 0L;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:StartTxnResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:StartTxnResponse)
+        private static final Grpccatalog.StartTxnResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.StartTxnResponse();
+        }
+
+        public static Grpccatalog.StartTxnResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<StartTxnResponse>
+                PARSER = new com.google.protobuf.AbstractParser<StartTxnResponse>() {
+            @java.lang.Override
+            public StartTxnResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<StartTxnResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<StartTxnResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.StartTxnResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface SnapshotRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:SnapshotRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>string name = 1;</code>
+         * @return The name.
+         */
+        java.lang.String getName();
+        /**
+         * <code>string name = 1;</code>
+         * @return The bytes for name.
+         */
+        com.google.protobuf.ByteString
+        getNameBytes();
+
+        /**
+         * <code>optional uint64 vid = 2;</code>
+         * @return Whether the vid field is set.
+         */
+        boolean hasVid();
+        /**
+         * <code>optional uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        long getVid();
+
+        /**
+         * <code>optional bool override = 3;</code>
+         * @return Whether the override field is set.
+         */
+        boolean hasOverride();
+        /**
+         * <code>optional bool override = 3;</code>
+         * @return The override.
+         */
+        boolean getOverride();
+    }
+    /**
+     * <pre>
+     * Path of the object to take a snapshot of. Name is the name of the
+     * snapshot. If vid is not specified, the latest version is used.
+     * </pre>
+     *
+     * Protobuf type {@code SnapshotRequest}
+     */
+    public static final class SnapshotRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:SnapshotRequest)
+            SnapshotRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use SnapshotRequest.newBuilder() to construct.
+        private SnapshotRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private SnapshotRequest() {
+            name_ = "";
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new SnapshotRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_SnapshotRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_SnapshotRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.SnapshotRequest.class, Grpccatalog.SnapshotRequest.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int NAME_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object name_ = "";
+        /**
+         * <code>string name = 1;</code>
+         * @return The name.
+         */
+        @java.lang.Override
+        public java.lang.String getName() {
+            java.lang.Object ref = name_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                name_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>string name = 1;</code>
+         * @return The bytes for name.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getNameBytes() {
+            java.lang.Object ref = name_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                name_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int VID_FIELD_NUMBER = 2;
+        private long vid_ = 0L;
+        /**
+         * <code>optional uint64 vid = 2;</code>
+         * @return Whether the vid field is set.
+         */
+        @java.lang.Override
+        public boolean hasVid() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        public static final int OVERRIDE_FIELD_NUMBER = 3;
+        private boolean override_ = false;
+        /**
+         * <code>optional bool override = 3;</code>
+         * @return Whether the override field is set.
+         */
+        @java.lang.Override
+        public boolean hasOverride() {
+            return ((bitField0_ & 0x00000002) != 0);
+        }
+        /**
+         * <code>optional bool override = 3;</code>
+         * @return The override.
+         */
+        @java.lang.Override
+        public boolean getOverride() {
+            return override_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeUInt64(2, vid_);
+            }
+            if (((bitField0_ & 0x00000002) != 0)) {
+                output.writeBool(3, override_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, vid_);
+            }
+            if (((bitField0_ & 0x00000002) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(3, override_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.SnapshotRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.SnapshotRequest other = (Grpccatalog.SnapshotRequest) obj;
+
+            if (!getName()
+                    .equals(other.getName())) return false;
+            if (hasVid() != other.hasVid()) return false;
+            if (hasVid()) {
+                if (getVid()
+                        != other.getVid()) return false;
+            }
+            if (hasOverride() != other.hasOverride()) return false;
+            if (hasOverride()) {
+                if (getOverride()
+                        != other.getOverride()) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + NAME_FIELD_NUMBER;
+            hash = (53 * hash) + getName().hashCode();
+            if (hasVid()) {
+                hash = (37 * hash) + VID_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                        getVid());
+            }
+            if (hasOverride()) {
+                hash = (37 * hash) + OVERRIDE_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                        getOverride());
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.SnapshotRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.SnapshotRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.SnapshotRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Path of the object to take a snapshot of. Name is the name of the
+         * snapshot. If vid is not specified, the latest version is used.
+         * </pre>
+         *
+         * Protobuf type {@code SnapshotRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:SnapshotRequest)
+                Grpccatalog.SnapshotRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_SnapshotRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_SnapshotRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.SnapshotRequest.class, Grpccatalog.SnapshotRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.SnapshotRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                name_ = "";
+                vid_ = 0L;
+                override_ = false;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_SnapshotRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.SnapshotRequest getDefaultInstanceForType() {
+                return Grpccatalog.SnapshotRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.SnapshotRequest build() {
+                Grpccatalog.SnapshotRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.SnapshotRequest buildPartial() {
+                Grpccatalog.SnapshotRequest result = new Grpccatalog.SnapshotRequest(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.SnapshotRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.name_ = name_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.vid_ = vid_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.override_ = override_;
+                    to_bitField0_ |= 0x00000002;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.SnapshotRequest) {
+                    return mergeFrom((Grpccatalog.SnapshotRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.SnapshotRequest other) {
+                if (other == Grpccatalog.SnapshotRequest.getDefaultInstance()) return this;
+                if (!other.getName().isEmpty()) {
+                    name_ = other.name_;
+                    bitField0_ |= 0x00000001;
+                    onChanged();
+                }
+                if (other.hasVid()) {
+                    setVid(other.getVid());
+                }
+                if (other.hasOverride()) {
+                    setOverride(other.getOverride());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                name_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            case 16: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            case 24: {
+                                override_ = input.readBool();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 24
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.lang.Object name_ = "";
+            /**
+             * <code>string name = 1;</code>
+             * @return The name.
+             */
+            public java.lang.String getName() {
+                java.lang.Object ref = name_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    name_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string name = 1;</code>
+             * @return The bytes for name.
+             */
+            public com.google.protobuf.ByteString
+            getNameBytes() {
+                java.lang.Object ref = name_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    name_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string name = 1;</code>
+             * @param value The name to set.
+             * @return This builder for chaining.
+             */
+            public Builder setName(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                name_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string name = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearName() {
+                name_ = getDefaultInstance().getName();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string name = 1;</code>
+             * @param value The bytes for name to set.
+             * @return This builder for chaining.
+             */
+            public Builder setNameBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                name_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>optional uint64 vid = 2;</code>
+             * @return Whether the vid field is set.
+             */
+            @java.lang.Override
+            public boolean hasVid() {
+                return ((bitField0_ & 0x00000002) != 0);
+            }
+            /**
+             * <code>optional uint64 vid = 2;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>optional uint64 vid = 2;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional uint64 vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private boolean override_ ;
+            /**
+             * <code>optional bool override = 3;</code>
+             * @return Whether the override field is set.
+             */
+            @java.lang.Override
+            public boolean hasOverride() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional bool override = 3;</code>
+             * @return The override.
+             */
+            @java.lang.Override
+            public boolean getOverride() {
+                return override_;
+            }
+            /**
+             * <code>optional bool override = 3;</code>
+             * @param value The override to set.
+             * @return This builder for chaining.
+             */
+            public Builder setOverride(boolean value) {
+
+                override_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional bool override = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearOverride() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                override_ = false;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:SnapshotRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:SnapshotRequest)
+        private static final Grpccatalog.SnapshotRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.SnapshotRequest();
+        }
+
+        public static Grpccatalog.SnapshotRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<SnapshotRequest>
+                PARSER = new com.google.protobuf.AbstractParser<SnapshotRequest>() {
+            @java.lang.Override
+            public SnapshotRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<SnapshotRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<SnapshotRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.SnapshotRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface SnapshotResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:SnapshotResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        long getVid();
+    }
+    /**
+     * <pre>
+     * Whether the operation was successful and the vid of the object,
+     * of which snapshot was created.
+     * </pre>
+     *
+     * Protobuf type {@code SnapshotResponse}
+     */
+    public static final class SnapshotResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:SnapshotResponse)
+            SnapshotResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use SnapshotResponse.newBuilder() to construct.
+        private SnapshotResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private SnapshotResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new SnapshotResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_SnapshotResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_SnapshotResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.SnapshotResponse.class, Grpccatalog.SnapshotResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        public static final int VID_FIELD_NUMBER = 2;
+        private long vid_ = 0L;
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            if (vid_ != 0L) {
+                output.writeUInt64(2, vid_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            if (vid_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, vid_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.SnapshotResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.SnapshotResponse other = (Grpccatalog.SnapshotResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (getVid()
+                    != other.getVid()) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (37 * hash) + VID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getVid());
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.SnapshotResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.SnapshotResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.SnapshotResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether the operation was successful and the vid of the object,
+         * of which snapshot was created.
+         * </pre>
+         *
+         * Protobuf type {@code SnapshotResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:SnapshotResponse)
+                Grpccatalog.SnapshotResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_SnapshotResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_SnapshotResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.SnapshotResponse.class, Grpccatalog.SnapshotResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.SnapshotResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                vid_ = 0L;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_SnapshotResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.SnapshotResponse getDefaultInstanceForType() {
+                return Grpccatalog.SnapshotResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.SnapshotResponse build() {
+                Grpccatalog.SnapshotResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.SnapshotResponse buildPartial() {
+                Grpccatalog.SnapshotResponse result = new Grpccatalog.SnapshotResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.SnapshotResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.vid_ = vid_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.SnapshotResponse) {
+                    return mergeFrom((Grpccatalog.SnapshotResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.SnapshotResponse other) {
+                if (other == Grpccatalog.SnapshotResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                if (other.getVid() != 0L) {
+                    setVid(other.getVid());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:SnapshotResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:SnapshotResponse)
+        private static final Grpccatalog.SnapshotResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.SnapshotResponse();
+        }
+
+        public static Grpccatalog.SnapshotResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<SnapshotResponse>
+                PARSER = new com.google.protobuf.AbstractParser<SnapshotResponse>() {
+            @java.lang.Override
+            public SnapshotResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<SnapshotResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<SnapshotResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.SnapshotResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface CloneRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:CloneRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>string src_path = 1;</code>
+         * @return The srcPath.
+         */
+        java.lang.String getSrcPath();
+        /**
+         * <code>string src_path = 1;</code>
+         * @return The bytes for srcPath.
+         */
+        com.google.protobuf.ByteString
+        getSrcPathBytes();
+
+        /**
+         * <code>string dest_path = 2;</code>
+         * @return The destPath.
+         */
+        java.lang.String getDestPath();
+        /**
+         * <code>string dest_path = 2;</code>
+         * @return The bytes for destPath.
+         */
+        com.google.protobuf.ByteString
+        getDestPathBytes();
+
+        /**
+         * <code>optional uint64 vid = 3;</code>
+         * @return Whether the vid field is set.
+         */
+        boolean hasVid();
+        /**
+         * <code>optional uint64 vid = 3;</code>
+         * @return The vid.
+         */
+        long getVid();
+    }
+    /**
+     * <pre>
+     * Source and destination paths of the object to be cloned. If
+     * vid is not given, the latest version is used.
+     * </pre>
+     *
+     * Protobuf type {@code CloneRequest}
+     */
+    public static final class CloneRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:CloneRequest)
+            CloneRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use CloneRequest.newBuilder() to construct.
+        private CloneRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private CloneRequest() {
+            srcPath_ = "";
+            destPath_ = "";
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new CloneRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_CloneRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_CloneRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.CloneRequest.class, Grpccatalog.CloneRequest.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int SRC_PATH_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object srcPath_ = "";
+        /**
+         * <code>string src_path = 1;</code>
+         * @return The srcPath.
+         */
+        @java.lang.Override
+        public java.lang.String getSrcPath() {
+            java.lang.Object ref = srcPath_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                srcPath_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>string src_path = 1;</code>
+         * @return The bytes for srcPath.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getSrcPathBytes() {
+            java.lang.Object ref = srcPath_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                srcPath_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int DEST_PATH_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object destPath_ = "";
+        /**
+         * <code>string dest_path = 2;</code>
+         * @return The destPath.
+         */
+        @java.lang.Override
+        public java.lang.String getDestPath() {
+            java.lang.Object ref = destPath_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                destPath_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>string dest_path = 2;</code>
+         * @return The bytes for destPath.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getDestPathBytes() {
+            java.lang.Object ref = destPath_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                destPath_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        public static final int VID_FIELD_NUMBER = 3;
+        private long vid_ = 0L;
+        /**
+         * <code>optional uint64 vid = 3;</code>
+         * @return Whether the vid field is set.
+         */
+        @java.lang.Override
+        public boolean hasVid() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional uint64 vid = 3;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(srcPath_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, srcPath_);
+            }
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destPath_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, destPath_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeUInt64(3, vid_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(srcPath_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, srcPath_);
+            }
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destPath_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, destPath_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(3, vid_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.CloneRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.CloneRequest other = (Grpccatalog.CloneRequest) obj;
+
+            if (!getSrcPath()
+                    .equals(other.getSrcPath())) return false;
+            if (!getDestPath()
+                    .equals(other.getDestPath())) return false;
+            if (hasVid() != other.hasVid()) return false;
+            if (hasVid()) {
+                if (getVid()
+                        != other.getVid()) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SRC_PATH_FIELD_NUMBER;
+            hash = (53 * hash) + getSrcPath().hashCode();
+            hash = (37 * hash) + DEST_PATH_FIELD_NUMBER;
+            hash = (53 * hash) + getDestPath().hashCode();
+            if (hasVid()) {
+                hash = (37 * hash) + VID_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                        getVid());
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.CloneRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CloneRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CloneRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CloneRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.CloneRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Source and destination paths of the object to be cloned. If
+         * vid is not given, the latest version is used.
+         * </pre>
+         *
+         * Protobuf type {@code CloneRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:CloneRequest)
+                Grpccatalog.CloneRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_CloneRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_CloneRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.CloneRequest.class, Grpccatalog.CloneRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.CloneRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                srcPath_ = "";
+                destPath_ = "";
+                vid_ = 0L;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_CloneRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CloneRequest getDefaultInstanceForType() {
+                return Grpccatalog.CloneRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CloneRequest build() {
+                Grpccatalog.CloneRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CloneRequest buildPartial() {
+                Grpccatalog.CloneRequest result = new Grpccatalog.CloneRequest(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.CloneRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.srcPath_ = srcPath_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.destPath_ = destPath_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.vid_ = vid_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.CloneRequest) {
+                    return mergeFrom((Grpccatalog.CloneRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.CloneRequest other) {
+                if (other == Grpccatalog.CloneRequest.getDefaultInstance()) return this;
+                if (!other.getSrcPath().isEmpty()) {
+                    srcPath_ = other.srcPath_;
+                    bitField0_ |= 0x00000001;
+                    onChanged();
+                }
+                if (!other.getDestPath().isEmpty()) {
+                    destPath_ = other.destPath_;
+                    bitField0_ |= 0x00000002;
+                    onChanged();
+                }
+                if (other.hasVid()) {
+                    setVid(other.getVid());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                srcPath_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            case 18: {
+                                destPath_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 18
+                            case 24: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 24
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.lang.Object srcPath_ = "";
+            /**
+             * <code>string src_path = 1;</code>
+             * @return The srcPath.
+             */
+            public java.lang.String getSrcPath() {
+                java.lang.Object ref = srcPath_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    srcPath_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string src_path = 1;</code>
+             * @return The bytes for srcPath.
+             */
+            public com.google.protobuf.ByteString
+            getSrcPathBytes() {
+                java.lang.Object ref = srcPath_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    srcPath_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string src_path = 1;</code>
+             * @param value The srcPath to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSrcPath(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                srcPath_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string src_path = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSrcPath() {
+                srcPath_ = getDefaultInstance().getSrcPath();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string src_path = 1;</code>
+             * @param value The bytes for srcPath to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSrcPathBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                srcPath_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+
+            private java.lang.Object destPath_ = "";
+            /**
+             * <code>string dest_path = 2;</code>
+             * @return The destPath.
+             */
+            public java.lang.String getDestPath() {
+                java.lang.Object ref = destPath_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    destPath_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string dest_path = 2;</code>
+             * @return The bytes for destPath.
+             */
+            public com.google.protobuf.ByteString
+            getDestPathBytes() {
+                java.lang.Object ref = destPath_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    destPath_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string dest_path = 2;</code>
+             * @param value The destPath to set.
+             * @return This builder for chaining.
+             */
+            public Builder setDestPath(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                destPath_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string dest_path = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearDestPath() {
+                destPath_ = getDefaultInstance().getDestPath();
+                bitField0_ = (bitField0_ & ~0x00000002);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string dest_path = 2;</code>
+             * @param value The bytes for destPath to set.
+             * @return This builder for chaining.
+             */
+            public Builder setDestPathBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                destPath_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>optional uint64 vid = 3;</code>
+             * @return Whether the vid field is set.
+             */
+            @java.lang.Override
+            public boolean hasVid() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional uint64 vid = 3;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>optional uint64 vid = 3;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional uint64 vid = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:CloneRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:CloneRequest)
+        private static final Grpccatalog.CloneRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.CloneRequest();
+        }
+
+        public static Grpccatalog.CloneRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<CloneRequest>
+                PARSER = new com.google.protobuf.AbstractParser<CloneRequest>() {
+            @java.lang.Override
+            public CloneRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<CloneRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<CloneRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.CloneRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface CloneResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:CloneResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        long getVid();
+    }
+    /**
+     * <pre>
+     * Whether the operation was successful and the vid of the cloned
+     * object.
+     * </pre>
+     *
+     * Protobuf type {@code CloneResponse}
+     */
+    public static final class CloneResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:CloneResponse)
+            CloneResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use CloneResponse.newBuilder() to construct.
+        private CloneResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private CloneResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new CloneResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_CloneResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_CloneResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.CloneResponse.class, Grpccatalog.CloneResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        public static final int VID_FIELD_NUMBER = 2;
+        private long vid_ = 0L;
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            if (vid_ != 0L) {
+                output.writeUInt64(2, vid_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            if (vid_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, vid_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.CloneResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.CloneResponse other = (Grpccatalog.CloneResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (getVid()
+                    != other.getVid()) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (37 * hash) + VID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getVid());
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.CloneResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CloneResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CloneResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CloneResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.CloneResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether the operation was successful and the vid of the cloned
+         * object.
+         * </pre>
+         *
+         * Protobuf type {@code CloneResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:CloneResponse)
+                Grpccatalog.CloneResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_CloneResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_CloneResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.CloneResponse.class, Grpccatalog.CloneResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.CloneResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                vid_ = 0L;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_CloneResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CloneResponse getDefaultInstanceForType() {
+                return Grpccatalog.CloneResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CloneResponse build() {
+                Grpccatalog.CloneResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CloneResponse buildPartial() {
+                Grpccatalog.CloneResponse result = new Grpccatalog.CloneResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.CloneResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.vid_ = vid_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.CloneResponse) {
+                    return mergeFrom((Grpccatalog.CloneResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.CloneResponse other) {
+                if (other == Grpccatalog.CloneResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                if (other.getVid() != 0L) {
+                    setVid(other.getVid());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:CloneResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:CloneResponse)
+        private static final Grpccatalog.CloneResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.CloneResponse();
+        }
+
+        public static Grpccatalog.CloneResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<CloneResponse>
+                PARSER = new com.google.protobuf.AbstractParser<CloneResponse>() {
+            @java.lang.Override
+            public CloneResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<CloneResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<CloneResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.CloneResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface GetGarbageRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:GetGarbageRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>string path = 1;</code>
+         * @return The path.
+         */
+        java.lang.String getPath();
+        /**
+         * <code>string path = 1;</code>
+         * @return The bytes for path.
+         */
+        com.google.protobuf.ByteString
+        getPathBytes();
+    }
+    /**
+     * <pre>
+     * Path of the object for which garbage is to be collected.
+     * </pre>
+     *
+     * Protobuf type {@code GetGarbageRequest}
+     */
+    public static final class GetGarbageRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:GetGarbageRequest)
+            GetGarbageRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use GetGarbageRequest.newBuilder() to construct.
+        private GetGarbageRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private GetGarbageRequest() {
+            path_ = "";
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new GetGarbageRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_GetGarbageRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_GetGarbageRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.GetGarbageRequest.class, Grpccatalog.GetGarbageRequest.Builder.class);
+        }
+
+        public static final int PATH_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private volatile java.lang.Object path_ = "";
+        /**
+         * <code>string path = 1;</code>
+         * @return The path.
+         */
+        @java.lang.Override
+        public java.lang.String getPath() {
+            java.lang.Object ref = path_;
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                path_ = s;
+                return s;
+            }
+        }
+        /**
+         * <code>string path = 1;</code>
+         * @return The bytes for path.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString
+        getPathBytes() {
+            java.lang.Object ref = path_;
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                path_ = b;
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(path_)) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, path_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(path_)) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, path_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.GetGarbageRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.GetGarbageRequest other = (Grpccatalog.GetGarbageRequest) obj;
+
+            if (!getPath()
+                    .equals(other.getPath())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + PATH_FIELD_NUMBER;
+            hash = (53 * hash) + getPath().hashCode();
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.GetGarbageRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.GetGarbageRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.GetGarbageRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Path of the object for which garbage is to be collected.
+         * </pre>
+         *
+         * Protobuf type {@code GetGarbageRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:GetGarbageRequest)
+                Grpccatalog.GetGarbageRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_GetGarbageRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_GetGarbageRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.GetGarbageRequest.class, Grpccatalog.GetGarbageRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.GetGarbageRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                path_ = "";
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_GetGarbageRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.GetGarbageRequest getDefaultInstanceForType() {
+                return Grpccatalog.GetGarbageRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.GetGarbageRequest build() {
+                Grpccatalog.GetGarbageRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.GetGarbageRequest buildPartial() {
+                Grpccatalog.GetGarbageRequest result = new Grpccatalog.GetGarbageRequest(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.GetGarbageRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.path_ = path_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.GetGarbageRequest) {
+                    return mergeFrom((Grpccatalog.GetGarbageRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.GetGarbageRequest other) {
+                if (other == Grpccatalog.GetGarbageRequest.getDefaultInstance()) return this;
+                if (!other.getPath().isEmpty()) {
+                    path_ = other.path_;
+                    bitField0_ |= 0x00000001;
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                path_ = input.readStringRequireUtf8();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.lang.Object path_ = "";
+            /**
+             * <code>string path = 1;</code>
+             * @return The path.
+             */
+            public java.lang.String getPath() {
+                java.lang.Object ref = path_;
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    path_ = s;
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string path = 1;</code>
+             * @return The bytes for path.
+             */
+            public com.google.protobuf.ByteString
+            getPathBytes() {
+                java.lang.Object ref = path_;
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    path_ = b;
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string path = 1;</code>
+             * @param value The path to set.
+             * @return This builder for chaining.
+             */
+            public Builder setPath(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                path_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string path = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearPath() {
+                path_ = getDefaultInstance().getPath();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string path = 1;</code>
+             * @param value The bytes for path to set.
+             * @return This builder for chaining.
+             */
+            public Builder setPathBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                path_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:GetGarbageRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:GetGarbageRequest)
+        private static final Grpccatalog.GetGarbageRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.GetGarbageRequest();
+        }
+
+        public static Grpccatalog.GetGarbageRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<GetGarbageRequest>
+                PARSER = new com.google.protobuf.AbstractParser<GetGarbageRequest>() {
+            @java.lang.Override
+            public GetGarbageRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<GetGarbageRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<GetGarbageRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.GetGarbageRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface GetGarbageResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:GetGarbageResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>repeated bytes garbage = 1;</code>
+         * @return A list containing the garbage.
+         */
+        java.util.List<com.google.protobuf.ByteString> getGarbageList();
+        /**
+         * <code>repeated bytes garbage = 1;</code>
+         * @return The count of garbage.
+         */
+        int getGarbageCount();
+        /**
+         * <code>repeated bytes garbage = 1;</code>
+         * @param index The index of the element to return.
+         * @return The garbage at the given index.
+         */
+        com.google.protobuf.ByteString getGarbage(int index);
+    }
+    /**
+     * <pre>
+     * Leaf objects that no longer belong to any active version of
+     * inner objects
+     * </pre>
+     *
+     * Protobuf type {@code GetGarbageResponse}
+     */
+    public static final class GetGarbageResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:GetGarbageResponse)
+            GetGarbageResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use GetGarbageResponse.newBuilder() to construct.
+        private GetGarbageResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private GetGarbageResponse() {
+            garbage_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new GetGarbageResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_GetGarbageResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_GetGarbageResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.GetGarbageResponse.class, Grpccatalog.GetGarbageResponse.Builder.class);
+        }
+
+        public static final int GARBAGE_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private java.util.List<com.google.protobuf.ByteString> garbage_;
+        /**
+         * <code>repeated bytes garbage = 1;</code>
+         * @return A list containing the garbage.
+         */
+        @java.lang.Override
+        public java.util.List<com.google.protobuf.ByteString>
+        getGarbageList() {
+            return garbage_;
+        }
+        /**
+         * <code>repeated bytes garbage = 1;</code>
+         * @return The count of garbage.
+         */
+        public int getGarbageCount() {
+            return garbage_.size();
+        }
+        /**
+         * <code>repeated bytes garbage = 1;</code>
+         * @param index The index of the element to return.
+         * @return The garbage at the given index.
+         */
+        public com.google.protobuf.ByteString getGarbage(int index) {
+            return garbage_.get(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            for (int i = 0; i < garbage_.size(); i++) {
+                output.writeBytes(1, garbage_.get(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            {
+                int dataSize = 0;
+                for (int i = 0; i < garbage_.size(); i++) {
+                    dataSize += com.google.protobuf.CodedOutputStream
+                            .computeBytesSizeNoTag(garbage_.get(i));
+                }
+                size += dataSize;
+                size += 1 * getGarbageList().size();
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.GetGarbageResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.GetGarbageResponse other = (Grpccatalog.GetGarbageResponse) obj;
+
+            if (!getGarbageList()
+                    .equals(other.getGarbageList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (getGarbageCount() > 0) {
+                hash = (37 * hash) + GARBAGE_FIELD_NUMBER;
+                hash = (53 * hash) + getGarbageList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.GetGarbageResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.GetGarbageResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.GetGarbageResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Leaf objects that no longer belong to any active version of
+         * inner objects
+         * </pre>
+         *
+         * Protobuf type {@code GetGarbageResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:GetGarbageResponse)
+                Grpccatalog.GetGarbageResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_GetGarbageResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_GetGarbageResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.GetGarbageResponse.class, Grpccatalog.GetGarbageResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.GetGarbageResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                garbage_ = java.util.Collections.emptyList();
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_GetGarbageResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.GetGarbageResponse getDefaultInstanceForType() {
+                return Grpccatalog.GetGarbageResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.GetGarbageResponse build() {
+                Grpccatalog.GetGarbageResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.GetGarbageResponse buildPartial() {
+                Grpccatalog.GetGarbageResponse result = new Grpccatalog.GetGarbageResponse(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.GetGarbageResponse result) {
+                if (((bitField0_ & 0x00000001) != 0)) {
+                    garbage_ = java.util.Collections.unmodifiableList(garbage_);
+                    bitField0_ = (bitField0_ & ~0x00000001);
+                }
+                result.garbage_ = garbage_;
+            }
+
+            private void buildPartial0(Grpccatalog.GetGarbageResponse result) {
+                int from_bitField0_ = bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.GetGarbageResponse) {
+                    return mergeFrom((Grpccatalog.GetGarbageResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.GetGarbageResponse other) {
+                if (other == Grpccatalog.GetGarbageResponse.getDefaultInstance()) return this;
+                if (!other.garbage_.isEmpty()) {
+                    if (garbage_.isEmpty()) {
+                        garbage_ = other.garbage_;
+                        bitField0_ = (bitField0_ & ~0x00000001);
+                    } else {
+                        ensureGarbageIsMutable();
+                        garbage_.addAll(other.garbage_);
+                    }
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                com.google.protobuf.ByteString v = input.readBytes();
+                                ensureGarbageIsMutable();
+                                garbage_.add(v);
+                                break;
+                            } // case 10
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.util.List<com.google.protobuf.ByteString> garbage_ = java.util.Collections.emptyList();
+            private void ensureGarbageIsMutable() {
+                if (!((bitField0_ & 0x00000001) != 0)) {
+                    garbage_ = new java.util.ArrayList<com.google.protobuf.ByteString>(garbage_);
+                    bitField0_ |= 0x00000001;
+                }
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @return A list containing the garbage.
+             */
+            public java.util.List<com.google.protobuf.ByteString>
+            getGarbageList() {
+                return ((bitField0_ & 0x00000001) != 0) ?
+                        java.util.Collections.unmodifiableList(garbage_) : garbage_;
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @return The count of garbage.
+             */
+            public int getGarbageCount() {
+                return garbage_.size();
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @param index The index of the element to return.
+             * @return The garbage at the given index.
+             */
+            public com.google.protobuf.ByteString getGarbage(int index) {
+                return garbage_.get(index);
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @param index The index to set the value at.
+             * @param value The garbage to set.
+             * @return This builder for chaining.
+             */
+            public Builder setGarbage(
+                    int index, com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureGarbageIsMutable();
+                garbage_.set(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @param value The garbage to add.
+             * @return This builder for chaining.
+             */
+            public Builder addGarbage(com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureGarbageIsMutable();
+                garbage_.add(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @param values The garbage to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllGarbage(
+                    java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
+                ensureGarbageIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, garbage_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated bytes garbage = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearGarbage() {
+                garbage_ = java.util.Collections.emptyList();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:GetGarbageResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:GetGarbageResponse)
+        private static final Grpccatalog.GetGarbageResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.GetGarbageResponse();
+        }
+
+        public static Grpccatalog.GetGarbageResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<GetGarbageResponse>
+                PARSER = new com.google.protobuf.AbstractParser<GetGarbageResponse>() {
+            @java.lang.Override
+            public GetGarbageResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<GetGarbageResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<GetGarbageResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.GetGarbageResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ClearGarbageRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ClearGarbageRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>repeated int64 pids = 1;</code>
+         * @return A list containing the pids.
+         */
+        java.util.List<java.lang.Long> getPidsList();
+        /**
+         * <code>repeated int64 pids = 1;</code>
+         * @return The count of pids.
+         */
+        int getPidsCount();
+        /**
+         * <code>repeated int64 pids = 1;</code>
+         * @param index The index of the element to return.
+         * @return The pids at the given index.
+         */
+        long getPids(int index);
+    }
+    /**
+     * <pre>
+     * Physical ID of leaf objects to be deleted.
+     * </pre>
+     *
+     * Protobuf type {@code ClearGarbageRequest}
+     */
+    public static final class ClearGarbageRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ClearGarbageRequest)
+            ClearGarbageRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ClearGarbageRequest.newBuilder() to construct.
+        private ClearGarbageRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ClearGarbageRequest() {
+            pids_ = emptyLongList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ClearGarbageRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ClearGarbageRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ClearGarbageRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ClearGarbageRequest.class, Grpccatalog.ClearGarbageRequest.Builder.class);
+        }
+
+        public static final int PIDS_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private com.google.protobuf.Internal.LongList pids_;
+        /**
+         * <code>repeated int64 pids = 1;</code>
+         * @return A list containing the pids.
+         */
+        @java.lang.Override
+        public java.util.List<java.lang.Long>
+        getPidsList() {
+            return pids_;
+        }
+        /**
+         * <code>repeated int64 pids = 1;</code>
+         * @return The count of pids.
+         */
+        public int getPidsCount() {
+            return pids_.size();
+        }
+        /**
+         * <code>repeated int64 pids = 1;</code>
+         * @param index The index of the element to return.
+         * @return The pids at the given index.
+         */
+        public long getPids(int index) {
+            return pids_.getLong(index);
+        }
+        private int pidsMemoizedSerializedSize = -1;
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            getSerializedSize();
+            if (getPidsList().size() > 0) {
+                output.writeUInt32NoTag(10);
+                output.writeUInt32NoTag(pidsMemoizedSerializedSize);
+            }
+            for (int i = 0; i < pids_.size(); i++) {
+                output.writeInt64NoTag(pids_.getLong(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            {
+                int dataSize = 0;
+                for (int i = 0; i < pids_.size(); i++) {
+                    dataSize += com.google.protobuf.CodedOutputStream
+                            .computeInt64SizeNoTag(pids_.getLong(i));
+                }
+                size += dataSize;
+                if (!getPidsList().isEmpty()) {
+                    size += 1;
+                    size += com.google.protobuf.CodedOutputStream
+                            .computeInt32SizeNoTag(dataSize);
+                }
+                pidsMemoizedSerializedSize = dataSize;
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ClearGarbageRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ClearGarbageRequest other = (Grpccatalog.ClearGarbageRequest) obj;
+
+            if (!getPidsList()
+                    .equals(other.getPidsList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (getPidsCount() > 0) {
+                hash = (37 * hash) + PIDS_FIELD_NUMBER;
+                hash = (53 * hash) + getPidsList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ClearGarbageRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ClearGarbageRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Physical ID of leaf objects to be deleted.
+         * </pre>
+         *
+         * Protobuf type {@code ClearGarbageRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ClearGarbageRequest)
+                Grpccatalog.ClearGarbageRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ClearGarbageRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ClearGarbageRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ClearGarbageRequest.class, Grpccatalog.ClearGarbageRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ClearGarbageRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                pids_ = emptyLongList();
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ClearGarbageRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ClearGarbageRequest getDefaultInstanceForType() {
+                return Grpccatalog.ClearGarbageRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ClearGarbageRequest build() {
+                Grpccatalog.ClearGarbageRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ClearGarbageRequest buildPartial() {
+                Grpccatalog.ClearGarbageRequest result = new Grpccatalog.ClearGarbageRequest(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.ClearGarbageRequest result) {
+                if (((bitField0_ & 0x00000001) != 0)) {
+                    pids_.makeImmutable();
+                    bitField0_ = (bitField0_ & ~0x00000001);
+                }
+                result.pids_ = pids_;
+            }
+
+            private void buildPartial0(Grpccatalog.ClearGarbageRequest result) {
+                int from_bitField0_ = bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ClearGarbageRequest) {
+                    return mergeFrom((Grpccatalog.ClearGarbageRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ClearGarbageRequest other) {
+                if (other == Grpccatalog.ClearGarbageRequest.getDefaultInstance()) return this;
+                if (!other.pids_.isEmpty()) {
+                    if (pids_.isEmpty()) {
+                        pids_ = other.pids_;
+                        bitField0_ = (bitField0_ & ~0x00000001);
+                    } else {
+                        ensurePidsIsMutable();
+                        pids_.addAll(other.pids_);
+                    }
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                long v = input.readInt64();
+                                ensurePidsIsMutable();
+                                pids_.addLong(v);
+                                break;
+                            } // case 8
+                            case 10: {
+                                int length = input.readRawVarint32();
+                                int limit = input.pushLimit(length);
+                                ensurePidsIsMutable();
+                                while (input.getBytesUntilLimit() > 0) {
+                                    pids_.addLong(input.readInt64());
+                                }
+                                input.popLimit(limit);
+                                break;
+                            } // case 10
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private com.google.protobuf.Internal.LongList pids_ = emptyLongList();
+            private void ensurePidsIsMutable() {
+                if (!((bitField0_ & 0x00000001) != 0)) {
+                    pids_ = mutableCopy(pids_);
+                    bitField0_ |= 0x00000001;
+                }
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @return A list containing the pids.
+             */
+            public java.util.List<java.lang.Long>
+            getPidsList() {
+                return ((bitField0_ & 0x00000001) != 0) ?
+                        java.util.Collections.unmodifiableList(pids_) : pids_;
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @return The count of pids.
+             */
+            public int getPidsCount() {
+                return pids_.size();
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @param index The index of the element to return.
+             * @return The pids at the given index.
+             */
+            public long getPids(int index) {
+                return pids_.getLong(index);
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @param index The index to set the value at.
+             * @param value The pids to set.
+             * @return This builder for chaining.
+             */
+            public Builder setPids(
+                    int index, long value) {
+
+                ensurePidsIsMutable();
+                pids_.setLong(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @param value The pids to add.
+             * @return This builder for chaining.
+             */
+            public Builder addPids(long value) {
+
+                ensurePidsIsMutable();
+                pids_.addLong(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @param values The pids to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllPids(
+                    java.lang.Iterable<? extends java.lang.Long> values) {
+                ensurePidsIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, pids_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated int64 pids = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearPids() {
+                pids_ = emptyLongList();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ClearGarbageRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:ClearGarbageRequest)
+        private static final Grpccatalog.ClearGarbageRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ClearGarbageRequest();
+        }
+
+        public static Grpccatalog.ClearGarbageRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ClearGarbageRequest>
+                PARSER = new com.google.protobuf.AbstractParser<ClearGarbageRequest>() {
+            @java.lang.Override
+            public ClearGarbageRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ClearGarbageRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ClearGarbageRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ClearGarbageRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ClearGarbageResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ClearGarbageResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+    }
+    /**
+     * <pre>
+     * Whether leaf objects were safely deleted.
+     * </pre>
+     *
+     * Protobuf type {@code ClearGarbageResponse}
+     */
+    public static final class ClearGarbageResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ClearGarbageResponse)
+            ClearGarbageResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ClearGarbageResponse.newBuilder() to construct.
+        private ClearGarbageResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ClearGarbageResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ClearGarbageResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ClearGarbageResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ClearGarbageResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ClearGarbageResponse.class, Grpccatalog.ClearGarbageResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ClearGarbageResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ClearGarbageResponse other = (Grpccatalog.ClearGarbageResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ClearGarbageResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ClearGarbageResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether leaf objects were safely deleted.
+         * </pre>
+         *
+         * Protobuf type {@code ClearGarbageResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ClearGarbageResponse)
+                Grpccatalog.ClearGarbageResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ClearGarbageResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ClearGarbageResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ClearGarbageResponse.class, Grpccatalog.ClearGarbageResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ClearGarbageResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ClearGarbageResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ClearGarbageResponse getDefaultInstanceForType() {
+                return Grpccatalog.ClearGarbageResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ClearGarbageResponse build() {
+                Grpccatalog.ClearGarbageResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ClearGarbageResponse buildPartial() {
+                Grpccatalog.ClearGarbageResponse result = new Grpccatalog.ClearGarbageResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ClearGarbageResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ClearGarbageResponse) {
+                    return mergeFrom((Grpccatalog.ClearGarbageResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ClearGarbageResponse other) {
+                if (other == Grpccatalog.ClearGarbageResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ClearGarbageResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:ClearGarbageResponse)
+        private static final Grpccatalog.ClearGarbageResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ClearGarbageResponse();
+        }
+
+        public static Grpccatalog.ClearGarbageResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ClearGarbageResponse>
+                PARSER = new com.google.protobuf.AbstractParser<ClearGarbageResponse>() {
+            @java.lang.Override
+            public ClearGarbageResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ClearGarbageResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ClearGarbageResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ClearGarbageResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface DefineTypeRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:DefineTypeRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>.ObjTypeDef type_def = 1;</code>
+         * @return Whether the typeDef field is set.
+         */
+        boolean hasTypeDef();
+        /**
+         * <code>.ObjTypeDef type_def = 1;</code>
+         * @return The typeDef.
+         */
+        Grpccatalog.ObjTypeDef getTypeDef();
+        /**
+         * <code>.ObjTypeDef type_def = 1;</code>
+         */
+        Grpccatalog.ObjTypeDefOrBuilder getTypeDefOrBuilder();
+    }
+    /**
+     * <pre>
+     * Type definition, defined by the caller/user.
+     * </pre>
+     *
+     * Protobuf type {@code DefineTypeRequest}
+     */
+    public static final class DefineTypeRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:DefineTypeRequest)
+            DefineTypeRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use DefineTypeRequest.newBuilder() to construct.
+        private DefineTypeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private DefineTypeRequest() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new DefineTypeRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_DefineTypeRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_DefineTypeRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.DefineTypeRequest.class, Grpccatalog.DefineTypeRequest.Builder.class);
+        }
+
+        public static final int TYPE_DEF_FIELD_NUMBER = 1;
+        private Grpccatalog.ObjTypeDef typeDef_;
+        /**
+         * <code>.ObjTypeDef type_def = 1;</code>
+         * @return Whether the typeDef field is set.
+         */
+        @java.lang.Override
+        public boolean hasTypeDef() {
+            return typeDef_ != null;
+        }
+        /**
+         * <code>.ObjTypeDef type_def = 1;</code>
+         * @return The typeDef.
+         */
+        @java.lang.Override
+        public Grpccatalog.ObjTypeDef getTypeDef() {
+            return typeDef_ == null ? Grpccatalog.ObjTypeDef.getDefaultInstance() : typeDef_;
+        }
+        /**
+         * <code>.ObjTypeDef type_def = 1;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.ObjTypeDefOrBuilder getTypeDefOrBuilder() {
+            return typeDef_ == null ? Grpccatalog.ObjTypeDef.getDefaultInstance() : typeDef_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (typeDef_ != null) {
+                output.writeMessage(1, getTypeDef());
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (typeDef_ != null) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(1, getTypeDef());
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.DefineTypeRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.DefineTypeRequest other = (Grpccatalog.DefineTypeRequest) obj;
+
+            if (hasTypeDef() != other.hasTypeDef()) return false;
+            if (hasTypeDef()) {
+                if (!getTypeDef()
+                        .equals(other.getTypeDef())) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (hasTypeDef()) {
+                hash = (37 * hash) + TYPE_DEF_FIELD_NUMBER;
+                hash = (53 * hash) + getTypeDef().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.DefineTypeRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.DefineTypeRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.DefineTypeRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Type definition, defined by the caller/user.
+         * </pre>
+         *
+         * Protobuf type {@code DefineTypeRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:DefineTypeRequest)
+                Grpccatalog.DefineTypeRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_DefineTypeRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_DefineTypeRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.DefineTypeRequest.class, Grpccatalog.DefineTypeRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.DefineTypeRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                typeDef_ = null;
+                if (typeDefBuilder_ != null) {
+                    typeDefBuilder_.dispose();
+                    typeDefBuilder_ = null;
+                }
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_DefineTypeRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.DefineTypeRequest getDefaultInstanceForType() {
+                return Grpccatalog.DefineTypeRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.DefineTypeRequest build() {
+                Grpccatalog.DefineTypeRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.DefineTypeRequest buildPartial() {
+                Grpccatalog.DefineTypeRequest result = new Grpccatalog.DefineTypeRequest(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.DefineTypeRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.typeDef_ = typeDefBuilder_ == null
+                            ? typeDef_
+                            : typeDefBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.DefineTypeRequest) {
+                    return mergeFrom((Grpccatalog.DefineTypeRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.DefineTypeRequest other) {
+                if (other == Grpccatalog.DefineTypeRequest.getDefaultInstance()) return this;
+                if (other.hasTypeDef()) {
+                    mergeTypeDef(other.getTypeDef());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                input.readMessage(
+                                        getTypeDefFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 10
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private Grpccatalog.ObjTypeDef typeDef_;
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ObjTypeDef, Grpccatalog.ObjTypeDef.Builder, Grpccatalog.ObjTypeDefOrBuilder> typeDefBuilder_;
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             * @return Whether the typeDef field is set.
+             */
+            public boolean hasTypeDef() {
+                return ((bitField0_ & 0x00000001) != 0);
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             * @return The typeDef.
+             */
+            public Grpccatalog.ObjTypeDef getTypeDef() {
+                if (typeDefBuilder_ == null) {
+                    return typeDef_ == null ? Grpccatalog.ObjTypeDef.getDefaultInstance() : typeDef_;
+                } else {
+                    return typeDefBuilder_.getMessage();
+                }
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            public Builder setTypeDef(Grpccatalog.ObjTypeDef value) {
+                if (typeDefBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    typeDef_ = value;
+                } else {
+                    typeDefBuilder_.setMessage(value);
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            public Builder setTypeDef(
+                    Grpccatalog.ObjTypeDef.Builder builderForValue) {
+                if (typeDefBuilder_ == null) {
+                    typeDef_ = builderForValue.build();
+                } else {
+                    typeDefBuilder_.setMessage(builderForValue.build());
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            public Builder mergeTypeDef(Grpccatalog.ObjTypeDef value) {
+                if (typeDefBuilder_ == null) {
+                    if (((bitField0_ & 0x00000001) != 0) &&
+                            typeDef_ != null &&
+                            typeDef_ != Grpccatalog.ObjTypeDef.getDefaultInstance()) {
+                        getTypeDefBuilder().mergeFrom(value);
+                    } else {
+                        typeDef_ = value;
+                    }
+                } else {
+                    typeDefBuilder_.mergeFrom(value);
+                }
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            public Builder clearTypeDef() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                typeDef_ = null;
+                if (typeDefBuilder_ != null) {
+                    typeDefBuilder_.dispose();
+                    typeDefBuilder_ = null;
+                }
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            public Grpccatalog.ObjTypeDef.Builder getTypeDefBuilder() {
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return getTypeDefFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            public Grpccatalog.ObjTypeDefOrBuilder getTypeDefOrBuilder() {
+                if (typeDefBuilder_ != null) {
+                    return typeDefBuilder_.getMessageOrBuilder();
+                } else {
+                    return typeDef_ == null ?
+                            Grpccatalog.ObjTypeDef.getDefaultInstance() : typeDef_;
+                }
+            }
+            /**
+             * <code>.ObjTypeDef type_def = 1;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.ObjTypeDef, Grpccatalog.ObjTypeDef.Builder, Grpccatalog.ObjTypeDefOrBuilder>
+            getTypeDefFieldBuilder() {
+                if (typeDefBuilder_ == null) {
+                    typeDefBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.ObjTypeDef, Grpccatalog.ObjTypeDef.Builder, Grpccatalog.ObjTypeDefOrBuilder>(
+                            getTypeDef(),
+                            getParentForChildren(),
+                            isClean());
+                    typeDef_ = null;
+                }
+                return typeDefBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:DefineTypeRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:DefineTypeRequest)
+        private static final Grpccatalog.DefineTypeRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.DefineTypeRequest();
+        }
+
+        public static Grpccatalog.DefineTypeRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<DefineTypeRequest>
+                PARSER = new com.google.protobuf.AbstractParser<DefineTypeRequest>() {
+            @java.lang.Override
+            public DefineTypeRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<DefineTypeRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<DefineTypeRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.DefineTypeRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface DefineTypeResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:DefineTypeResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+    }
+    /**
+     * <pre>
+     * Whether type was successfully defined.
+     * </pre>
+     *
+     * Protobuf type {@code DefineTypeResponse}
+     */
+    public static final class DefineTypeResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:DefineTypeResponse)
+            DefineTypeResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use DefineTypeResponse.newBuilder() to construct.
+        private DefineTypeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private DefineTypeResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new DefineTypeResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_DefineTypeResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_DefineTypeResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.DefineTypeResponse.class, Grpccatalog.DefineTypeResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.DefineTypeResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.DefineTypeResponse other = (Grpccatalog.DefineTypeResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.DefineTypeResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.DefineTypeResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.DefineTypeResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether type was successfully defined.
+         * </pre>
+         *
+         * Protobuf type {@code DefineTypeResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:DefineTypeResponse)
+                Grpccatalog.DefineTypeResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_DefineTypeResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_DefineTypeResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.DefineTypeResponse.class, Grpccatalog.DefineTypeResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.DefineTypeResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_DefineTypeResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.DefineTypeResponse getDefaultInstanceForType() {
+                return Grpccatalog.DefineTypeResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.DefineTypeResponse build() {
+                Grpccatalog.DefineTypeResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.DefineTypeResponse buildPartial() {
+                Grpccatalog.DefineTypeResponse result = new Grpccatalog.DefineTypeResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.DefineTypeResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.DefineTypeResponse) {
+                    return mergeFrom((Grpccatalog.DefineTypeResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.DefineTypeResponse other) {
+                if (other == Grpccatalog.DefineTypeResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:DefineTypeResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:DefineTypeResponse)
+        private static final Grpccatalog.DefineTypeResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.DefineTypeResponse();
+        }
+
+        public static Grpccatalog.DefineTypeResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<DefineTypeResponse>
+                PARSER = new com.google.protobuf.AbstractParser<DefineTypeResponse>() {
+            @java.lang.Override
+            public DefineTypeResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<DefineTypeResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<DefineTypeResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.DefineTypeResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExecuteQueryRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExecuteQueryRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool base_only = 1;</code>
+         * @return The baseOnly.
+         */
+        boolean getBaseOnly();
+
+        /**
+         * <pre>
+         * vid is ignored if txn_id is set and valid
+         * </pre>
+         *
+         * <code>optional uint64 vid = 2;</code>
+         * @return Whether the vid field is set.
+         */
+        boolean hasVid();
+        /**
+         * <pre>
+         * vid is ignored if txn_id is set and valid
+         * </pre>
+         *
+         * <code>optional uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        long getVid();
+
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return Whether the txnId field is set.
+         */
+        boolean hasTxnId();
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return The txnId.
+         */
+        long getTxnId();
+
+        /**
+         * <code>optional uint32 return_type = 4;</code>
+         * @return Whether the returnType field is set.
+         */
+        boolean hasReturnType();
+        /**
+         * <code>optional uint32 return_type = 4;</code>
+         * @return The returnType.
+         */
+        int getReturnType();
+
+        /**
+         * <code>.PathExpr parse_tree = 5;</code>
+         * @return Whether the parseTree field is set.
+         */
+        boolean hasParseTree();
+        /**
+         * <code>.PathExpr parse_tree = 5;</code>
+         * @return The parseTree.
+         */
+        Grpccatalog.PathExpr getParseTree();
+        /**
+         * <code>.PathExpr parse_tree = 5;</code>
+         */
+        Grpccatalog.PathExprOrBuilder getParseTreeOrBuilder();
+
+        /**
+         * <code>string query_str = 6;</code>
+         * @return Whether the queryStr field is set.
+         */
+        boolean hasQueryStr();
+        /**
+         * <code>string query_str = 6;</code>
+         * @return The queryStr.
+         */
+        java.lang.String getQueryStr();
+        /**
+         * <code>string query_str = 6;</code>
+         * @return The bytes for queryStr.
+         */
+        com.google.protobuf.ByteString
+        getQueryStrBytes();
+
+        public Grpccatalog.ExecuteQueryRequest.QueryCase getQueryCase();
+    }
+    /**
+     * <pre>
+     * Query is either in a parse tree or string form.
+     * base specifies whether only base objects are to be returned
+     * </pre>
+     *
+     * Protobuf type {@code ExecuteQueryRequest}
+     */
+    public static final class ExecuteQueryRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExecuteQueryRequest)
+            ExecuteQueryRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExecuteQueryRequest.newBuilder() to construct.
+        private ExecuteQueryRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExecuteQueryRequest() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExecuteQueryRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExecuteQueryRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExecuteQueryRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExecuteQueryRequest.class, Grpccatalog.ExecuteQueryRequest.Builder.class);
+        }
+
+        private int bitField0_;
+        private int queryCase_ = 0;
+        private java.lang.Object query_;
+        public enum QueryCase
+                implements com.google.protobuf.Internal.EnumLite,
+                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
+            PARSE_TREE(5),
+            QUERY_STR(6),
+            QUERY_NOT_SET(0);
+            private final int value;
+            private QueryCase(int value) {
+                this.value = value;
+            }
+            /**
+             * @param value The number of the enum to look for.
+             * @return The enum associated with the given number.
+             * @deprecated Use {@link #forNumber(int)} instead.
+             */
+            @java.lang.Deprecated
+            public static QueryCase valueOf(int value) {
+                return forNumber(value);
+            }
+
+            public static QueryCase forNumber(int value) {
+                switch (value) {
+                    case 5: return PARSE_TREE;
+                    case 6: return QUERY_STR;
+                    case 0: return QUERY_NOT_SET;
+                    default: return null;
+                }
+            }
+            public int getNumber() {
+                return this.value;
+            }
+        };
+
+        public QueryCase
+        getQueryCase() {
+            return QueryCase.forNumber(
+                    queryCase_);
+        }
+
+        public static final int BASE_ONLY_FIELD_NUMBER = 1;
+        private boolean baseOnly_ = false;
+        /**
+         * <code>bool base_only = 1;</code>
+         * @return The baseOnly.
+         */
+        @java.lang.Override
+        public boolean getBaseOnly() {
+            return baseOnly_;
+        }
+
+        public static final int VID_FIELD_NUMBER = 2;
+        private long vid_ = 0L;
+        /**
+         * <pre>
+         * vid is ignored if txn_id is set and valid
+         * </pre>
+         *
+         * <code>optional uint64 vid = 2;</code>
+         * @return Whether the vid field is set.
+         */
+        @java.lang.Override
+        public boolean hasVid() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <pre>
+         * vid is ignored if txn_id is set and valid
+         * </pre>
+         *
+         * <code>optional uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        public static final int TXN_ID_FIELD_NUMBER = 3;
+        private long txnId_ = 0L;
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return Whether the txnId field is set.
+         */
+        @java.lang.Override
+        public boolean hasTxnId() {
+            return ((bitField0_ & 0x00000002) != 0);
+        }
+        /**
+         * <code>optional uint64 txn_id = 3;</code>
+         * @return The txnId.
+         */
+        @java.lang.Override
+        public long getTxnId() {
+            return txnId_;
+        }
+
+        public static final int RETURN_TYPE_FIELD_NUMBER = 4;
+        private int returnType_ = 0;
+        /**
+         * <code>optional uint32 return_type = 4;</code>
+         * @return Whether the returnType field is set.
+         */
+        @java.lang.Override
+        public boolean hasReturnType() {
+            return ((bitField0_ & 0x00000004) != 0);
+        }
+        /**
+         * <code>optional uint32 return_type = 4;</code>
+         * @return The returnType.
+         */
+        @java.lang.Override
+        public int getReturnType() {
+            return returnType_;
+        }
+
+        public static final int PARSE_TREE_FIELD_NUMBER = 5;
+        /**
+         * <code>.PathExpr parse_tree = 5;</code>
+         * @return Whether the parseTree field is set.
+         */
+        @java.lang.Override
+        public boolean hasParseTree() {
+            return queryCase_ == 5;
+        }
+        /**
+         * <code>.PathExpr parse_tree = 5;</code>
+         * @return The parseTree.
+         */
+        @java.lang.Override
+        public Grpccatalog.PathExpr getParseTree() {
+            if (queryCase_ == 5) {
+                return (Grpccatalog.PathExpr) query_;
+            }
+            return Grpccatalog.PathExpr.getDefaultInstance();
+        }
+        /**
+         * <code>.PathExpr parse_tree = 5;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.PathExprOrBuilder getParseTreeOrBuilder() {
+            if (queryCase_ == 5) {
+                return (Grpccatalog.PathExpr) query_;
+            }
+            return Grpccatalog.PathExpr.getDefaultInstance();
+        }
+
+        public static final int QUERY_STR_FIELD_NUMBER = 6;
+        /**
+         * <code>string query_str = 6;</code>
+         * @return Whether the queryStr field is set.
+         */
+        public boolean hasQueryStr() {
+            return queryCase_ == 6;
+        }
+        /**
+         * <code>string query_str = 6;</code>
+         * @return The queryStr.
+         */
+        public java.lang.String getQueryStr() {
+            java.lang.Object ref = "";
+            if (queryCase_ == 6) {
+                ref = query_;
+            }
+            if (ref instanceof java.lang.String) {
+                return (java.lang.String) ref;
+            } else {
+                com.google.protobuf.ByteString bs =
+                        (com.google.protobuf.ByteString) ref;
+                java.lang.String s = bs.toStringUtf8();
+                if (queryCase_ == 6) {
+                    query_ = s;
+                }
+                return s;
+            }
+        }
+        /**
+         * <code>string query_str = 6;</code>
+         * @return The bytes for queryStr.
+         */
+        public com.google.protobuf.ByteString
+        getQueryStrBytes() {
+            java.lang.Object ref = "";
+            if (queryCase_ == 6) {
+                ref = query_;
+            }
+            if (ref instanceof java.lang.String) {
+                com.google.protobuf.ByteString b =
+                        com.google.protobuf.ByteString.copyFromUtf8(
+                                (java.lang.String) ref);
+                if (queryCase_ == 6) {
+                    query_ = b;
+                }
+                return b;
+            } else {
+                return (com.google.protobuf.ByteString) ref;
+            }
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (baseOnly_ != false) {
+                output.writeBool(1, baseOnly_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeUInt64(2, vid_);
+            }
+            if (((bitField0_ & 0x00000002) != 0)) {
+                output.writeUInt64(3, txnId_);
+            }
+            if (((bitField0_ & 0x00000004) != 0)) {
+                output.writeUInt32(4, returnType_);
+            }
+            if (queryCase_ == 5) {
+                output.writeMessage(5, (Grpccatalog.PathExpr) query_);
+            }
+            if (queryCase_ == 6) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 6, query_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (baseOnly_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, baseOnly_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, vid_);
+            }
+            if (((bitField0_ & 0x00000002) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(3, txnId_);
+            }
+            if (((bitField0_ & 0x00000004) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt32Size(4, returnType_);
+            }
+            if (queryCase_ == 5) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(5, (Grpccatalog.PathExpr) query_);
+            }
+            if (queryCase_ == 6) {
+                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, query_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExecuteQueryRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExecuteQueryRequest other = (Grpccatalog.ExecuteQueryRequest) obj;
+
+            if (getBaseOnly()
+                    != other.getBaseOnly()) return false;
+            if (hasVid() != other.hasVid()) return false;
+            if (hasVid()) {
+                if (getVid()
+                        != other.getVid()) return false;
+            }
+            if (hasTxnId() != other.hasTxnId()) return false;
+            if (hasTxnId()) {
+                if (getTxnId()
+                        != other.getTxnId()) return false;
+            }
+            if (hasReturnType() != other.hasReturnType()) return false;
+            if (hasReturnType()) {
+                if (getReturnType()
+                        != other.getReturnType()) return false;
+            }
+            if (!getQueryCase().equals(other.getQueryCase())) return false;
+            switch (queryCase_) {
+                case 5:
+                    if (!getParseTree()
+                            .equals(other.getParseTree())) return false;
+                    break;
+                case 6:
+                    if (!getQueryStr()
+                            .equals(other.getQueryStr())) return false;
+                    break;
+                case 0:
+                default:
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + BASE_ONLY_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getBaseOnly());
+            if (hasVid()) {
+                hash = (37 * hash) + VID_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                        getVid());
+            }
+            if (hasTxnId()) {
+                hash = (37 * hash) + TXN_ID_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                        getTxnId());
+            }
+            if (hasReturnType()) {
+                hash = (37 * hash) + RETURN_TYPE_FIELD_NUMBER;
+                hash = (53 * hash) + getReturnType();
+            }
+            switch (queryCase_) {
+                case 5:
+                    hash = (37 * hash) + PARSE_TREE_FIELD_NUMBER;
+                    hash = (53 * hash) + getParseTree().hashCode();
+                    break;
+                case 6:
+                    hash = (37 * hash) + QUERY_STR_FIELD_NUMBER;
+                    hash = (53 * hash) + getQueryStr().hashCode();
+                    break;
+                case 0:
+                default:
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExecuteQueryRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExecuteQueryRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Query is either in a parse tree or string form.
+         * base specifies whether only base objects are to be returned
+         * </pre>
+         *
+         * Protobuf type {@code ExecuteQueryRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExecuteQueryRequest)
+                Grpccatalog.ExecuteQueryRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExecuteQueryRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExecuteQueryRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExecuteQueryRequest.class, Grpccatalog.ExecuteQueryRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExecuteQueryRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                baseOnly_ = false;
+                vid_ = 0L;
+                txnId_ = 0L;
+                returnType_ = 0;
+                if (parseTreeBuilder_ != null) {
+                    parseTreeBuilder_.clear();
+                }
+                queryCase_ = 0;
+                query_ = null;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExecuteQueryRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExecuteQueryRequest getDefaultInstanceForType() {
+                return Grpccatalog.ExecuteQueryRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExecuteQueryRequest build() {
+                Grpccatalog.ExecuteQueryRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExecuteQueryRequest buildPartial() {
+                Grpccatalog.ExecuteQueryRequest result = new Grpccatalog.ExecuteQueryRequest(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                buildPartialOneofs(result);
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ExecuteQueryRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.baseOnly_ = baseOnly_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.vid_ = vid_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.txnId_ = txnId_;
+                    to_bitField0_ |= 0x00000002;
+                }
+                if (((from_bitField0_ & 0x00000008) != 0)) {
+                    result.returnType_ = returnType_;
+                    to_bitField0_ |= 0x00000004;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            private void buildPartialOneofs(Grpccatalog.ExecuteQueryRequest result) {
+                result.queryCase_ = queryCase_;
+                result.query_ = this.query_;
+                if (queryCase_ == 5 &&
+                        parseTreeBuilder_ != null) {
+                    result.query_ = parseTreeBuilder_.build();
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExecuteQueryRequest) {
+                    return mergeFrom((Grpccatalog.ExecuteQueryRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExecuteQueryRequest other) {
+                if (other == Grpccatalog.ExecuteQueryRequest.getDefaultInstance()) return this;
+                if (other.getBaseOnly() != false) {
+                    setBaseOnly(other.getBaseOnly());
+                }
+                if (other.hasVid()) {
+                    setVid(other.getVid());
+                }
+                if (other.hasTxnId()) {
+                    setTxnId(other.getTxnId());
+                }
+                if (other.hasReturnType()) {
+                    setReturnType(other.getReturnType());
+                }
+                switch (other.getQueryCase()) {
+                    case PARSE_TREE: {
+                        mergeParseTree(other.getParseTree());
+                        break;
+                    }
+                    case QUERY_STR: {
+                        queryCase_ = 6;
+                        query_ = other.query_;
+                        onChanged();
+                        break;
+                    }
+                    case QUERY_NOT_SET: {
+                        break;
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                baseOnly_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            case 24: {
+                                txnId_ = input.readUInt64();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 24
+                            case 32: {
+                                returnType_ = input.readUInt32();
+                                bitField0_ |= 0x00000008;
+                                break;
+                            } // case 32
+                            case 42: {
+                                input.readMessage(
+                                        getParseTreeFieldBuilder().getBuilder(),
+                                        extensionRegistry);
+                                queryCase_ = 5;
+                                break;
+                            } // case 42
+                            case 50: {
+                                java.lang.String s = input.readStringRequireUtf8();
+                                queryCase_ = 6;
+                                query_ = s;
+                                break;
+                            } // case 50
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int queryCase_ = 0;
+            private java.lang.Object query_;
+            public QueryCase
+            getQueryCase() {
+                return QueryCase.forNumber(
+                        queryCase_);
+            }
+
+            public Builder clearQuery() {
+                queryCase_ = 0;
+                query_ = null;
+                onChanged();
+                return this;
+            }
+
+            private int bitField0_;
+
+            private boolean baseOnly_ ;
+            /**
+             * <code>bool base_only = 1;</code>
+             * @return The baseOnly.
+             */
+            @java.lang.Override
+            public boolean getBaseOnly() {
+                return baseOnly_;
+            }
+            /**
+             * <code>bool base_only = 1;</code>
+             * @param value The baseOnly to set.
+             * @return This builder for chaining.
+             */
+            public Builder setBaseOnly(boolean value) {
+
+                baseOnly_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool base_only = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearBaseOnly() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                baseOnly_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <pre>
+             * vid is ignored if txn_id is set and valid
+             * </pre>
+             *
+             * <code>optional uint64 vid = 2;</code>
+             * @return Whether the vid field is set.
+             */
+            @java.lang.Override
+            public boolean hasVid() {
+                return ((bitField0_ & 0x00000002) != 0);
+            }
+            /**
+             * <pre>
+             * vid is ignored if txn_id is set and valid
+             * </pre>
+             *
+             * <code>optional uint64 vid = 2;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <pre>
+             * vid is ignored if txn_id is set and valid
+             * </pre>
+             *
+             * <code>optional uint64 vid = 2;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <pre>
+             * vid is ignored if txn_id is set and valid
+             * </pre>
+             *
+             * <code>optional uint64 vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private long txnId_ ;
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @return Whether the txnId field is set.
+             */
+            @java.lang.Override
+            public boolean hasTxnId() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @return The txnId.
+             */
+            @java.lang.Override
+            public long getTxnId() {
+                return txnId_;
+            }
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @param value The txnId to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTxnId(long value) {
+
+                txnId_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional uint64 txn_id = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearTxnId() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                txnId_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private int returnType_ ;
+            /**
+             * <code>optional uint32 return_type = 4;</code>
+             * @return Whether the returnType field is set.
+             */
+            @java.lang.Override
+            public boolean hasReturnType() {
+                return ((bitField0_ & 0x00000008) != 0);
+            }
+            /**
+             * <code>optional uint32 return_type = 4;</code>
+             * @return The returnType.
+             */
+            @java.lang.Override
+            public int getReturnType() {
+                return returnType_;
+            }
+            /**
+             * <code>optional uint32 return_type = 4;</code>
+             * @param value The returnType to set.
+             * @return This builder for chaining.
+             */
+            public Builder setReturnType(int value) {
+
+                returnType_ = value;
+                bitField0_ |= 0x00000008;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional uint32 return_type = 4;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearReturnType() {
+                bitField0_ = (bitField0_ & ~0x00000008);
+                returnType_ = 0;
+                onChanged();
+                return this;
+            }
+
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.PathExpr, Grpccatalog.PathExpr.Builder, Grpccatalog.PathExprOrBuilder> parseTreeBuilder_;
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             * @return Whether the parseTree field is set.
+             */
+            @java.lang.Override
+            public boolean hasParseTree() {
+                return queryCase_ == 5;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             * @return The parseTree.
+             */
+            @java.lang.Override
+            public Grpccatalog.PathExpr getParseTree() {
+                if (parseTreeBuilder_ == null) {
+                    if (queryCase_ == 5) {
+                        return (Grpccatalog.PathExpr) query_;
+                    }
+                    return Grpccatalog.PathExpr.getDefaultInstance();
+                } else {
+                    if (queryCase_ == 5) {
+                        return parseTreeBuilder_.getMessage();
+                    }
+                    return Grpccatalog.PathExpr.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            public Builder setParseTree(Grpccatalog.PathExpr value) {
+                if (parseTreeBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    query_ = value;
+                    onChanged();
+                } else {
+                    parseTreeBuilder_.setMessage(value);
+                }
+                queryCase_ = 5;
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            public Builder setParseTree(
+                    Grpccatalog.PathExpr.Builder builderForValue) {
+                if (parseTreeBuilder_ == null) {
+                    query_ = builderForValue.build();
+                    onChanged();
+                } else {
+                    parseTreeBuilder_.setMessage(builderForValue.build());
+                }
+                queryCase_ = 5;
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            public Builder mergeParseTree(Grpccatalog.PathExpr value) {
+                if (parseTreeBuilder_ == null) {
+                    if (queryCase_ == 5 &&
+                            query_ != Grpccatalog.PathExpr.getDefaultInstance()) {
+                        query_ = Grpccatalog.PathExpr.newBuilder((Grpccatalog.PathExpr) query_)
+                                .mergeFrom(value).buildPartial();
+                    } else {
+                        query_ = value;
+                    }
+                    onChanged();
+                } else {
+                    if (queryCase_ == 5) {
+                        parseTreeBuilder_.mergeFrom(value);
+                    } else {
+                        parseTreeBuilder_.setMessage(value);
+                    }
+                }
+                queryCase_ = 5;
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            public Builder clearParseTree() {
+                if (parseTreeBuilder_ == null) {
+                    if (queryCase_ == 5) {
+                        queryCase_ = 0;
+                        query_ = null;
+                        onChanged();
+                    }
+                } else {
+                    if (queryCase_ == 5) {
+                        queryCase_ = 0;
+                        query_ = null;
+                    }
+                    parseTreeBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            public Grpccatalog.PathExpr.Builder getParseTreeBuilder() {
+                return getParseTreeFieldBuilder().getBuilder();
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            @java.lang.Override
+            public Grpccatalog.PathExprOrBuilder getParseTreeOrBuilder() {
+                if ((queryCase_ == 5) && (parseTreeBuilder_ != null)) {
+                    return parseTreeBuilder_.getMessageOrBuilder();
+                } else {
+                    if (queryCase_ == 5) {
+                        return (Grpccatalog.PathExpr) query_;
+                    }
+                    return Grpccatalog.PathExpr.getDefaultInstance();
+                }
+            }
+            /**
+             * <code>.PathExpr parse_tree = 5;</code>
+             */
+            private com.google.protobuf.SingleFieldBuilderV3<
+                    Grpccatalog.PathExpr, Grpccatalog.PathExpr.Builder, Grpccatalog.PathExprOrBuilder>
+            getParseTreeFieldBuilder() {
+                if (parseTreeBuilder_ == null) {
+                    if (!(queryCase_ == 5)) {
+                        query_ = Grpccatalog.PathExpr.getDefaultInstance();
+                    }
+                    parseTreeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
+                            Grpccatalog.PathExpr, Grpccatalog.PathExpr.Builder, Grpccatalog.PathExprOrBuilder>(
+                            (Grpccatalog.PathExpr) query_,
+                            getParentForChildren(),
+                            isClean());
+                    query_ = null;
+                }
+                queryCase_ = 5;
+                onChanged();
+                return parseTreeBuilder_;
+            }
+
+            /**
+             * <code>string query_str = 6;</code>
+             * @return Whether the queryStr field is set.
+             */
+            @java.lang.Override
+            public boolean hasQueryStr() {
+                return queryCase_ == 6;
+            }
+            /**
+             * <code>string query_str = 6;</code>
+             * @return The queryStr.
+             */
+            @java.lang.Override
+            public java.lang.String getQueryStr() {
+                java.lang.Object ref = "";
+                if (queryCase_ == 6) {
+                    ref = query_;
+                }
+                if (!(ref instanceof java.lang.String)) {
+                    com.google.protobuf.ByteString bs =
+                            (com.google.protobuf.ByteString) ref;
+                    java.lang.String s = bs.toStringUtf8();
+                    if (queryCase_ == 6) {
+                        query_ = s;
+                    }
+                    return s;
+                } else {
+                    return (java.lang.String) ref;
+                }
+            }
+            /**
+             * <code>string query_str = 6;</code>
+             * @return The bytes for queryStr.
+             */
+            @java.lang.Override
+            public com.google.protobuf.ByteString
+            getQueryStrBytes() {
+                java.lang.Object ref = "";
+                if (queryCase_ == 6) {
+                    ref = query_;
+                }
+                if (ref instanceof String) {
+                    com.google.protobuf.ByteString b =
+                            com.google.protobuf.ByteString.copyFromUtf8(
+                                    (java.lang.String) ref);
+                    if (queryCase_ == 6) {
+                        query_ = b;
+                    }
+                    return b;
+                } else {
+                    return (com.google.protobuf.ByteString) ref;
+                }
+            }
+            /**
+             * <code>string query_str = 6;</code>
+             * @param value The queryStr to set.
+             * @return This builder for chaining.
+             */
+            public Builder setQueryStr(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                queryCase_ = 6;
+                query_ = value;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>string query_str = 6;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearQueryStr() {
+                if (queryCase_ == 6) {
+                    queryCase_ = 0;
+                    query_ = null;
+                    onChanged();
+                }
+                return this;
+            }
+            /**
+             * <code>string query_str = 6;</code>
+             * @param value The bytes for queryStr to set.
+             * @return This builder for chaining.
+             */
+            public Builder setQueryStrBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                queryCase_ = 6;
+                query_ = value;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExecuteQueryRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExecuteQueryRequest)
+        private static final Grpccatalog.ExecuteQueryRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExecuteQueryRequest();
+        }
+
+        public static Grpccatalog.ExecuteQueryRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExecuteQueryRequest>
+                PARSER = new com.google.protobuf.AbstractParser<ExecuteQueryRequest>() {
+            @java.lang.Override
+            public ExecuteQueryRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExecuteQueryRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExecuteQueryRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExecuteQueryRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface ExecuteQueryResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:ExecuteQueryResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool leaf_obj = 1;</code>
+         * @return The leafObj.
+         */
+        boolean getLeafObj();
+
+        /**
+         * <code>bool base_only = 2;</code>
+         * @return The baseOnly.
+         */
+        boolean getBaseOnly();
+
+        /**
+         * <code>uint64 vid = 3;</code>
+         * @return The vid.
+         */
+        long getVid();
+
+        /**
+         * <code>bytes obj_list = 4;</code>
+         * @return The objList.
+         */
+        com.google.protobuf.ByteString getObjList();
+
+        /**
+         * <code>optional bool abort = 5;</code>
+         * @return Whether the abort field is set.
+         */
+        boolean hasAbort();
+        /**
+         * <code>optional bool abort = 5;</code>
+         * @return The abort.
+         */
+        boolean getAbort();
+
+        /**
+         * <code>.BufCompression compression = 6;</code>
+         * @return The enum numeric value on the wire for compression.
+         */
+        int getCompressionValue();
+        /**
+         * <code>.BufCompression compression = 6;</code>
+         * @return The compression.
+         */
+        Grpccatalog.BufCompression getCompression();
+    }
+    /**
+     * <pre>
+     * Query result is either a set of inner objects, leaf objects, or
+     * base objects.
+     * </pre>
+     *
+     * Protobuf type {@code ExecuteQueryResponse}
+     */
+    public static final class ExecuteQueryResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:ExecuteQueryResponse)
+            ExecuteQueryResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use ExecuteQueryResponse.newBuilder() to construct.
+        private ExecuteQueryResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private ExecuteQueryResponse() {
+            objList_ = com.google.protobuf.ByteString.EMPTY;
+            compression_ = 0;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new ExecuteQueryResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_ExecuteQueryResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_ExecuteQueryResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.ExecuteQueryResponse.class, Grpccatalog.ExecuteQueryResponse.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int LEAF_OBJ_FIELD_NUMBER = 1;
+        private boolean leafObj_ = false;
+        /**
+         * <code>bool leaf_obj = 1;</code>
+         * @return The leafObj.
+         */
+        @java.lang.Override
+        public boolean getLeafObj() {
+            return leafObj_;
+        }
+
+        public static final int BASE_ONLY_FIELD_NUMBER = 2;
+        private boolean baseOnly_ = false;
+        /**
+         * <code>bool base_only = 2;</code>
+         * @return The baseOnly.
+         */
+        @java.lang.Override
+        public boolean getBaseOnly() {
+            return baseOnly_;
+        }
+
+        public static final int VID_FIELD_NUMBER = 3;
+        private long vid_ = 0L;
+        /**
+         * <code>uint64 vid = 3;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        public static final int OBJ_LIST_FIELD_NUMBER = 4;
+        private com.google.protobuf.ByteString objList_ = com.google.protobuf.ByteString.EMPTY;
+        /**
+         * <code>bytes obj_list = 4;</code>
+         * @return The objList.
+         */
+        @java.lang.Override
+        public com.google.protobuf.ByteString getObjList() {
+            return objList_;
+        }
+
+        public static final int ABORT_FIELD_NUMBER = 5;
+        private boolean abort_ = false;
+        /**
+         * <code>optional bool abort = 5;</code>
+         * @return Whether the abort field is set.
+         */
+        @java.lang.Override
+        public boolean hasAbort() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional bool abort = 5;</code>
+         * @return The abort.
+         */
+        @java.lang.Override
+        public boolean getAbort() {
+            return abort_;
+        }
+
+        public static final int COMPRESSION_FIELD_NUMBER = 6;
+        private int compression_ = 0;
+        /**
+         * <code>.BufCompression compression = 6;</code>
+         * @return The enum numeric value on the wire for compression.
+         */
+        @java.lang.Override public int getCompressionValue() {
+            return compression_;
+        }
+        /**
+         * <code>.BufCompression compression = 6;</code>
+         * @return The compression.
+         */
+        @java.lang.Override public Grpccatalog.BufCompression getCompression() {
+            Grpccatalog.BufCompression result = Grpccatalog.BufCompression.forNumber(compression_);
+            return result == null ? Grpccatalog.BufCompression.UNRECOGNIZED : result;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (leafObj_ != false) {
+                output.writeBool(1, leafObj_);
+            }
+            if (baseOnly_ != false) {
+                output.writeBool(2, baseOnly_);
+            }
+            if (vid_ != 0L) {
+                output.writeUInt64(3, vid_);
+            }
+            if (!objList_.isEmpty()) {
+                output.writeBytes(4, objList_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeBool(5, abort_);
+            }
+            if (compression_ != Grpccatalog.BufCompression.BUF_NO_COMPRESSION.getNumber()) {
+                output.writeEnum(6, compression_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (leafObj_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, leafObj_);
+            }
+            if (baseOnly_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(2, baseOnly_);
+            }
+            if (vid_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(3, vid_);
+            }
+            if (!objList_.isEmpty()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBytesSize(4, objList_);
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(5, abort_);
+            }
+            if (compression_ != Grpccatalog.BufCompression.BUF_NO_COMPRESSION.getNumber()) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeEnumSize(6, compression_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.ExecuteQueryResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.ExecuteQueryResponse other = (Grpccatalog.ExecuteQueryResponse) obj;
+
+            if (getLeafObj()
+                    != other.getLeafObj()) return false;
+            if (getBaseOnly()
+                    != other.getBaseOnly()) return false;
+            if (getVid()
+                    != other.getVid()) return false;
+            if (!getObjList()
+                    .equals(other.getObjList())) return false;
+            if (hasAbort() != other.hasAbort()) return false;
+            if (hasAbort()) {
+                if (getAbort()
+                        != other.getAbort()) return false;
+            }
+            if (compression_ != other.compression_) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + LEAF_OBJ_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getLeafObj());
+            hash = (37 * hash) + BASE_ONLY_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getBaseOnly());
+            hash = (37 * hash) + VID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getVid());
+            hash = (37 * hash) + OBJ_LIST_FIELD_NUMBER;
+            hash = (53 * hash) + getObjList().hashCode();
+            if (hasAbort()) {
+                hash = (37 * hash) + ABORT_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                        getAbort());
+            }
+            hash = (37 * hash) + COMPRESSION_FIELD_NUMBER;
+            hash = (53 * hash) + compression_;
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.ExecuteQueryResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.ExecuteQueryResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Query result is either a set of inner objects, leaf objects, or
+         * base objects.
+         * </pre>
+         *
+         * Protobuf type {@code ExecuteQueryResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:ExecuteQueryResponse)
+                Grpccatalog.ExecuteQueryResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_ExecuteQueryResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_ExecuteQueryResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.ExecuteQueryResponse.class, Grpccatalog.ExecuteQueryResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.ExecuteQueryResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                leafObj_ = false;
+                baseOnly_ = false;
+                vid_ = 0L;
+                objList_ = com.google.protobuf.ByteString.EMPTY;
+                abort_ = false;
+                compression_ = 0;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_ExecuteQueryResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExecuteQueryResponse getDefaultInstanceForType() {
+                return Grpccatalog.ExecuteQueryResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExecuteQueryResponse build() {
+                Grpccatalog.ExecuteQueryResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.ExecuteQueryResponse buildPartial() {
+                Grpccatalog.ExecuteQueryResponse result = new Grpccatalog.ExecuteQueryResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.ExecuteQueryResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.leafObj_ = leafObj_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.baseOnly_ = baseOnly_;
+                }
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.vid_ = vid_;
+                }
+                if (((from_bitField0_ & 0x00000008) != 0)) {
+                    result.objList_ = objList_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000010) != 0)) {
+                    result.abort_ = abort_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                if (((from_bitField0_ & 0x00000020) != 0)) {
+                    result.compression_ = compression_;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.ExecuteQueryResponse) {
+                    return mergeFrom((Grpccatalog.ExecuteQueryResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.ExecuteQueryResponse other) {
+                if (other == Grpccatalog.ExecuteQueryResponse.getDefaultInstance()) return this;
+                if (other.getLeafObj() != false) {
+                    setLeafObj(other.getLeafObj());
+                }
+                if (other.getBaseOnly() != false) {
+                    setBaseOnly(other.getBaseOnly());
+                }
+                if (other.getVid() != 0L) {
+                    setVid(other.getVid());
+                }
+                if (other.getObjList() != com.google.protobuf.ByteString.EMPTY) {
+                    setObjList(other.getObjList());
+                }
+                if (other.hasAbort()) {
+                    setAbort(other.getAbort());
+                }
+                if (other.compression_ != 0) {
+                    setCompressionValue(other.getCompressionValue());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                leafObj_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                baseOnly_ = input.readBool();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            case 24: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 24
+                            case 34: {
+                                objList_ = input.readBytes();
+                                bitField0_ |= 0x00000008;
+                                break;
+                            } // case 34
+                            case 40: {
+                                abort_ = input.readBool();
+                                bitField0_ |= 0x00000010;
+                                break;
+                            } // case 40
+                            case 48: {
+                                compression_ = input.readEnum();
+                                bitField0_ |= 0x00000020;
+                                break;
+                            } // case 48
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean leafObj_ ;
+            /**
+             * <code>bool leaf_obj = 1;</code>
+             * @return The leafObj.
+             */
+            @java.lang.Override
+            public boolean getLeafObj() {
+                return leafObj_;
+            }
+            /**
+             * <code>bool leaf_obj = 1;</code>
+             * @param value The leafObj to set.
+             * @return This builder for chaining.
+             */
+            public Builder setLeafObj(boolean value) {
+
+                leafObj_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool leaf_obj = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearLeafObj() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                leafObj_ = false;
+                onChanged();
+                return this;
+            }
+
+            private boolean baseOnly_ ;
+            /**
+             * <code>bool base_only = 2;</code>
+             * @return The baseOnly.
+             */
+            @java.lang.Override
+            public boolean getBaseOnly() {
+                return baseOnly_;
+            }
+            /**
+             * <code>bool base_only = 2;</code>
+             * @param value The baseOnly to set.
+             * @return This builder for chaining.
+             */
+            public Builder setBaseOnly(boolean value) {
+
+                baseOnly_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool base_only = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearBaseOnly() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                baseOnly_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>uint64 vid = 3;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>uint64 vid = 3;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 vid = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private com.google.protobuf.ByteString objList_ = com.google.protobuf.ByteString.EMPTY;
+            /**
+             * <code>bytes obj_list = 4;</code>
+             * @return The objList.
+             */
+            @java.lang.Override
+            public com.google.protobuf.ByteString getObjList() {
+                return objList_;
+            }
+            /**
+             * <code>bytes obj_list = 4;</code>
+             * @param value The objList to set.
+             * @return This builder for chaining.
+             */
+            public Builder setObjList(com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                objList_ = value;
+                bitField0_ |= 0x00000008;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bytes obj_list = 4;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearObjList() {
+                bitField0_ = (bitField0_ & ~0x00000008);
+                objList_ = getDefaultInstance().getObjList();
+                onChanged();
+                return this;
+            }
+
+            private boolean abort_ ;
+            /**
+             * <code>optional bool abort = 5;</code>
+             * @return Whether the abort field is set.
+             */
+            @java.lang.Override
+            public boolean hasAbort() {
+                return ((bitField0_ & 0x00000010) != 0);
+            }
+            /**
+             * <code>optional bool abort = 5;</code>
+             * @return The abort.
+             */
+            @java.lang.Override
+            public boolean getAbort() {
+                return abort_;
+            }
+            /**
+             * <code>optional bool abort = 5;</code>
+             * @param value The abort to set.
+             * @return This builder for chaining.
+             */
+            public Builder setAbort(boolean value) {
+
+                abort_ = value;
+                bitField0_ |= 0x00000010;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional bool abort = 5;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearAbort() {
+                bitField0_ = (bitField0_ & ~0x00000010);
+                abort_ = false;
+                onChanged();
+                return this;
+            }
+
+            private int compression_ = 0;
+            /**
+             * <code>.BufCompression compression = 6;</code>
+             * @return The enum numeric value on the wire for compression.
+             */
+            @java.lang.Override public int getCompressionValue() {
+                return compression_;
+            }
+            /**
+             * <code>.BufCompression compression = 6;</code>
+             * @param value The enum numeric value on the wire for compression to set.
+             * @return This builder for chaining.
+             */
+            public Builder setCompressionValue(int value) {
+                compression_ = value;
+                bitField0_ |= 0x00000020;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.BufCompression compression = 6;</code>
+             * @return The compression.
+             */
+            @java.lang.Override
+            public Grpccatalog.BufCompression getCompression() {
+                Grpccatalog.BufCompression result = Grpccatalog.BufCompression.forNumber(compression_);
+                return result == null ? Grpccatalog.BufCompression.UNRECOGNIZED : result;
+            }
+            /**
+             * <code>.BufCompression compression = 6;</code>
+             * @param value The compression to set.
+             * @return This builder for chaining.
+             */
+            public Builder setCompression(Grpccatalog.BufCompression value) {
+                if (value == null) {
+                    throw new NullPointerException();
+                }
+                bitField0_ |= 0x00000020;
+                compression_ = value.getNumber();
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>.BufCompression compression = 6;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearCompression() {
+                bitField0_ = (bitField0_ & ~0x00000020);
+                compression_ = 0;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:ExecuteQueryResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:ExecuteQueryResponse)
+        private static final Grpccatalog.ExecuteQueryResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.ExecuteQueryResponse();
+        }
+
+        public static Grpccatalog.ExecuteQueryResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<ExecuteQueryResponse>
+                PARSER = new com.google.protobuf.AbstractParser<ExecuteQueryResponse>() {
+            @java.lang.Override
+            public ExecuteQueryResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<ExecuteQueryResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<ExecuteQueryResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.ExecuteQueryResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface CommitRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:CommitRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>uint64 txn_id = 1;</code>
+         * @return The txnId.
+         */
+        long getTxnId();
+
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        java.util.List<Grpccatalog.Write>
+        getWriteSetList();
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        Grpccatalog.Write getWriteSet(int index);
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        int getWriteSetCount();
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        java.util.List<? extends Grpccatalog.WriteOrBuilder>
+        getWriteSetOrBuilderList();
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        Grpccatalog.WriteOrBuilder getWriteSetOrBuilder(
+                int index);
+
+        /**
+         * <code>optional bool abort = 3;</code>
+         * @return Whether the abort field is set.
+         */
+        boolean hasAbort();
+        /**
+         * <code>optional bool abort = 3;</code>
+         * @return The abort.
+         */
+        boolean getAbort();
+    }
+    /**
+     * <pre>
+     * Default concurrency control mechanism is OCC for now.
+     * </pre>
+     *
+     * Protobuf type {@code CommitRequest}
+     */
+    public static final class CommitRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:CommitRequest)
+            CommitRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use CommitRequest.newBuilder() to construct.
+        private CommitRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private CommitRequest() {
+            writeSet_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new CommitRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_CommitRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_CommitRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.CommitRequest.class, Grpccatalog.CommitRequest.Builder.class);
+        }
+
+        private int bitField0_;
+        public static final int TXN_ID_FIELD_NUMBER = 1;
+        private long txnId_ = 0L;
+        /**
+         * <code>uint64 txn_id = 1;</code>
+         * @return The txnId.
+         */
+        @java.lang.Override
+        public long getTxnId() {
+            return txnId_;
+        }
+
+        public static final int WRITE_SET_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private java.util.List<Grpccatalog.Write> writeSet_;
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<Grpccatalog.Write> getWriteSetList() {
+            return writeSet_;
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<? extends Grpccatalog.WriteOrBuilder>
+        getWriteSetOrBuilderList() {
+            return writeSet_;
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public int getWriteSetCount() {
+            return writeSet_.size();
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.Write getWriteSet(int index) {
+            return writeSet_.get(index);
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.WriteOrBuilder getWriteSetOrBuilder(
+                int index) {
+            return writeSet_.get(index);
+        }
+
+        public static final int ABORT_FIELD_NUMBER = 3;
+        private boolean abort_ = false;
+        /**
+         * <code>optional bool abort = 3;</code>
+         * @return Whether the abort field is set.
+         */
+        @java.lang.Override
+        public boolean hasAbort() {
+            return ((bitField0_ & 0x00000001) != 0);
+        }
+        /**
+         * <code>optional bool abort = 3;</code>
+         * @return The abort.
+         */
+        @java.lang.Override
+        public boolean getAbort() {
+            return abort_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (txnId_ != 0L) {
+                output.writeUInt64(1, txnId_);
+            }
+            for (int i = 0; i < writeSet_.size(); i++) {
+                output.writeMessage(2, writeSet_.get(i));
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                output.writeBool(3, abort_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (txnId_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(1, txnId_);
+            }
+            for (int i = 0; i < writeSet_.size(); i++) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(2, writeSet_.get(i));
+            }
+            if (((bitField0_ & 0x00000001) != 0)) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(3, abort_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.CommitRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.CommitRequest other = (Grpccatalog.CommitRequest) obj;
+
+            if (getTxnId()
+                    != other.getTxnId()) return false;
+            if (!getWriteSetList()
+                    .equals(other.getWriteSetList())) return false;
+            if (hasAbort() != other.hasAbort()) return false;
+            if (hasAbort()) {
+                if (getAbort()
+                        != other.getAbort()) return false;
+            }
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + TXN_ID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getTxnId());
+            if (getWriteSetCount() > 0) {
+                hash = (37 * hash) + WRITE_SET_FIELD_NUMBER;
+                hash = (53 * hash) + getWriteSetList().hashCode();
+            }
+            if (hasAbort()) {
+                hash = (37 * hash) + ABORT_FIELD_NUMBER;
+                hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                        getAbort());
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.CommitRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CommitRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CommitRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CommitRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.CommitRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Default concurrency control mechanism is OCC for now.
+         * </pre>
+         *
+         * Protobuf type {@code CommitRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:CommitRequest)
+                Grpccatalog.CommitRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_CommitRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_CommitRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.CommitRequest.class, Grpccatalog.CommitRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.CommitRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                txnId_ = 0L;
+                if (writeSetBuilder_ == null) {
+                    writeSet_ = java.util.Collections.emptyList();
+                } else {
+                    writeSet_ = null;
+                    writeSetBuilder_.clear();
+                }
+                bitField0_ = (bitField0_ & ~0x00000002);
+                abort_ = false;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_CommitRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CommitRequest getDefaultInstanceForType() {
+                return Grpccatalog.CommitRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CommitRequest build() {
+                Grpccatalog.CommitRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CommitRequest buildPartial() {
+                Grpccatalog.CommitRequest result = new Grpccatalog.CommitRequest(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.CommitRequest result) {
+                if (writeSetBuilder_ == null) {
+                    if (((bitField0_ & 0x00000002) != 0)) {
+                        writeSet_ = java.util.Collections.unmodifiableList(writeSet_);
+                        bitField0_ = (bitField0_ & ~0x00000002);
+                    }
+                    result.writeSet_ = writeSet_;
+                } else {
+                    result.writeSet_ = writeSetBuilder_.build();
+                }
+            }
+
+            private void buildPartial0(Grpccatalog.CommitRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.txnId_ = txnId_;
+                }
+                int to_bitField0_ = 0;
+                if (((from_bitField0_ & 0x00000004) != 0)) {
+                    result.abort_ = abort_;
+                    to_bitField0_ |= 0x00000001;
+                }
+                result.bitField0_ |= to_bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.CommitRequest) {
+                    return mergeFrom((Grpccatalog.CommitRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.CommitRequest other) {
+                if (other == Grpccatalog.CommitRequest.getDefaultInstance()) return this;
+                if (other.getTxnId() != 0L) {
+                    setTxnId(other.getTxnId());
+                }
+                if (writeSetBuilder_ == null) {
+                    if (!other.writeSet_.isEmpty()) {
+                        if (writeSet_.isEmpty()) {
+                            writeSet_ = other.writeSet_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                        } else {
+                            ensureWriteSetIsMutable();
+                            writeSet_.addAll(other.writeSet_);
+                        }
+                        onChanged();
+                    }
+                } else {
+                    if (!other.writeSet_.isEmpty()) {
+                        if (writeSetBuilder_.isEmpty()) {
+                            writeSetBuilder_.dispose();
+                            writeSetBuilder_ = null;
+                            writeSet_ = other.writeSet_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                            writeSetBuilder_ =
+                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
+                                            getWriteSetFieldBuilder() : null;
+                        } else {
+                            writeSetBuilder_.addAllMessages(other.writeSet_);
+                        }
+                    }
+                }
+                if (other.hasAbort()) {
+                    setAbort(other.getAbort());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                txnId_ = input.readUInt64();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 18: {
+                                Grpccatalog.Write m =
+                                        input.readMessage(
+                                                Grpccatalog.Write.parser(),
+                                                extensionRegistry);
+                                if (writeSetBuilder_ == null) {
+                                    ensureWriteSetIsMutable();
+                                    writeSet_.add(m);
+                                } else {
+                                    writeSetBuilder_.addMessage(m);
+                                }
+                                break;
+                            } // case 18
+                            case 24: {
+                                abort_ = input.readBool();
+                                bitField0_ |= 0x00000004;
+                                break;
+                            } // case 24
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private long txnId_ ;
+            /**
+             * <code>uint64 txn_id = 1;</code>
+             * @return The txnId.
+             */
+            @java.lang.Override
+            public long getTxnId() {
+                return txnId_;
+            }
+            /**
+             * <code>uint64 txn_id = 1;</code>
+             * @param value The txnId to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTxnId(long value) {
+
+                txnId_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 txn_id = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearTxnId() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                txnId_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private java.util.List<Grpccatalog.Write> writeSet_ =
+                    java.util.Collections.emptyList();
+            private void ensureWriteSetIsMutable() {
+                if (!((bitField0_ & 0x00000002) != 0)) {
+                    writeSet_ = new java.util.ArrayList<Grpccatalog.Write>(writeSet_);
+                    bitField0_ |= 0x00000002;
+                }
+            }
+
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.Write, Grpccatalog.Write.Builder, Grpccatalog.WriteOrBuilder> writeSetBuilder_;
+
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public java.util.List<Grpccatalog.Write> getWriteSetList() {
+                if (writeSetBuilder_ == null) {
+                    return java.util.Collections.unmodifiableList(writeSet_);
+                } else {
+                    return writeSetBuilder_.getMessageList();
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public int getWriteSetCount() {
+                if (writeSetBuilder_ == null) {
+                    return writeSet_.size();
+                } else {
+                    return writeSetBuilder_.getCount();
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write getWriteSet(int index) {
+                if (writeSetBuilder_ == null) {
+                    return writeSet_.get(index);
+                } else {
+                    return writeSetBuilder_.getMessage(index);
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder setWriteSet(
+                    int index, Grpccatalog.Write value) {
+                if (writeSetBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureWriteSetIsMutable();
+                    writeSet_.set(index, value);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.setMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder setWriteSet(
+                    int index, Grpccatalog.Write.Builder builderForValue) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.set(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    writeSetBuilder_.setMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(Grpccatalog.Write value) {
+                if (writeSetBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(value);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(
+                    int index, Grpccatalog.Write value) {
+                if (writeSetBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(index, value);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(
+                    Grpccatalog.Write.Builder builderForValue) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(builderForValue.build());
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(
+                    int index, Grpccatalog.Write.Builder builderForValue) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addAllWriteSet(
+                    java.lang.Iterable<? extends Grpccatalog.Write> values) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                            values, writeSet_);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addAllMessages(values);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder clearWriteSet() {
+                if (writeSetBuilder_ == null) {
+                    writeSet_ = java.util.Collections.emptyList();
+                    bitField0_ = (bitField0_ & ~0x00000002);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder removeWriteSet(int index) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.remove(index);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.remove(index);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write.Builder getWriteSetBuilder(
+                    int index) {
+                return getWriteSetFieldBuilder().getBuilder(index);
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.WriteOrBuilder getWriteSetOrBuilder(
+                    int index) {
+                if (writeSetBuilder_ == null) {
+                    return writeSet_.get(index);  } else {
+                    return writeSetBuilder_.getMessageOrBuilder(index);
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public java.util.List<? extends Grpccatalog.WriteOrBuilder>
+            getWriteSetOrBuilderList() {
+                if (writeSetBuilder_ != null) {
+                    return writeSetBuilder_.getMessageOrBuilderList();
+                } else {
+                    return java.util.Collections.unmodifiableList(writeSet_);
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write.Builder addWriteSetBuilder() {
+                return getWriteSetFieldBuilder().addBuilder(
+                        Grpccatalog.Write.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write.Builder addWriteSetBuilder(
+                    int index) {
+                return getWriteSetFieldBuilder().addBuilder(
+                        index, Grpccatalog.Write.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public java.util.List<Grpccatalog.Write.Builder>
+            getWriteSetBuilderList() {
+                return getWriteSetFieldBuilder().getBuilderList();
+            }
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.Write, Grpccatalog.Write.Builder, Grpccatalog.WriteOrBuilder>
+            getWriteSetFieldBuilder() {
+                if (writeSetBuilder_ == null) {
+                    writeSetBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
+                            Grpccatalog.Write, Grpccatalog.Write.Builder, Grpccatalog.WriteOrBuilder>(
+                            writeSet_,
+                            ((bitField0_ & 0x00000002) != 0),
+                            getParentForChildren(),
+                            isClean());
+                    writeSet_ = null;
+                }
+                return writeSetBuilder_;
+            }
+
+            private boolean abort_ ;
+            /**
+             * <code>optional bool abort = 3;</code>
+             * @return Whether the abort field is set.
+             */
+            @java.lang.Override
+            public boolean hasAbort() {
+                return ((bitField0_ & 0x00000004) != 0);
+            }
+            /**
+             * <code>optional bool abort = 3;</code>
+             * @return The abort.
+             */
+            @java.lang.Override
+            public boolean getAbort() {
+                return abort_;
+            }
+            /**
+             * <code>optional bool abort = 3;</code>
+             * @param value The abort to set.
+             * @return This builder for chaining.
+             */
+            public Builder setAbort(boolean value) {
+
+                abort_ = value;
+                bitField0_ |= 0x00000004;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>optional bool abort = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearAbort() {
+                bitField0_ = (bitField0_ & ~0x00000004);
+                abort_ = false;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:CommitRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:CommitRequest)
+        private static final Grpccatalog.CommitRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.CommitRequest();
+        }
+
+        public static Grpccatalog.CommitRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<CommitRequest>
+                PARSER = new com.google.protobuf.AbstractParser<CommitRequest>() {
+            @java.lang.Override
+            public CommitRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<CommitRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<CommitRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.CommitRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface CommitResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:CommitResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+
+        /**
+         * <code>uint64 commit_vid = 2;</code>
+         * @return The commitVid.
+         */
+        long getCommitVid();
+    }
+    /**
+     * <pre>
+     * Whether commit was succesful.
+     * </pre>
+     *
+     * Protobuf type {@code CommitResponse}
+     */
+    public static final class CommitResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:CommitResponse)
+            CommitResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use CommitResponse.newBuilder() to construct.
+        private CommitResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private CommitResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new CommitResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_CommitResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_CommitResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.CommitResponse.class, Grpccatalog.CommitResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        public static final int COMMIT_VID_FIELD_NUMBER = 2;
+        private long commitVid_ = 0L;
+        /**
+         * <code>uint64 commit_vid = 2;</code>
+         * @return The commitVid.
+         */
+        @java.lang.Override
+        public long getCommitVid() {
+            return commitVid_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            if (commitVid_ != 0L) {
+                output.writeUInt64(2, commitVid_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            if (commitVid_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, commitVid_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.CommitResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.CommitResponse other = (Grpccatalog.CommitResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (getCommitVid()
+                    != other.getCommitVid()) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (37 * hash) + COMMIT_VID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getCommitVid());
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.CommitResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CommitResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CommitResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.CommitResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.CommitResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether commit was succesful.
+         * </pre>
+         *
+         * Protobuf type {@code CommitResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:CommitResponse)
+                Grpccatalog.CommitResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_CommitResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_CommitResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.CommitResponse.class, Grpccatalog.CommitResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.CommitResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                commitVid_ = 0L;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_CommitResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CommitResponse getDefaultInstanceForType() {
+                return Grpccatalog.CommitResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CommitResponse build() {
+                Grpccatalog.CommitResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.CommitResponse buildPartial() {
+                Grpccatalog.CommitResponse result = new Grpccatalog.CommitResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.CommitResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.commitVid_ = commitVid_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.CommitResponse) {
+                    return mergeFrom((Grpccatalog.CommitResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.CommitResponse other) {
+                if (other == Grpccatalog.CommitResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                if (other.getCommitVid() != 0L) {
+                    setCommitVid(other.getCommitVid());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                commitVid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long commitVid_ ;
+            /**
+             * <code>uint64 commit_vid = 2;</code>
+             * @return The commitVid.
+             */
+            @java.lang.Override
+            public long getCommitVid() {
+                return commitVid_;
+            }
+            /**
+             * <code>uint64 commit_vid = 2;</code>
+             * @param value The commitVid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setCommitVid(long value) {
+
+                commitVid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 commit_vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearCommitVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                commitVid_ = 0L;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:CommitResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:CommitResponse)
+        private static final Grpccatalog.CommitResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.CommitResponse();
+        }
+
+        public static Grpccatalog.CommitResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<CommitResponse>
+                PARSER = new com.google.protobuf.AbstractParser<CommitResponse>() {
+            @java.lang.Override
+            public CommitResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<CommitResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<CommitResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.CommitResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface PreCommitRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:PreCommitRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>uint64 txn_id = 1;</code>
+         * @return The txnId.
+         */
+        long getTxnId();
+
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        java.util.List<Grpccatalog.Write>
+        getWriteSetList();
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        Grpccatalog.Write getWriteSet(int index);
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        int getWriteSetCount();
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        java.util.List<? extends Grpccatalog.WriteOrBuilder>
+        getWriteSetOrBuilderList();
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        Grpccatalog.WriteOrBuilder getWriteSetOrBuilder(
+                int index);
+    }
+    /**
+     * <pre>
+     * Default concurrency control mechanism is OCC for now.
+     * </pre>
+     *
+     * Protobuf type {@code PreCommitRequest}
+     */
+    public static final class PreCommitRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:PreCommitRequest)
+            PreCommitRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use PreCommitRequest.newBuilder() to construct.
+        private PreCommitRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private PreCommitRequest() {
+            writeSet_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new PreCommitRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_PreCommitRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_PreCommitRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.PreCommitRequest.class, Grpccatalog.PreCommitRequest.Builder.class);
+        }
+
+        public static final int TXN_ID_FIELD_NUMBER = 1;
+        private long txnId_ = 0L;
+        /**
+         * <code>uint64 txn_id = 1;</code>
+         * @return The txnId.
+         */
+        @java.lang.Override
+        public long getTxnId() {
+            return txnId_;
+        }
+
+        public static final int WRITE_SET_FIELD_NUMBER = 2;
+        @SuppressWarnings("serial")
+        private java.util.List<Grpccatalog.Write> writeSet_;
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<Grpccatalog.Write> getWriteSetList() {
+            return writeSet_;
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public java.util.List<? extends Grpccatalog.WriteOrBuilder>
+        getWriteSetOrBuilderList() {
+            return writeSet_;
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public int getWriteSetCount() {
+            return writeSet_.size();
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.Write getWriteSet(int index) {
+            return writeSet_.get(index);
+        }
+        /**
+         * <code>repeated .Write write_set = 2;</code>
+         */
+        @java.lang.Override
+        public Grpccatalog.WriteOrBuilder getWriteSetOrBuilder(
+                int index) {
+            return writeSet_.get(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (txnId_ != 0L) {
+                output.writeUInt64(1, txnId_);
+            }
+            for (int i = 0; i < writeSet_.size(); i++) {
+                output.writeMessage(2, writeSet_.get(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (txnId_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(1, txnId_);
+            }
+            for (int i = 0; i < writeSet_.size(); i++) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeMessageSize(2, writeSet_.get(i));
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.PreCommitRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.PreCommitRequest other = (Grpccatalog.PreCommitRequest) obj;
+
+            if (getTxnId()
+                    != other.getTxnId()) return false;
+            if (!getWriteSetList()
+                    .equals(other.getWriteSetList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + TXN_ID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getTxnId());
+            if (getWriteSetCount() > 0) {
+                hash = (37 * hash) + WRITE_SET_FIELD_NUMBER;
+                hash = (53 * hash) + getWriteSetList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PreCommitRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PreCommitRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.PreCommitRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Default concurrency control mechanism is OCC for now.
+         * </pre>
+         *
+         * Protobuf type {@code PreCommitRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:PreCommitRequest)
+                Grpccatalog.PreCommitRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_PreCommitRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_PreCommitRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.PreCommitRequest.class, Grpccatalog.PreCommitRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.PreCommitRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                txnId_ = 0L;
+                if (writeSetBuilder_ == null) {
+                    writeSet_ = java.util.Collections.emptyList();
+                } else {
+                    writeSet_ = null;
+                    writeSetBuilder_.clear();
+                }
+                bitField0_ = (bitField0_ & ~0x00000002);
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_PreCommitRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PreCommitRequest getDefaultInstanceForType() {
+                return Grpccatalog.PreCommitRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PreCommitRequest build() {
+                Grpccatalog.PreCommitRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PreCommitRequest buildPartial() {
+                Grpccatalog.PreCommitRequest result = new Grpccatalog.PreCommitRequest(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.PreCommitRequest result) {
+                if (writeSetBuilder_ == null) {
+                    if (((bitField0_ & 0x00000002) != 0)) {
+                        writeSet_ = java.util.Collections.unmodifiableList(writeSet_);
+                        bitField0_ = (bitField0_ & ~0x00000002);
+                    }
+                    result.writeSet_ = writeSet_;
+                } else {
+                    result.writeSet_ = writeSetBuilder_.build();
+                }
+            }
+
+            private void buildPartial0(Grpccatalog.PreCommitRequest result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.txnId_ = txnId_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.PreCommitRequest) {
+                    return mergeFrom((Grpccatalog.PreCommitRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.PreCommitRequest other) {
+                if (other == Grpccatalog.PreCommitRequest.getDefaultInstance()) return this;
+                if (other.getTxnId() != 0L) {
+                    setTxnId(other.getTxnId());
+                }
+                if (writeSetBuilder_ == null) {
+                    if (!other.writeSet_.isEmpty()) {
+                        if (writeSet_.isEmpty()) {
+                            writeSet_ = other.writeSet_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                        } else {
+                            ensureWriteSetIsMutable();
+                            writeSet_.addAll(other.writeSet_);
+                        }
+                        onChanged();
+                    }
+                } else {
+                    if (!other.writeSet_.isEmpty()) {
+                        if (writeSetBuilder_.isEmpty()) {
+                            writeSetBuilder_.dispose();
+                            writeSetBuilder_ = null;
+                            writeSet_ = other.writeSet_;
+                            bitField0_ = (bitField0_ & ~0x00000002);
+                            writeSetBuilder_ =
+                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
+                                            getWriteSetFieldBuilder() : null;
+                        } else {
+                            writeSetBuilder_.addAllMessages(other.writeSet_);
+                        }
+                    }
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                txnId_ = input.readUInt64();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 18: {
+                                Grpccatalog.Write m =
+                                        input.readMessage(
+                                                Grpccatalog.Write.parser(),
+                                                extensionRegistry);
+                                if (writeSetBuilder_ == null) {
+                                    ensureWriteSetIsMutable();
+                                    writeSet_.add(m);
+                                } else {
+                                    writeSetBuilder_.addMessage(m);
+                                }
+                                break;
+                            } // case 18
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private long txnId_ ;
+            /**
+             * <code>uint64 txn_id = 1;</code>
+             * @return The txnId.
+             */
+            @java.lang.Override
+            public long getTxnId() {
+                return txnId_;
+            }
+            /**
+             * <code>uint64 txn_id = 1;</code>
+             * @param value The txnId to set.
+             * @return This builder for chaining.
+             */
+            public Builder setTxnId(long value) {
+
+                txnId_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 txn_id = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearTxnId() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                txnId_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private java.util.List<Grpccatalog.Write> writeSet_ =
+                    java.util.Collections.emptyList();
+            private void ensureWriteSetIsMutable() {
+                if (!((bitField0_ & 0x00000002) != 0)) {
+                    writeSet_ = new java.util.ArrayList<Grpccatalog.Write>(writeSet_);
+                    bitField0_ |= 0x00000002;
+                }
+            }
+
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.Write, Grpccatalog.Write.Builder, Grpccatalog.WriteOrBuilder> writeSetBuilder_;
+
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public java.util.List<Grpccatalog.Write> getWriteSetList() {
+                if (writeSetBuilder_ == null) {
+                    return java.util.Collections.unmodifiableList(writeSet_);
+                } else {
+                    return writeSetBuilder_.getMessageList();
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public int getWriteSetCount() {
+                if (writeSetBuilder_ == null) {
+                    return writeSet_.size();
+                } else {
+                    return writeSetBuilder_.getCount();
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write getWriteSet(int index) {
+                if (writeSetBuilder_ == null) {
+                    return writeSet_.get(index);
+                } else {
+                    return writeSetBuilder_.getMessage(index);
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder setWriteSet(
+                    int index, Grpccatalog.Write value) {
+                if (writeSetBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureWriteSetIsMutable();
+                    writeSet_.set(index, value);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.setMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder setWriteSet(
+                    int index, Grpccatalog.Write.Builder builderForValue) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.set(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    writeSetBuilder_.setMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(Grpccatalog.Write value) {
+                if (writeSetBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(value);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(
+                    int index, Grpccatalog.Write value) {
+                if (writeSetBuilder_ == null) {
+                    if (value == null) {
+                        throw new NullPointerException();
+                    }
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(index, value);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(index, value);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(
+                    Grpccatalog.Write.Builder builderForValue) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(builderForValue.build());
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addWriteSet(
+                    int index, Grpccatalog.Write.Builder builderForValue) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.add(index, builderForValue.build());
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addMessage(index, builderForValue.build());
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder addAllWriteSet(
+                    java.lang.Iterable<? extends Grpccatalog.Write> values) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                            values, writeSet_);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.addAllMessages(values);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder clearWriteSet() {
+                if (writeSetBuilder_ == null) {
+                    writeSet_ = java.util.Collections.emptyList();
+                    bitField0_ = (bitField0_ & ~0x00000002);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.clear();
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Builder removeWriteSet(int index) {
+                if (writeSetBuilder_ == null) {
+                    ensureWriteSetIsMutable();
+                    writeSet_.remove(index);
+                    onChanged();
+                } else {
+                    writeSetBuilder_.remove(index);
+                }
+                return this;
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write.Builder getWriteSetBuilder(
+                    int index) {
+                return getWriteSetFieldBuilder().getBuilder(index);
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.WriteOrBuilder getWriteSetOrBuilder(
+                    int index) {
+                if (writeSetBuilder_ == null) {
+                    return writeSet_.get(index);  } else {
+                    return writeSetBuilder_.getMessageOrBuilder(index);
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public java.util.List<? extends Grpccatalog.WriteOrBuilder>
+            getWriteSetOrBuilderList() {
+                if (writeSetBuilder_ != null) {
+                    return writeSetBuilder_.getMessageOrBuilderList();
+                } else {
+                    return java.util.Collections.unmodifiableList(writeSet_);
+                }
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write.Builder addWriteSetBuilder() {
+                return getWriteSetFieldBuilder().addBuilder(
+                        Grpccatalog.Write.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public Grpccatalog.Write.Builder addWriteSetBuilder(
+                    int index) {
+                return getWriteSetFieldBuilder().addBuilder(
+                        index, Grpccatalog.Write.getDefaultInstance());
+            }
+            /**
+             * <code>repeated .Write write_set = 2;</code>
+             */
+            public java.util.List<Grpccatalog.Write.Builder>
+            getWriteSetBuilderList() {
+                return getWriteSetFieldBuilder().getBuilderList();
+            }
+            private com.google.protobuf.RepeatedFieldBuilderV3<
+                    Grpccatalog.Write, Grpccatalog.Write.Builder, Grpccatalog.WriteOrBuilder>
+            getWriteSetFieldBuilder() {
+                if (writeSetBuilder_ == null) {
+                    writeSetBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
+                            Grpccatalog.Write, Grpccatalog.Write.Builder, Grpccatalog.WriteOrBuilder>(
+                            writeSet_,
+                            ((bitField0_ & 0x00000002) != 0),
+                            getParentForChildren(),
+                            isClean());
+                    writeSet_ = null;
+                }
+                return writeSetBuilder_;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:PreCommitRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:PreCommitRequest)
+        private static final Grpccatalog.PreCommitRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.PreCommitRequest();
+        }
+
+        public static Grpccatalog.PreCommitRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<PreCommitRequest>
+                PARSER = new com.google.protobuf.AbstractParser<PreCommitRequest>() {
+            @java.lang.Override
+            public PreCommitRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<PreCommitRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<PreCommitRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.PreCommitRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface PreCommitResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:PreCommitResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+    }
+    /**
+     * <pre>
+     * Whether precommit was succesful.
+     * </pre>
+     *
+     * Protobuf type {@code PreCommitResponse}
+     */
+    public static final class PreCommitResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:PreCommitResponse)
+            PreCommitResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use PreCommitResponse.newBuilder() to construct.
+        private PreCommitResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private PreCommitResponse() {
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new PreCommitResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_PreCommitResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_PreCommitResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.PreCommitResponse.class, Grpccatalog.PreCommitResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.PreCommitResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.PreCommitResponse other = (Grpccatalog.PreCommitResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PreCommitResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.PreCommitResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.PreCommitResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Whether precommit was succesful.
+         * </pre>
+         *
+         * Protobuf type {@code PreCommitResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:PreCommitResponse)
+                Grpccatalog.PreCommitResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_PreCommitResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_PreCommitResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.PreCommitResponse.class, Grpccatalog.PreCommitResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.PreCommitResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_PreCommitResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PreCommitResponse getDefaultInstanceForType() {
+                return Grpccatalog.PreCommitResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PreCommitResponse build() {
+                Grpccatalog.PreCommitResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.PreCommitResponse buildPartial() {
+                Grpccatalog.PreCommitResponse result = new Grpccatalog.PreCommitResponse(this);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartial0(Grpccatalog.PreCommitResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.PreCommitResponse) {
+                    return mergeFrom((Grpccatalog.PreCommitResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.PreCommitResponse other) {
+                if (other == Grpccatalog.PreCommitResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:PreCommitResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:PreCommitResponse)
+        private static final Grpccatalog.PreCommitResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.PreCommitResponse();
+        }
+
+        public static Grpccatalog.PreCommitResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<PreCommitResponse>
+                PARSER = new com.google.protobuf.AbstractParser<PreCommitResponse>() {
+            @java.lang.Override
+            public PreCommitResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<PreCommitResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<PreCommitResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.PreCommitResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface BulkLoadRequestOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:BulkLoadRequest)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>repeated bytes obj_list = 1;</code>
+         * @return A list containing the objList.
+         */
+        java.util.List<com.google.protobuf.ByteString> getObjListList();
+        /**
+         * <code>repeated bytes obj_list = 1;</code>
+         * @return The count of objList.
+         */
+        int getObjListCount();
+        /**
+         * <code>repeated bytes obj_list = 1;</code>
+         * @param index The index of the element to return.
+         * @return The objList at the given index.
+         */
+        com.google.protobuf.ByteString getObjList(int index);
+    }
+    /**
+     * <pre>
+     * Each message contains multiple objects
+     * </pre>
+     *
+     * Protobuf type {@code BulkLoadRequest}
+     */
+    public static final class BulkLoadRequest extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:BulkLoadRequest)
+            BulkLoadRequestOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use BulkLoadRequest.newBuilder() to construct.
+        private BulkLoadRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private BulkLoadRequest() {
+            objList_ = java.util.Collections.emptyList();
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new BulkLoadRequest();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_BulkLoadRequest_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_BulkLoadRequest_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.BulkLoadRequest.class, Grpccatalog.BulkLoadRequest.Builder.class);
+        }
+
+        public static final int OBJ_LIST_FIELD_NUMBER = 1;
+        @SuppressWarnings("serial")
+        private java.util.List<com.google.protobuf.ByteString> objList_;
+        /**
+         * <code>repeated bytes obj_list = 1;</code>
+         * @return A list containing the objList.
+         */
+        @java.lang.Override
+        public java.util.List<com.google.protobuf.ByteString>
+        getObjListList() {
+            return objList_;
+        }
+        /**
+         * <code>repeated bytes obj_list = 1;</code>
+         * @return The count of objList.
+         */
+        public int getObjListCount() {
+            return objList_.size();
+        }
+        /**
+         * <code>repeated bytes obj_list = 1;</code>
+         * @param index The index of the element to return.
+         * @return The objList at the given index.
+         */
+        public com.google.protobuf.ByteString getObjList(int index) {
+            return objList_.get(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            for (int i = 0; i < objList_.size(); i++) {
+                output.writeBytes(1, objList_.get(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            {
+                int dataSize = 0;
+                for (int i = 0; i < objList_.size(); i++) {
+                    dataSize += com.google.protobuf.CodedOutputStream
+                            .computeBytesSizeNoTag(objList_.get(i));
+                }
+                size += dataSize;
+                size += 1 * getObjListList().size();
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.BulkLoadRequest)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.BulkLoadRequest other = (Grpccatalog.BulkLoadRequest) obj;
+
+            if (!getObjListList()
+                    .equals(other.getObjListList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            if (getObjListCount() > 0) {
+                hash = (37 * hash) + OBJ_LIST_FIELD_NUMBER;
+                hash = (53 * hash) + getObjListList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadRequest parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.BulkLoadRequest parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.BulkLoadRequest parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.BulkLoadRequest prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * Each message contains multiple objects
+         * </pre>
+         *
+         * Protobuf type {@code BulkLoadRequest}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:BulkLoadRequest)
+                Grpccatalog.BulkLoadRequestOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_BulkLoadRequest_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_BulkLoadRequest_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.BulkLoadRequest.class, Grpccatalog.BulkLoadRequest.Builder.class);
+            }
+
+            // Construct using Grpccatalog.BulkLoadRequest.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                objList_ = java.util.Collections.emptyList();
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_BulkLoadRequest_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.BulkLoadRequest getDefaultInstanceForType() {
+                return Grpccatalog.BulkLoadRequest.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.BulkLoadRequest build() {
+                Grpccatalog.BulkLoadRequest result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.BulkLoadRequest buildPartial() {
+                Grpccatalog.BulkLoadRequest result = new Grpccatalog.BulkLoadRequest(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.BulkLoadRequest result) {
+                if (((bitField0_ & 0x00000001) != 0)) {
+                    objList_ = java.util.Collections.unmodifiableList(objList_);
+                    bitField0_ = (bitField0_ & ~0x00000001);
+                }
+                result.objList_ = objList_;
+            }
+
+            private void buildPartial0(Grpccatalog.BulkLoadRequest result) {
+                int from_bitField0_ = bitField0_;
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.BulkLoadRequest) {
+                    return mergeFrom((Grpccatalog.BulkLoadRequest)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.BulkLoadRequest other) {
+                if (other == Grpccatalog.BulkLoadRequest.getDefaultInstance()) return this;
+                if (!other.objList_.isEmpty()) {
+                    if (objList_.isEmpty()) {
+                        objList_ = other.objList_;
+                        bitField0_ = (bitField0_ & ~0x00000001);
+                    } else {
+                        ensureObjListIsMutable();
+                        objList_.addAll(other.objList_);
+                    }
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 10: {
+                                com.google.protobuf.ByteString v = input.readBytes();
+                                ensureObjListIsMutable();
+                                objList_.add(v);
+                                break;
+                            } // case 10
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private java.util.List<com.google.protobuf.ByteString> objList_ = java.util.Collections.emptyList();
+            private void ensureObjListIsMutable() {
+                if (!((bitField0_ & 0x00000001) != 0)) {
+                    objList_ = new java.util.ArrayList<com.google.protobuf.ByteString>(objList_);
+                    bitField0_ |= 0x00000001;
+                }
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @return A list containing the objList.
+             */
+            public java.util.List<com.google.protobuf.ByteString>
+            getObjListList() {
+                return ((bitField0_ & 0x00000001) != 0) ?
+                        java.util.Collections.unmodifiableList(objList_) : objList_;
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @return The count of objList.
+             */
+            public int getObjListCount() {
+                return objList_.size();
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @param index The index of the element to return.
+             * @return The objList at the given index.
+             */
+            public com.google.protobuf.ByteString getObjList(int index) {
+                return objList_.get(index);
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @param index The index to set the value at.
+             * @param value The objList to set.
+             * @return This builder for chaining.
+             */
+            public Builder setObjList(
+                    int index, com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureObjListIsMutable();
+                objList_.set(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @param value The objList to add.
+             * @return This builder for chaining.
+             */
+            public Builder addObjList(com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureObjListIsMutable();
+                objList_.add(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @param values The objList to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllObjList(
+                    java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
+                ensureObjListIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, objList_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated bytes obj_list = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearObjList() {
+                objList_ = java.util.Collections.emptyList();
+                bitField0_ = (bitField0_ & ~0x00000001);
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:BulkLoadRequest)
+        }
+
+        // @@protoc_insertion_point(class_scope:BulkLoadRequest)
+        private static final Grpccatalog.BulkLoadRequest DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.BulkLoadRequest();
+        }
+
+        public static Grpccatalog.BulkLoadRequest getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<BulkLoadRequest>
+                PARSER = new com.google.protobuf.AbstractParser<BulkLoadRequest>() {
+            @java.lang.Override
+            public BulkLoadRequest parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<BulkLoadRequest> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<BulkLoadRequest> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.BulkLoadRequest getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    public interface BulkLoadResponseOrBuilder extends
+            // @@protoc_insertion_point(interface_extends:BulkLoadResponse)
+            com.google.protobuf.MessageOrBuilder {
+
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        boolean getSuccess();
+
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        long getVid();
+
+        /**
+         * <code>repeated string err = 3;</code>
+         * @return A list containing the err.
+         */
+        java.util.List<java.lang.String>
+        getErrList();
+        /**
+         * <code>repeated string err = 3;</code>
+         * @return The count of err.
+         */
+        int getErrCount();
+        /**
+         * <code>repeated string err = 3;</code>
+         * @param index The index of the element to return.
+         * @return The err at the given index.
+         */
+        java.lang.String getErr(int index);
+        /**
+         * <code>repeated string err = 3;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the err at the given index.
+         */
+        com.google.protobuf.ByteString
+        getErrBytes(int index);
+    }
+    /**
+     * <pre>
+     * The response informs whether the bulkload operation was successful and the vid of the operation.
+     * Otherwise, the list of error messages (e.g. parents missing)
+     * </pre>
+     *
+     * Protobuf type {@code BulkLoadResponse}
+     */
+    public static final class BulkLoadResponse extends
+            com.google.protobuf.GeneratedMessageV3 implements
+            // @@protoc_insertion_point(message_implements:BulkLoadResponse)
+            BulkLoadResponseOrBuilder {
+        private static final long serialVersionUID = 0L;
+        // Use BulkLoadResponse.newBuilder() to construct.
+        private BulkLoadResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
+            super(builder);
+        }
+        private BulkLoadResponse() {
+            err_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+        }
+
+        @java.lang.Override
+        @SuppressWarnings({"unused"})
+        protected java.lang.Object newInstance(
+                UnusedPrivateParameter unused) {
+            return new BulkLoadResponse();
+        }
+
+        @java.lang.Override
+        public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+            return this.unknownFields;
+        }
+        public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+            return Grpccatalog.internal_static_BulkLoadResponse_descriptor;
+        }
+
+        @java.lang.Override
+        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+            return Grpccatalog.internal_static_BulkLoadResponse_fieldAccessorTable
+                    .ensureFieldAccessorsInitialized(
+                            Grpccatalog.BulkLoadResponse.class, Grpccatalog.BulkLoadResponse.Builder.class);
+        }
+
+        public static final int SUCCESS_FIELD_NUMBER = 1;
+        private boolean success_ = false;
+        /**
+         * <code>bool success = 1;</code>
+         * @return The success.
+         */
+        @java.lang.Override
+        public boolean getSuccess() {
+            return success_;
+        }
+
+        public static final int VID_FIELD_NUMBER = 2;
+        private long vid_ = 0L;
+        /**
+         * <code>uint64 vid = 2;</code>
+         * @return The vid.
+         */
+        @java.lang.Override
+        public long getVid() {
+            return vid_;
+        }
+
+        public static final int ERR_FIELD_NUMBER = 3;
+        @SuppressWarnings("serial")
+        private com.google.protobuf.LazyStringList err_;
+        /**
+         * <code>repeated string err = 3;</code>
+         * @return A list containing the err.
+         */
+        public com.google.protobuf.ProtocolStringList
+        getErrList() {
+            return err_;
+        }
+        /**
+         * <code>repeated string err = 3;</code>
+         * @return The count of err.
+         */
+        public int getErrCount() {
+            return err_.size();
+        }
+        /**
+         * <code>repeated string err = 3;</code>
+         * @param index The index of the element to return.
+         * @return The err at the given index.
+         */
+        public java.lang.String getErr(int index) {
+            return err_.get(index);
+        }
+        /**
+         * <code>repeated string err = 3;</code>
+         * @param index The index of the value to return.
+         * @return The bytes of the err at the given index.
+         */
+        public com.google.protobuf.ByteString
+        getErrBytes(int index) {
+            return err_.getByteString(index);
+        }
+
+        private byte memoizedIsInitialized = -1;
+        @java.lang.Override
+        public final boolean isInitialized() {
+            byte isInitialized = memoizedIsInitialized;
+            if (isInitialized == 1) return true;
+            if (isInitialized == 0) return false;
+
+            memoizedIsInitialized = 1;
+            return true;
+        }
+
+        @java.lang.Override
+        public void writeTo(com.google.protobuf.CodedOutputStream output)
+                throws java.io.IOException {
+            if (success_ != false) {
+                output.writeBool(1, success_);
+            }
+            if (vid_ != 0L) {
+                output.writeUInt64(2, vid_);
+            }
+            for (int i = 0; i < err_.size(); i++) {
+                com.google.protobuf.GeneratedMessageV3.writeString(output, 3, err_.getRaw(i));
+            }
+            getUnknownFields().writeTo(output);
+        }
+
+        @java.lang.Override
+        public int getSerializedSize() {
+            int size = memoizedSize;
+            if (size != -1) return size;
+
+            size = 0;
+            if (success_ != false) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeBoolSize(1, success_);
+            }
+            if (vid_ != 0L) {
+                size += com.google.protobuf.CodedOutputStream
+                        .computeUInt64Size(2, vid_);
+            }
+            {
+                int dataSize = 0;
+                for (int i = 0; i < err_.size(); i++) {
+                    dataSize += computeStringSizeNoTag(err_.getRaw(i));
+                }
+                size += dataSize;
+                size += 1 * getErrList().size();
+            }
+            size += getUnknownFields().getSerializedSize();
+            memoizedSize = size;
+            return size;
+        }
+
+        @java.lang.Override
+        public boolean equals(final java.lang.Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (!(obj instanceof Grpccatalog.BulkLoadResponse)) {
+                return super.equals(obj);
+            }
+            Grpccatalog.BulkLoadResponse other = (Grpccatalog.BulkLoadResponse) obj;
+
+            if (getSuccess()
+                    != other.getSuccess()) return false;
+            if (getVid()
+                    != other.getVid()) return false;
+            if (!getErrList()
+                    .equals(other.getErrList())) return false;
+            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
+            return true;
+        }
+
+        @java.lang.Override
+        public int hashCode() {
+            if (memoizedHashCode != 0) {
+                return memoizedHashCode;
+            }
+            int hash = 41;
+            hash = (19 * hash) + getDescriptor().hashCode();
+            hash = (37 * hash) + SUCCESS_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
+                    getSuccess());
+            hash = (37 * hash) + VID_FIELD_NUMBER;
+            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
+                    getVid());
+            if (getErrCount() > 0) {
+                hash = (37 * hash) + ERR_FIELD_NUMBER;
+                hash = (53 * hash) + getErrList().hashCode();
+            }
+            hash = (29 * hash) + getUnknownFields().hashCode();
+            memoizedHashCode = hash;
+            return hash;
+        }
+
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                java.nio.ByteBuffer data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                java.nio.ByteBuffer data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                com.google.protobuf.ByteString data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                com.google.protobuf.ByteString data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(byte[] data)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                byte[] data,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws com.google.protobuf.InvalidProtocolBufferException {
+            return PARSER.parseFrom(data, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadResponse parseDelimitedFrom(java.io.InputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.BulkLoadResponse parseDelimitedFrom(
+                java.io.InputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                com.google.protobuf.CodedInputStream input)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input);
+        }
+        public static Grpccatalog.BulkLoadResponse parseFrom(
+                com.google.protobuf.CodedInputStream input,
+                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                throws java.io.IOException {
+            return com.google.protobuf.GeneratedMessageV3
+                    .parseWithIOException(PARSER, input, extensionRegistry);
+        }
+
+        @java.lang.Override
+        public Builder newBuilderForType() { return newBuilder(); }
+        public static Builder newBuilder() {
+            return DEFAULT_INSTANCE.toBuilder();
+        }
+        public static Builder newBuilder(Grpccatalog.BulkLoadResponse prototype) {
+            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
+        }
+        @java.lang.Override
+        public Builder toBuilder() {
+            return this == DEFAULT_INSTANCE
+                    ? new Builder() : new Builder().mergeFrom(this);
+        }
+
+        @java.lang.Override
+        protected Builder newBuilderForType(
+                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+            Builder builder = new Builder(parent);
+            return builder;
+        }
+        /**
+         * <pre>
+         * The response informs whether the bulkload operation was successful and the vid of the operation.
+         * Otherwise, the list of error messages (e.g. parents missing)
+         * </pre>
+         *
+         * Protobuf type {@code BulkLoadResponse}
+         */
+        public static final class Builder extends
+                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
+                // @@protoc_insertion_point(builder_implements:BulkLoadResponse)
+                Grpccatalog.BulkLoadResponseOrBuilder {
+            public static final com.google.protobuf.Descriptors.Descriptor
+            getDescriptor() {
+                return Grpccatalog.internal_static_BulkLoadResponse_descriptor;
+            }
+
+            @java.lang.Override
+            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internalGetFieldAccessorTable() {
+                return Grpccatalog.internal_static_BulkLoadResponse_fieldAccessorTable
+                        .ensureFieldAccessorsInitialized(
+                                Grpccatalog.BulkLoadResponse.class, Grpccatalog.BulkLoadResponse.Builder.class);
+            }
+
+            // Construct using Grpccatalog.BulkLoadResponse.newBuilder()
+            private Builder() {
+
+            }
+
+            private Builder(
+                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
+                super(parent);
+
+            }
+            @java.lang.Override
+            public Builder clear() {
+                super.clear();
+                bitField0_ = 0;
+                success_ = false;
+                vid_ = 0L;
+                err_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+                bitField0_ = (bitField0_ & ~0x00000004);
+                return this;
+            }
+
+            @java.lang.Override
+            public com.google.protobuf.Descriptors.Descriptor
+            getDescriptorForType() {
+                return Grpccatalog.internal_static_BulkLoadResponse_descriptor;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.BulkLoadResponse getDefaultInstanceForType() {
+                return Grpccatalog.BulkLoadResponse.getDefaultInstance();
+            }
+
+            @java.lang.Override
+            public Grpccatalog.BulkLoadResponse build() {
+                Grpccatalog.BulkLoadResponse result = buildPartial();
+                if (!result.isInitialized()) {
+                    throw newUninitializedMessageException(result);
+                }
+                return result;
+            }
+
+            @java.lang.Override
+            public Grpccatalog.BulkLoadResponse buildPartial() {
+                Grpccatalog.BulkLoadResponse result = new Grpccatalog.BulkLoadResponse(this);
+                buildPartialRepeatedFields(result);
+                if (bitField0_ != 0) { buildPartial0(result); }
+                onBuilt();
+                return result;
+            }
+
+            private void buildPartialRepeatedFields(Grpccatalog.BulkLoadResponse result) {
+                if (((bitField0_ & 0x00000004) != 0)) {
+                    err_ = err_.getUnmodifiableView();
+                    bitField0_ = (bitField0_ & ~0x00000004);
+                }
+                result.err_ = err_;
+            }
+
+            private void buildPartial0(Grpccatalog.BulkLoadResponse result) {
+                int from_bitField0_ = bitField0_;
+                if (((from_bitField0_ & 0x00000001) != 0)) {
+                    result.success_ = success_;
+                }
+                if (((from_bitField0_ & 0x00000002) != 0)) {
+                    result.vid_ = vid_;
+                }
+            }
+
+            @java.lang.Override
+            public Builder clone() {
+                return super.clone();
+            }
+            @java.lang.Override
+            public Builder setField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.setField(field, value);
+            }
+            @java.lang.Override
+            public Builder clearField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field) {
+                return super.clearField(field);
+            }
+            @java.lang.Override
+            public Builder clearOneof(
+                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
+                return super.clearOneof(oneof);
+            }
+            @java.lang.Override
+            public Builder setRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    int index, java.lang.Object value) {
+                return super.setRepeatedField(field, index, value);
+            }
+            @java.lang.Override
+            public Builder addRepeatedField(
+                    com.google.protobuf.Descriptors.FieldDescriptor field,
+                    java.lang.Object value) {
+                return super.addRepeatedField(field, value);
+            }
+            @java.lang.Override
+            public Builder mergeFrom(com.google.protobuf.Message other) {
+                if (other instanceof Grpccatalog.BulkLoadResponse) {
+                    return mergeFrom((Grpccatalog.BulkLoadResponse)other);
+                } else {
+                    super.mergeFrom(other);
+                    return this;
+                }
+            }
+
+            public Builder mergeFrom(Grpccatalog.BulkLoadResponse other) {
+                if (other == Grpccatalog.BulkLoadResponse.getDefaultInstance()) return this;
+                if (other.getSuccess() != false) {
+                    setSuccess(other.getSuccess());
+                }
+                if (other.getVid() != 0L) {
+                    setVid(other.getVid());
+                }
+                if (!other.err_.isEmpty()) {
+                    if (err_.isEmpty()) {
+                        err_ = other.err_;
+                        bitField0_ = (bitField0_ & ~0x00000004);
+                    } else {
+                        ensureErrIsMutable();
+                        err_.addAll(other.err_);
+                    }
+                    onChanged();
+                }
+                this.mergeUnknownFields(other.getUnknownFields());
+                onChanged();
+                return this;
+            }
+
+            @java.lang.Override
+            public final boolean isInitialized() {
+                return true;
+            }
+
+            @java.lang.Override
+            public Builder mergeFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws java.io.IOException {
+                if (extensionRegistry == null) {
+                    throw new java.lang.NullPointerException();
+                }
+                try {
+                    boolean done = false;
+                    while (!done) {
+                        int tag = input.readTag();
+                        switch (tag) {
+                            case 0:
+                                done = true;
+                                break;
+                            case 8: {
+                                success_ = input.readBool();
+                                bitField0_ |= 0x00000001;
+                                break;
+                            } // case 8
+                            case 16: {
+                                vid_ = input.readUInt64();
+                                bitField0_ |= 0x00000002;
+                                break;
+                            } // case 16
+                            case 26: {
+                                java.lang.String s = input.readStringRequireUtf8();
+                                ensureErrIsMutable();
+                                err_.add(s);
+                                break;
+                            } // case 26
+                            default: {
+                                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
+                                    done = true; // was an endgroup tag
+                                }
+                                break;
+                            } // default:
+                        } // switch (tag)
+                    } // while (!done)
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.unwrapIOException();
+                } finally {
+                    onChanged();
+                } // finally
+                return this;
+            }
+            private int bitField0_;
+
+            private boolean success_ ;
+            /**
+             * <code>bool success = 1;</code>
+             * @return The success.
+             */
+            @java.lang.Override
+            public boolean getSuccess() {
+                return success_;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @param value The success to set.
+             * @return This builder for chaining.
+             */
+            public Builder setSuccess(boolean value) {
+
+                success_ = value;
+                bitField0_ |= 0x00000001;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>bool success = 1;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearSuccess() {
+                bitField0_ = (bitField0_ & ~0x00000001);
+                success_ = false;
+                onChanged();
+                return this;
+            }
+
+            private long vid_ ;
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return The vid.
+             */
+            @java.lang.Override
+            public long getVid() {
+                return vid_;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @param value The vid to set.
+             * @return This builder for chaining.
+             */
+            public Builder setVid(long value) {
+
+                vid_ = value;
+                bitField0_ |= 0x00000002;
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>uint64 vid = 2;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearVid() {
+                bitField0_ = (bitField0_ & ~0x00000002);
+                vid_ = 0L;
+                onChanged();
+                return this;
+            }
+
+            private com.google.protobuf.LazyStringList err_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+            private void ensureErrIsMutable() {
+                if (!((bitField0_ & 0x00000004) != 0)) {
+                    err_ = new com.google.protobuf.LazyStringArrayList(err_);
+                    bitField0_ |= 0x00000004;
+                }
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @return A list containing the err.
+             */
+            public com.google.protobuf.ProtocolStringList
+            getErrList() {
+                return err_.getUnmodifiableView();
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @return The count of err.
+             */
+            public int getErrCount() {
+                return err_.size();
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @param index The index of the element to return.
+             * @return The err at the given index.
+             */
+            public java.lang.String getErr(int index) {
+                return err_.get(index);
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @param index The index of the value to return.
+             * @return The bytes of the err at the given index.
+             */
+            public com.google.protobuf.ByteString
+            getErrBytes(int index) {
+                return err_.getByteString(index);
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @param index The index to set the value at.
+             * @param value The err to set.
+             * @return This builder for chaining.
+             */
+            public Builder setErr(
+                    int index, java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureErrIsMutable();
+                err_.set(index, value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @param value The err to add.
+             * @return This builder for chaining.
+             */
+            public Builder addErr(
+                    java.lang.String value) {
+                if (value == null) { throw new NullPointerException(); }
+                ensureErrIsMutable();
+                err_.add(value);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @param values The err to add.
+             * @return This builder for chaining.
+             */
+            public Builder addAllErr(
+                    java.lang.Iterable<java.lang.String> values) {
+                ensureErrIsMutable();
+                com.google.protobuf.AbstractMessageLite.Builder.addAll(
+                        values, err_);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @return This builder for chaining.
+             */
+            public Builder clearErr() {
+                err_ = com.google.protobuf.LazyStringArrayList.EMPTY;
+                bitField0_ = (bitField0_ & ~0x00000004);
+                onChanged();
+                return this;
+            }
+            /**
+             * <code>repeated string err = 3;</code>
+             * @param value The bytes of the err to add.
+             * @return This builder for chaining.
+             */
+            public Builder addErrBytes(
+                    com.google.protobuf.ByteString value) {
+                if (value == null) { throw new NullPointerException(); }
+                checkByteStringIsUtf8(value);
+                ensureErrIsMutable();
+                err_.add(value);
+                onChanged();
+                return this;
+            }
+            @java.lang.Override
+            public final Builder setUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.setUnknownFields(unknownFields);
+            }
+
+            @java.lang.Override
+            public final Builder mergeUnknownFields(
+                    final com.google.protobuf.UnknownFieldSet unknownFields) {
+                return super.mergeUnknownFields(unknownFields);
+            }
+
+
+            // @@protoc_insertion_point(builder_scope:BulkLoadResponse)
+        }
+
+        // @@protoc_insertion_point(class_scope:BulkLoadResponse)
+        private static final Grpccatalog.BulkLoadResponse DEFAULT_INSTANCE;
+        static {
+            DEFAULT_INSTANCE = new Grpccatalog.BulkLoadResponse();
+        }
+
+        public static Grpccatalog.BulkLoadResponse getDefaultInstance() {
+            return DEFAULT_INSTANCE;
+        }
+
+        private static final com.google.protobuf.Parser<BulkLoadResponse>
+                PARSER = new com.google.protobuf.AbstractParser<BulkLoadResponse>() {
+            @java.lang.Override
+            public BulkLoadResponse parsePartialFrom(
+                    com.google.protobuf.CodedInputStream input,
+                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+                    throws com.google.protobuf.InvalidProtocolBufferException {
+                Builder builder = newBuilder();
+                try {
+                    builder.mergeFrom(input, extensionRegistry);
+                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+                    throw e.setUnfinishedMessage(builder.buildPartial());
+                } catch (com.google.protobuf.UninitializedMessageException e) {
+                    throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
+                } catch (java.io.IOException e) {
+                    throw new com.google.protobuf.InvalidProtocolBufferException(e)
+                            .setUnfinishedMessage(builder.buildPartial());
+                }
+                return builder.buildPartial();
+            }
+        };
+
+        public static com.google.protobuf.Parser<BulkLoadResponse> parser() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public com.google.protobuf.Parser<BulkLoadResponse> getParserForType() {
+            return PARSER;
+        }
+
+        @java.lang.Override
+        public Grpccatalog.BulkLoadResponse getDefaultInstanceForType() {
+            return DEFAULT_INSTANCE;
+        }
+
+    }
+
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_Field_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_Field_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_FieldDef_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_FieldDef_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExtObjTypeName_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExtObjTypeName_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ObjTypeDef_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ObjTypeDef_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_Children_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_Children_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_Write_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_Write_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_PathExpr_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_PathExpr_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_Predicate_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_Predicate_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExprOp_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExprOp_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExprBool_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExprBool_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExprConst_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExprConst_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExprFieldRef_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExprFieldRef_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExprNode_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExprNode_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_StartTxnRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_StartTxnRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_StartTxnResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_StartTxnResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_SnapshotRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_SnapshotRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_SnapshotResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_SnapshotResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_CloneRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_CloneRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_CloneResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_CloneResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_GetGarbageRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_GetGarbageRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_GetGarbageResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_GetGarbageResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ClearGarbageRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ClearGarbageRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ClearGarbageResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ClearGarbageResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_DefineTypeRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_DefineTypeRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_DefineTypeResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_DefineTypeResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExecuteQueryRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExecuteQueryRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_ExecuteQueryResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_ExecuteQueryResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_CommitRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_CommitRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_CommitResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_CommitResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_PreCommitRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_PreCommitRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_PreCommitResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_PreCommitResponse_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_BulkLoadRequest_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_BulkLoadRequest_fieldAccessorTable;
+    private static final com.google.protobuf.Descriptors.Descriptor
+            internal_static_BulkLoadResponse_descriptor;
+    private static final
+    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
+            internal_static_BulkLoadResponse_fieldAccessorTable;
+
+    public static com.google.protobuf.Descriptors.FileDescriptor
+    getDescriptor() {
+        return descriptor;
+    }
+    private static  com.google.protobuf.Descriptors.FileDescriptor
+            descriptor;
+    static {
+        java.lang.String[] descriptorData = {
+                "\n\021grpccatalog.proto\"E\n\005Field\022\022\n\nfield_na" +
+                        "me\030\001 \001(\t\022\030\n\013field_value\030\002 \001(\tH\000\210\001\001B\016\n\014_f" +
+                        "ield_value\"1\n\010FieldDef\022\022\n\nfield_name\030\001 \001" +
+                        "(\t\022\021\n\tfield_def\030\002 \001(\t\"[\n\016ExtObjTypeName\022" +
+                        "#\n\robj_type_name\030\001 \001(\0162\014.ObjTypeName\022\026\n\t" +
+                        "extension\030\002 \001(\tH\000\210\001\001B\014\n\n_extension\"W\n\nOb" +
+                        "jTypeDef\022*\n\021ext_obj_type_name\030\001 \001(\0132\017.Ex" +
+                        "tObjTypeName\022\035\n\nfield_defs\030\002 \003(\0132\t.Field" +
+                        "Def\"D\n\010Children\022*\n\021ext_obj_type_name\030\001 \001" +
+                        "(\0132\017.ExtObjTypeName\022\014\n\004oids\030\002 \003(\003\"\264\001\n\005Wr" +
+                        "ite\022\030\n\004type\030\001 \001(\0162\n.WriteType\022\017\n\007is_leaf" +
+                        "\030\002 \001(\010\022\023\n\013write_value\030\003 \001(\014\022\024\n\007trigger\030\004" +
+                        " \001(\tH\001\210\001\001\022\014\n\004args\030\005 \003(\t\022\037\n\nparse_tree\030\006 " +
+                        "\001(\0132\t.PathExprH\000\022\022\n\010path_str\030\007 \001(\tH\000B\006\n\004" +
+                        "pathB\n\n\010_trigger\"}\n\010PathExpr\022\031\n\005preds\030\001 " +
+                        "\003(\0132\n.Predicate\022\035\n\nlock_modes\030\002 \003(\0162\t.Lo" +
+                        "ckMode\022%\n\roptional_pred\030\003 \001(\0132\t.ExprNode" +
+                        "H\000\210\001\001B\020\n\016_optional_pred\"R\n\tPredicate\022\036\n\t" +
+                        "expr_node\030\001 \001(\0132\t.ExprNodeH\000\022\035\n\010wildcard" +
+                        "\030\002 \001(\0162\t.WildcardH\000B\006\n\004pred\"g\n\006ExprOp\022\034\n" +
+                        "\007op_type\030\001 \001(\0162\013.ExprOpType\022\030\n\005right\030\002 \001" +
+                        "(\0132\t.ExprNode\022\034\n\004left\030\003 \001(\0132\t.ExprNodeH\000" +
+                        "\210\001\001B\007\n\005_left\"C\n\010ExprBool\022\036\n\007op_type\030\001 \001(" +
+                        "\0162\r.ExprBoolType\022\027\n\004args\030\002 \003(\0132\t.ExprNod" +
+                        "e\"\242\001\n\tExprConst\022\"\n\nconst_type\030\001 \001(\0162\016.Ex" +
+                        "prConstType\022\024\n\nstring_val\030\002 \001(\tH\000\022\023\n\tint" +
+                        "32_val\030\003 \001(\005H\000\022\023\n\tint64_val\030\004 \001(\003H\000\022\024\n\nd" +
+                        "ouble_val\030\005 \001(\001H\000\022\022\n\010bool_val\030\006 \001(\010H\000B\007\n" +
+                        "\005value\"\"\n\014ExprFieldRef\022\022\n\nfield_refs\030\001 \003" +
+                        "(\t\"\231\001\n\010ExprNode\022\032\n\007expr_op\030\001 \001(\0132\007.ExprO" +
+                        "pH\000\022\036\n\texpr_bool\030\002 \001(\0132\t.ExprBoolH\000\022 \n\ne" +
+                        "xpr_const\030\003 \001(\0132\n.ExprConstH\000\022\'\n\016expr_fi" +
+                        "eld_ref\030\004 \001(\0132\r.ExprFieldRefH\000B\006\n\004node\"Q" +
+                        "\n\017StartTxnRequest\022\032\n\010txn_mode\030\001 \001(\0162\010.Tx" +
+                        "nMode\022\025\n\010read_vid\030\002 \001(\004H\000\210\001\001B\013\n\t_read_vi" +
+                        "d\"P\n\020StartTxnResponse\022\017\n\007success\030\001 \001(\010\022\013" +
+                        "\n\003vid\030\002 \001(\004\022\023\n\006txn_id\030\003 \001(\004H\000\210\001\001B\t\n\007_txn" +
+                        "_id\"]\n\017SnapshotRequest\022\014\n\004name\030\001 \001(\t\022\020\n\003" +
+                        "vid\030\002 \001(\004H\000\210\001\001\022\025\n\010override\030\003 \001(\010H\001\210\001\001B\006\n" +
+                        "\004_vidB\013\n\t_override\"0\n\020SnapshotResponse\022\017" +
+                        "\n\007success\030\001 \001(\010\022\013\n\003vid\030\002 \001(\004\"M\n\014CloneReq" +
+                        "uest\022\020\n\010src_path\030\001 \001(\t\022\021\n\tdest_path\030\002 \001(" +
+                        "\t\022\020\n\003vid\030\003 \001(\004H\000\210\001\001B\006\n\004_vid\"-\n\rCloneResp" +
+                        "onse\022\017\n\007success\030\001 \001(\010\022\013\n\003vid\030\002 \001(\004\"!\n\021Ge" +
+                        "tGarbageRequest\022\014\n\004path\030\001 \001(\t\"%\n\022GetGarb" +
+                        "ageResponse\022\017\n\007garbage\030\001 \003(\014\"#\n\023ClearGar" +
+                        "bageRequest\022\014\n\004pids\030\001 \003(\003\"\'\n\024ClearGarbag" +
+                        "eResponse\022\017\n\007success\030\001 \001(\010\"2\n\021DefineType" +
+                        "Request\022\035\n\010type_def\030\001 \001(\0132\013.ObjTypeDef\"%" +
+                        "\n\022DefineTypeResponse\022\017\n\007success\030\001 \001(\010\"\313\001" +
+                        "\n\023ExecuteQueryRequest\022\021\n\tbase_only\030\001 \001(\010" +
+                        "\022\020\n\003vid\030\002 \001(\004H\001\210\001\001\022\023\n\006txn_id\030\003 \001(\004H\002\210\001\001\022" +
+                        "\030\n\013return_type\030\004 \001(\rH\003\210\001\001\022\037\n\nparse_tree\030" +
+                        "\005 \001(\0132\t.PathExprH\000\022\023\n\tquery_str\030\006 \001(\tH\000B" +
+                        "\007\n\005queryB\006\n\004_vidB\t\n\007_txn_idB\016\n\014_return_t" +
+                        "ype\"\236\001\n\024ExecuteQueryResponse\022\020\n\010leaf_obj" +
+                        "\030\001 \001(\010\022\021\n\tbase_only\030\002 \001(\010\022\013\n\003vid\030\003 \001(\004\022\020" +
+                        "\n\010obj_list\030\004 \001(\014\022\022\n\005abort\030\005 \001(\010H\000\210\001\001\022$\n\013" +
+                        "compression\030\006 \001(\0162\017.BufCompressionB\010\n\006_a" +
+                        "bort\"X\n\rCommitRequest\022\016\n\006txn_id\030\001 \001(\004\022\031\n" +
+                        "\twrite_set\030\002 \003(\0132\006.Write\022\022\n\005abort\030\003 \001(\010H" +
+                        "\000\210\001\001B\010\n\006_abort\"5\n\016CommitResponse\022\017\n\007succ" +
+                        "ess\030\001 \001(\010\022\022\n\ncommit_vid\030\002 \001(\004\"=\n\020PreComm" +
+                        "itRequest\022\016\n\006txn_id\030\001 \001(\004\022\031\n\twrite_set\030\002" +
+                        " \003(\0132\006.Write\"$\n\021PreCommitResponse\022\017\n\007suc" +
+                        "cess\030\001 \001(\010\"#\n\017BulkLoadRequest\022\020\n\010obj_lis" +
+                        "t\030\001 \003(\014\"=\n\020BulkLoadResponse\022\017\n\007success\030\001" +
+                        " \001(\010\022\013\n\003vid\030\002 \001(\004\022\013\n\003err\030\003 \003(\t*:\n\007TxnMod" +
+                        "e\022\026\n\022TXN_MODE_READ_ONLY\020\000\022\027\n\023TXN_MODE_RE" +
+                        "AD_WRITE\020\001*u\n\010LockMode\022\020\n\014LOCK_MODE_NL\020\000" +
+                        "\022\020\n\014LOCK_MODE_IS\020\001\022\020\n\014LOCK_MODE_IX\020\002\022\017\n\013" +
+                        "LOCK_MODE_S\020\003\022\021\n\rLOCK_MODE_SIX\020\004\022\017\n\013LOCK" +
+                        "_MODE_X\020\005*c\n\tWriteType\022\022\n\016WRITE_TYPE_ADD" +
+                        "\020\000\022\025\n\021WRITE_TYPE_REMOVE\020\001\022\024\n\020WRITE_TYPE_" +
+                        "MERGE\020\002\022\025\n\021WRITE_TYPE_UPDATE\020\003*\227\001\n\013ObjTy" +
+                        "peName\022\032\n\026OBJ_TYPE_NAME_DATABASE\020\000\022\027\n\023OB" +
+                        "J_TYPE_NAME_TABLE\020\001\022\033\n\027OBJ_TYPE_NAME_PAR" +
+                        "TITION\020\002\022\035\n\031OBJ_TYPE_NAME_FILE_OBJECT\020\003\022" +
+                        "\027\n\023OBJ_TYPE_NAME_OTHER\020\004*\034\n\010Wildcard\022\020\n\014" +
+                        "WILDCARD_ANY\020\000*\301\002\n\nExprOpType\022\025\n\021EXPR_OP" +
+                        "_TYPE_LESS\020\000\022\030\n\024EXPR_OP_TYPE_GREATER\020\001\022\027" +
+                        "\n\023EXPR_OP_TYPE_EQUALS\020\002\022\034\n\030EXPR_OP_TYPE_" +
+                        "LESS_EQUALS\020\003\022\037\n\033EXPR_OP_TYPE_GREATER_EQ" +
+                        "UALS\020\004\022\033\n\027EXPR_OP_TYPE_NOT_EQUALS\020\005\022\025\n\021E" +
+                        "XPR_OP_TYPE_PLUS\020\006\022\026\n\022EXPR_OP_TYPE_MINUS" +
+                        "\020\007\022\025\n\021EXPR_OP_TYPE_MULT\020\010\022\024\n\020EXPR_OP_TYP" +
+                        "E_DIV\020\t\022\031\n\025EXPR_OP_TYPE_ENDSWITH\020\n\022\026\n\022EX" +
+                        "PR_OP_TYPE_OTHER\020\013*U\n\014ExprBoolType\022\025\n\021EX" +
+                        "PR_BOOL_TYPE_OR\020\000\022\026\n\022EXPR_BOOL_TYPE_AND\020" +
+                        "\001\022\026\n\022EXPR_BOOL_TYPE_NOT\020\002*\313\001\n\rExprConstT" +
+                        "ype\022\032\n\026EXPR_CONST_TYPE_STRING\020\000\022\027\n\023EXPR_" +
+                        "CONST_TYPE_INT\020\001\022\030\n\024EXPR_CONST_TYPE_LONG" +
+                        "\020\002\022\032\n\026EXPR_CONST_TYPE_DOUBLE\020\003\022\033\n\027EXPR_C" +
+                        "ONST_TYPE_BOOLEAN\020\004\022\030\n\024EXPR_CONST_TYPE_D" +
+                        "ATE\020\005\022\030\n\024EXPR_CONST_TYPE_NULL\020\006*D\n\016BufCo" +
+                        "mpression\022\026\n\022BUF_NO_COMPRESSION\020\000\022\032\n\026BUF" +
+                        "_SNAPPY_COMPRESSION\020\0012\223\004\n\013GRPCCatalog\022/\n" +
+                        "\010StartTxn\022\020.StartTxnRequest\032\021.StartTxnRe" +
+                        "sponse\022/\n\010Snapshot\022\020.SnapshotRequest\032\021.S" +
+                        "napshotResponse\022&\n\005Clone\022\r.CloneRequest\032" +
+                        "\016.CloneResponse\0225\n\nGetGarbage\022\022.GetGarba" +
+                        "geRequest\032\023.GetGarbageResponse\022;\n\014ClearG" +
+                        "arbage\022\024.ClearGarbageRequest\032\025.ClearGarb" +
+                        "ageResponse\0225\n\nDefineType\022\022.DefineTypeRe" +
+                        "quest\032\023.DefineTypeResponse\022=\n\014ExecuteQue" +
+                        "ry\022\024.ExecuteQueryRequest\032\025.ExecuteQueryR" +
+                        "esponse0\001\022)\n\006Commit\022\016.CommitRequest\032\017.Co" +
+                        "mmitResponse\0222\n\tPreCommit\022\021.PreCommitReq" +
+                        "uest\032\022.PreCommitResponse\0221\n\010BulkLoad\022\020.B" +
+                        "ulkLoadRequest\032\021.BulkLoadResponse(\001b\006pro" +
+                        "to3"
+        };
+        descriptor = com.google.protobuf.Descriptors.FileDescriptor
+                .internalBuildGeneratedFileFrom(descriptorData,
+                        new com.google.protobuf.Descriptors.FileDescriptor[] {
+                        });
+        internal_static_Field_descriptor =
+                getDescriptor().getMessageTypes().get(0);
+        internal_static_Field_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_Field_descriptor,
+                new java.lang.String[] { "FieldName", "FieldValue", "FieldValue", });
+        internal_static_FieldDef_descriptor =
+                getDescriptor().getMessageTypes().get(1);
+        internal_static_FieldDef_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_FieldDef_descriptor,
+                new java.lang.String[] { "FieldName", "FieldDef", });
+        internal_static_ExtObjTypeName_descriptor =
+                getDescriptor().getMessageTypes().get(2);
+        internal_static_ExtObjTypeName_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExtObjTypeName_descriptor,
+                new java.lang.String[] { "ObjTypeName", "Extension", "Extension", });
+        internal_static_ObjTypeDef_descriptor =
+                getDescriptor().getMessageTypes().get(3);
+        internal_static_ObjTypeDef_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ObjTypeDef_descriptor,
+                new java.lang.String[] { "ExtObjTypeName", "FieldDefs", });
+        internal_static_Children_descriptor =
+                getDescriptor().getMessageTypes().get(4);
+        internal_static_Children_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_Children_descriptor,
+                new java.lang.String[] { "ExtObjTypeName", "Oids", });
+        internal_static_Write_descriptor =
+                getDescriptor().getMessageTypes().get(5);
+        internal_static_Write_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_Write_descriptor,
+                new java.lang.String[] { "Type", "IsLeaf", "WriteValue", "Trigger", "Args", "ParseTree", "PathStr", "Path", "Trigger", });
+        internal_static_PathExpr_descriptor =
+                getDescriptor().getMessageTypes().get(6);
+        internal_static_PathExpr_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_PathExpr_descriptor,
+                new java.lang.String[] { "Preds", "LockModes", "OptionalPred", "OptionalPred", });
+        internal_static_Predicate_descriptor =
+                getDescriptor().getMessageTypes().get(7);
+        internal_static_Predicate_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_Predicate_descriptor,
+                new java.lang.String[] { "ExprNode", "Wildcard", "Pred", });
+        internal_static_ExprOp_descriptor =
+                getDescriptor().getMessageTypes().get(8);
+        internal_static_ExprOp_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExprOp_descriptor,
+                new java.lang.String[] { "OpType", "Right", "Left", "Left", });
+        internal_static_ExprBool_descriptor =
+                getDescriptor().getMessageTypes().get(9);
+        internal_static_ExprBool_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExprBool_descriptor,
+                new java.lang.String[] { "OpType", "Args", });
+        internal_static_ExprConst_descriptor =
+                getDescriptor().getMessageTypes().get(10);
+        internal_static_ExprConst_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExprConst_descriptor,
+                new java.lang.String[] { "ConstType", "StringVal", "Int32Val", "Int64Val", "DoubleVal", "BoolVal", "Value", });
+        internal_static_ExprFieldRef_descriptor =
+                getDescriptor().getMessageTypes().get(11);
+        internal_static_ExprFieldRef_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExprFieldRef_descriptor,
+                new java.lang.String[] { "FieldRefs", });
+        internal_static_ExprNode_descriptor =
+                getDescriptor().getMessageTypes().get(12);
+        internal_static_ExprNode_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExprNode_descriptor,
+                new java.lang.String[] { "ExprOp", "ExprBool", "ExprConst", "ExprFieldRef", "Node", });
+        internal_static_StartTxnRequest_descriptor =
+                getDescriptor().getMessageTypes().get(13);
+        internal_static_StartTxnRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_StartTxnRequest_descriptor,
+                new java.lang.String[] { "TxnMode", "ReadVid", "ReadVid", });
+        internal_static_StartTxnResponse_descriptor =
+                getDescriptor().getMessageTypes().get(14);
+        internal_static_StartTxnResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_StartTxnResponse_descriptor,
+                new java.lang.String[] { "Success", "Vid", "TxnId", "TxnId", });
+        internal_static_SnapshotRequest_descriptor =
+                getDescriptor().getMessageTypes().get(15);
+        internal_static_SnapshotRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_SnapshotRequest_descriptor,
+                new java.lang.String[] { "Name", "Vid", "Override", "Vid", "Override", });
+        internal_static_SnapshotResponse_descriptor =
+                getDescriptor().getMessageTypes().get(16);
+        internal_static_SnapshotResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_SnapshotResponse_descriptor,
+                new java.lang.String[] { "Success", "Vid", });
+        internal_static_CloneRequest_descriptor =
+                getDescriptor().getMessageTypes().get(17);
+        internal_static_CloneRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_CloneRequest_descriptor,
+                new java.lang.String[] { "SrcPath", "DestPath", "Vid", "Vid", });
+        internal_static_CloneResponse_descriptor =
+                getDescriptor().getMessageTypes().get(18);
+        internal_static_CloneResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_CloneResponse_descriptor,
+                new java.lang.String[] { "Success", "Vid", });
+        internal_static_GetGarbageRequest_descriptor =
+                getDescriptor().getMessageTypes().get(19);
+        internal_static_GetGarbageRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_GetGarbageRequest_descriptor,
+                new java.lang.String[] { "Path", });
+        internal_static_GetGarbageResponse_descriptor =
+                getDescriptor().getMessageTypes().get(20);
+        internal_static_GetGarbageResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_GetGarbageResponse_descriptor,
+                new java.lang.String[] { "Garbage", });
+        internal_static_ClearGarbageRequest_descriptor =
+                getDescriptor().getMessageTypes().get(21);
+        internal_static_ClearGarbageRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ClearGarbageRequest_descriptor,
+                new java.lang.String[] { "Pids", });
+        internal_static_ClearGarbageResponse_descriptor =
+                getDescriptor().getMessageTypes().get(22);
+        internal_static_ClearGarbageResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ClearGarbageResponse_descriptor,
+                new java.lang.String[] { "Success", });
+        internal_static_DefineTypeRequest_descriptor =
+                getDescriptor().getMessageTypes().get(23);
+        internal_static_DefineTypeRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_DefineTypeRequest_descriptor,
+                new java.lang.String[] { "TypeDef", });
+        internal_static_DefineTypeResponse_descriptor =
+                getDescriptor().getMessageTypes().get(24);
+        internal_static_DefineTypeResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_DefineTypeResponse_descriptor,
+                new java.lang.String[] { "Success", });
+        internal_static_ExecuteQueryRequest_descriptor =
+                getDescriptor().getMessageTypes().get(25);
+        internal_static_ExecuteQueryRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExecuteQueryRequest_descriptor,
+                new java.lang.String[] { "BaseOnly", "Vid", "TxnId", "ReturnType", "ParseTree", "QueryStr", "Query", "Vid", "TxnId", "ReturnType", });
+        internal_static_ExecuteQueryResponse_descriptor =
+                getDescriptor().getMessageTypes().get(26);
+        internal_static_ExecuteQueryResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_ExecuteQueryResponse_descriptor,
+                new java.lang.String[] { "LeafObj", "BaseOnly", "Vid", "ObjList", "Abort", "Compression", "Abort", });
+        internal_static_CommitRequest_descriptor =
+                getDescriptor().getMessageTypes().get(27);
+        internal_static_CommitRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_CommitRequest_descriptor,
+                new java.lang.String[] { "TxnId", "WriteSet", "Abort", "Abort", });
+        internal_static_CommitResponse_descriptor =
+                getDescriptor().getMessageTypes().get(28);
+        internal_static_CommitResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_CommitResponse_descriptor,
+                new java.lang.String[] { "Success", "CommitVid", });
+        internal_static_PreCommitRequest_descriptor =
+                getDescriptor().getMessageTypes().get(29);
+        internal_static_PreCommitRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_PreCommitRequest_descriptor,
+                new java.lang.String[] { "TxnId", "WriteSet", });
+        internal_static_PreCommitResponse_descriptor =
+                getDescriptor().getMessageTypes().get(30);
+        internal_static_PreCommitResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_PreCommitResponse_descriptor,
+                new java.lang.String[] { "Success", });
+        internal_static_BulkLoadRequest_descriptor =
+                getDescriptor().getMessageTypes().get(31);
+        internal_static_BulkLoadRequest_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_BulkLoadRequest_descriptor,
+                new java.lang.String[] { "ObjList", });
+        internal_static_BulkLoadResponse_descriptor =
+                getDescriptor().getMessageTypes().get(32);
+        internal_static_BulkLoadResponse_fieldAccessorTable = new
+                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
+                internal_static_BulkLoadResponse_descriptor,
+                new java.lang.String[] { "Success", "Vid", "Err", });
+    }
+
+    // @@protoc_insertion_point(outer_class_scope)
+}
diff --git a/tree/src/main/proto/grpccatalog.proto b/tree/src/main/proto/grpccatalog.proto
new file mode 100644
index 00000000000..b3ddbfd451d
--- /dev/null
+++ b/tree/src/main/proto/grpccatalog.proto
@@ -0,0 +1,422 @@
+syntax = "proto3";
+
+enum TxnMode {
+    TXN_MODE_READ_ONLY = 0;
+    TXN_MODE_READ_WRITE = 1;
+}
+
+enum LockMode {
+    LOCK_MODE_NL = 0;
+    LOCK_MODE_IS = 1;
+    LOCK_MODE_IX = 2;
+    LOCK_MODE_S = 3;
+    LOCK_MODE_SIX = 4;
+    LOCK_MODE_X = 5;
+}
+
+enum WriteType {
+    WRITE_TYPE_ADD = 0;
+    WRITE_TYPE_REMOVE = 1;
+    WRITE_TYPE_MERGE =  2;
+    WRITE_TYPE_UPDATE = 3;
+}
+
+/*
+ * List of default types + OTHER for extended types.
+ * TODO:    1. Potentially extend the default types supported.
+ *          2. Rename to ObjTypeName.
+ */
+enum ObjTypeName {
+    OBJ_TYPE_NAME_DATABASE = 0;
+    OBJ_TYPE_NAME_TABLE = 1;
+    OBJ_TYPE_NAME_PARTITION = 2;
+    OBJ_TYPE_NAME_FILE_OBJECT = 3;
+    OBJ_TYPE_NAME_OTHER = 4;
+}
+
+enum Wildcard {
+    // match any object in the given level
+    WILDCARD_ANY = 0;
+}
+
+/*
+ * type of unary/binary operators for ExprOp parse tree nodes
+ */
+enum ExprOpType {
+    EXPR_OP_TYPE_LESS = 0;
+    EXPR_OP_TYPE_GREATER = 1;
+    EXPR_OP_TYPE_EQUALS = 2;
+    EXPR_OP_TYPE_LESS_EQUALS = 3;
+    EXPR_OP_TYPE_GREATER_EQUALS = 4;
+    EXPR_OP_TYPE_NOT_EQUALS = 5;
+    EXPR_OP_TYPE_PLUS = 6;
+    EXPR_OP_TYPE_MINUS = 7;
+    EXPR_OP_TYPE_MULT = 8;
+    EXPR_OP_TYPE_DIV = 9;
+    EXPR_OP_TYPE_ENDSWITH = 10;
+    EXPR_OP_TYPE_OTHER = 11;
+}
+
+/*
+ * type of boolean operators for ExprBool parse tree nodes
+ */
+enum ExprBoolType {
+    EXPR_BOOL_TYPE_OR = 0;
+    EXPR_BOOL_TYPE_AND = 1;
+    EXPR_BOOL_TYPE_NOT = 2;
+}
+
+/*
+ * type of constant for ExprConst parse tree nodes
+ */
+enum ExprConstType {
+    EXPR_CONST_TYPE_STRING = 0;
+    EXPR_CONST_TYPE_INT = 1;
+    EXPR_CONST_TYPE_LONG = 2;
+    EXPR_CONST_TYPE_DOUBLE = 3;
+    EXPR_CONST_TYPE_BOOLEAN = 4;
+    EXPR_CONST_TYPE_DATE = 5;
+    EXPR_CONST_TYPE_NULL = 6;
+}
+
+
+enum BufCompression {
+    BUF_NO_COMPRESSION = 0;
+    BUF_SNAPPY_COMPRESSION = 1;
+}
+
+/*
+ * a field has a name and the corresponding value, if absent, is
+ * considered NULL
+ */
+message Field {
+    string field_name = 1;
+    optional string field_value = 2;
+}
+
+/*
+ * field definition has field name and the corresponding
+ * definition, which is required.
+ */
+message FieldDef {
+    string field_name = 1;
+    // Potentially change this to enum.
+    string field_def = 2;
+}
+
+/*
+ * an extended typename has an extension if obj_type_name is OTHER
+ */
+message ExtObjTypeName {
+    ObjTypeName obj_type_name = 1;
+    optional string extension = 2;
+}
+
+/*
+ * A type definition has a extended type name and a list of field
+ * definitions.
+ * TODO(LATER): Add more information to parse the type.
+ */
+message ObjTypeDef {
+    ExtObjTypeName ext_obj_type_name = 1;
+    repeated FieldDef field_defs = 2;
+}
+
+/*
+ * Children consists of their extended type name and list of oids.
+ */
+message Children {
+    ExtObjTypeName ext_obj_type_name = 1;
+    repeated int64 oids = 2;
+}
+
+/*
+ * When we use OCC for concurrency control, we need to specify the
+ * delta/change of the object, which is change (merge, update) in the object
+ * attributes, addition, or removal of the object. parse tree can be
+ * optionally selected for removal as we still do not have a parser for path
+ * expression...
+ * write_values is the actual delta or value of the object. trigger is a stored
+ * procedure that has to be execute upon writing the object.
+ *
+ * TODO: remove parse_tree option after building a parser.
+ */
+message Write {
+    WriteType type = 1;
+    bool is_leaf = 2;
+    bytes write_value = 3;
+    optional string trigger = 4;
+    repeated string args = 5;
+    oneof path {
+        PathExpr parse_tree = 6;
+        string path_str = 7;
+    }
+}
+
+
+/*
+ * Parse tree representation of the query path expression.
+ * Path experession is a list of predicates, followed by an
+ * optional one. vid is optional and if absent, latest version
+ * is used
+ */
+message PathExpr {
+    repeated Predicate preds = 1;
+    repeated LockMode lock_modes = 2;
+    optional ExprNode optional_pred = 3;
+
+}
+
+/*
+ * A predicate is either an expression, oid, or a wildcard.
+ */
+message Predicate {
+    oneof pred {
+        ExprNode expr_node = 1;
+        Wildcard wildcard = 2;
+    }
+}
+
+/*
+ * Expression node where the highest level operator is binary/unary.
+ * Left is absent if the operator is unary.
+ */
+message ExprOp {
+    ExprOpType op_type = 1;
+    ExprNode right = 2;
+    optional ExprNode left = 3;
+}
+
+/*
+ * Expression node where the highest level operator is a boolean
+ * operator.
+ */
+message ExprBool {
+    ExprBoolType op_type = 1;
+    repeated ExprNode args = 2;
+}
+
+/*
+ * Expression node that is a constant.
+ */
+message ExprConst {
+    ExprConstType const_type = 1;
+    oneof value {
+        string string_val = 2;
+        int32 int32_val = 3;
+        int64 int64_val = 4;
+        double double_val = 5;
+        bool bool_val = 6;
+    }
+}
+
+/*
+ * Expression node that is a field reference.
+ */
+message ExprFieldRef {
+    repeated string field_refs = 1;
+}
+
+/*
+ * General expression node.
+ */
+message ExprNode {
+    oneof node {
+        ExprOp expr_op = 1;
+        ExprBool expr_bool = 2;
+        ExprConst expr_const = 3;
+        ExprFieldRef expr_field_ref = 4;
+    }
+}
+
+/*
+ * Start transaction in either READ or READ_WRITE mode.
+ * TODO txn_mode is ignored for now, will support READ only txn in the future
+ */
+message StartTxnRequest {
+    TxnMode txn_mode = 1;
+    optional uint64 read_vid = 2;
+}
+
+/*
+ * Whether operation was successful and the vid of the version at which
+ * the transaction is to be performed and txn_id of the txn object.
+ */
+message StartTxnResponse {
+    bool success = 1;
+    uint64 vid = 2;
+    optional uint64 txn_id = 3;
+}
+
+/*
+ * Path of the object to take a snapshot of. Name is the name of the
+ * snapshot. If vid is not specified, the latest version is used.
+ */
+message SnapshotRequest {
+    string name = 1;
+    optional uint64 vid = 2;
+    optional bool override = 3;
+}
+
+/*
+ * Whether the operation was successful and the vid of the object,
+ * of which snapshot was created.
+ */
+message SnapshotResponse {
+    bool success = 1;
+    uint64 vid = 2;
+}
+
+/*
+ * Source and destination paths of the object to be cloned. If
+ * vid is not given, the latest version is used.
+ */
+message CloneRequest {
+    string src_path = 1;
+    string dest_path = 2;
+    optional uint64 vid = 3;
+}
+
+/*
+ * Whether the operation was successful and the vid of the cloned
+ * object.
+ */
+message CloneResponse {
+    bool success = 1;
+    uint64 vid = 2;
+}
+
+/*
+ * Path of the object for which garbage is to be collected.
+ */
+message GetGarbageRequest {
+    string path = 1;
+}
+
+/*
+ * Leaf objects that no longer belong to any active version of
+ * inner objects
+ */
+message GetGarbageResponse {
+    repeated bytes garbage = 1;
+}
+
+/*
+ * Physical ID of leaf objects to be deleted.
+ */
+message ClearGarbageRequest {
+    repeated int64 pids = 1;
+}
+
+/*
+ * Whether leaf objects were safely deleted.
+ */
+message ClearGarbageResponse {
+    bool success = 1;
+}
+
+/*
+ * Type definition, defined by the caller/user.
+ */
+message DefineTypeRequest {
+    ObjTypeDef type_def  = 1;
+}
+
+/*
+ * Whether type was successfully defined.
+ */
+message DefineTypeResponse {
+    bool success = 1;
+}
+
+/*
+ * Query is either in a parse tree or string form.
+ * base specifies whether only base objects are to be returned
+ */
+message ExecuteQueryRequest {
+    bool base_only = 1;
+    // vid is ignored if txn_id is set and valid
+    optional uint64 vid = 2;
+    optional uint64 txn_id = 3;
+    optional uint32 return_type = 4;
+    oneof query {
+        PathExpr parse_tree = 5;
+        string query_str = 6;
+    }
+
+}
+
+/*
+ * Query result is either a set of inner objects, leaf objects, or
+ * base objects.
+    */
+message ExecuteQueryResponse {
+    bool leaf_obj = 1;
+    bool base_only = 2;
+    uint64 vid = 3;
+    bytes obj_list = 4;
+    optional bool abort = 5;
+    BufCompression compression = 6;
+}
+
+/*
+ * Default concurrency control mechanism is OCC for now.
+ */
+message CommitRequest {
+    uint64 txn_id = 1;
+    repeated Write write_set = 2;
+    optional bool abort = 3;
+}
+
+/*
+ * Whether commit was succesful.
+ */
+message CommitResponse {
+    bool success = 1;
+    uint64 commit_vid = 2;
+}
+
+/*
+ * Default concurrency control mechanism is OCC for now.
+ */
+message PreCommitRequest {
+    uint64 txn_id = 1;
+    repeated Write write_set = 2;
+}
+
+/*
+ * Whether precommit was succesful.
+ */
+message PreCommitResponse {
+    bool success = 1;
+}
+
+/*
+ * Each message contains multiple objects
+ */
+message BulkLoadRequest {
+    repeated bytes obj_list = 1;
+}
+
+/*
+ * The response informs whether the bulkload operation was successful and the vid of the operation.
+ * Otherwise, the list of error messages (e.g. parents missing)
+ */
+message BulkLoadResponse {
+	bool success = 1;
+	uint64 vid = 2;
+	repeated string err = 3;
+}
+
+service GRPCCatalog {
+    rpc StartTxn(StartTxnRequest) returns (StartTxnResponse);
+    rpc Snapshot(SnapshotRequest) returns (SnapshotResponse);
+    rpc Clone(CloneRequest) returns (CloneResponse);
+    rpc GetGarbage(GetGarbageRequest) returns (GetGarbageResponse);
+    rpc ClearGarbage(ClearGarbageRequest) returns (ClearGarbageResponse);
+    rpc DefineType(DefineTypeRequest) returns (DefineTypeResponse);
+    rpc ExecuteQuery(ExecuteQueryRequest) returns (stream ExecuteQueryResponse);
+    rpc Commit(CommitRequest) returns (CommitResponse);
+    rpc PreCommit(PreCommitRequest) returns (PreCommitResponse);
+    rpc BulkLoad(stream BulkLoadRequest) returns (BulkLoadResponse);
+}
\ No newline at end of file
diff --git a/tree/src/main/scala/org/apache/spark/tree/TreeExternalCatalog.scala b/tree/src/main/scala/org/apache/spark/tree/TreeExternalCatalog.scala
new file mode 100644
index 00000000000..167028d7e3e
--- /dev/null
+++ b/tree/src/main/scala/org/apache/spark/tree/TreeExternalCatalog.scala
@@ -0,0 +1,2518 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.tree
+
+import java.net.URI
+import java.nio.ByteBuffer
+
+import scala.collection.immutable
+import scala.collection.mutable
+import scala.collection.mutable.ArrayBuffer
+import scala.util.matching.Regex
+
+import com.google.protobuf.ByteString
+import io.grpc.ManagedChannel
+import io.grpc.ManagedChannelBuilder
+import org.apache.hadoop.fs.FileStatus
+import org.apache.hadoop.fs.Path
+import org.bson.BsonArray
+import org.bson.BsonBinaryWriter
+import org.bson.BsonDocument
+import org.bson.BsonType
+import org.bson.BsonValue
+import org.bson.RawBsonDocument
+import org.bson.io.BasicOutputBuffer
+import org.bson.json.JsonMode
+import org.bson.json.JsonWriterSettings
+import org.json4s.CustomSerializer
+import org.json4s.JsonAST.JNull
+import org.json4s.JsonAST.JObject
+import org.json4s.JsonAST.JString
+import org.json4s.NoTypeHints
+import org.json4s.jackson.Serialization
+import org.xerial.snappy.Snappy
+
+import org.apache.spark.internal.Logging
+import org.apache.spark.sql.catalyst.TableIdentifier
+import org.apache.spark.sql.catalyst.analysis.UnresolvedFunction
+import org.apache.spark.sql.catalyst.catalog._
+import org.apache.spark.sql.catalyst.expressions._
+import org.apache.spark.sql.catalyst.util.DateFormatter
+import org.apache.spark.sql.types._
+import org.apache.spark.tree.grpc.Grpccatalog
+import org.apache.spark.tree.grpc.Grpccatalog._
+import org.apache.spark.tree.grpc.Grpccatalog.Predicate
+import org.apache.spark.tree.grpc.GRPCCatalogGrpc
+import org.apache.spark.unsafe.types.UTF8String
+
+
+// custom serde that should be much faster than jackson
+private[spark] object TreeSerde {
+  private val jsonWriterSetting : JsonWriterSettings = JsonWriterSettings.builder().
+    outputMode(JsonMode.RELAXED).build()
+
+  private implicit val formats = Serialization.formats(NoTypeHints) + new HiveURISerializer +
+    new HiveDataTypeSerializer + new HiveMetadataSerializer + new HiveStructTypeSerializer
+
+  private class HiveURISerializer extends CustomSerializer[URI](format =>
+    (
+      {
+        case JString(s) => URI.create(s)
+        case JNull => null
+      },
+      { case x: URI =>
+        JString(x.toString)
+      }
+    )
+  )
+
+  private class HiveDataTypeSerializer extends CustomSerializer[DataType](format =>
+    (
+      {
+        case JObject(o) => DataType.parseDataType(JObject(o))
+        case JNull => null
+      },
+      { case x: DataType =>
+        x.jsonValue
+      }
+    )
+  )
+
+  private class HiveStructTypeSerializer extends CustomSerializer[StructType](format =>
+    (
+      {
+        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[StructType]
+        case JNull => null
+      },
+      { case x: StructType =>
+        x.jsonValue
+      }
+    )
+  )
+
+  private class HiveMetadataSerializer extends CustomSerializer[Metadata](format =>
+    (
+      {
+        case JObject(o) => Metadata.fromJObject(JObject(o))
+        case JNull => null
+      },
+      { case x: Metadata =>
+        Metadata.toJsonValue(x)
+      }
+    )
+  )
+
+  // serializer for CatalogTable
+  def toBson(table : CatalogTable): RawBsonDocument = {
+    val table_prefix = "{\"meta\": {\"paths\": [\"/" + table.identifier.database.get +
+      "/" + table.identifier.table + "\"], }, \"val\": {\"obj_type\": \"table\", "
+    val json_brace : Regex = "\\{".r
+    val table_json = Serialization.write(table)
+    RawBsonDocument.parse(json_brace.replaceFirstIn(table_json, table_prefix) + "}")
+  }
+
+  // serializer for CatalogTablePartition
+  def toBson(objPath : String, table : CatalogTable,
+             partition : CatalogTablePartition): BasicOutputBuffer = {
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+    writer.writeStartDocument()
+
+    writer.writeStartDocument("meta")
+    writer.writeStartArray("paths")
+    writer.writeString(objPath)
+    writer.writeEndArray()
+    writer.writeEndDocument()
+
+    writer.writeStartDocument("val")
+    writer.writeString("obj_type", "partition")
+    writer.writeName("spec")
+    appendBson(writer, partition.spec)
+    writer.writeName("storage")
+    appendBson(writer, partition.storage)
+    writer.writeName("parameters")
+    appendBson(writer, partition.parameters)
+    writer.writeInt64("createTime", partition.createTime)
+    writer.writeInt64("lastAccessTime", partition.lastAccessTime)
+    if (partition.stats.isDefined) {
+      writer.writeName("stats")
+      appendBson(writer, table, partition.stats.get)
+    }
+    writer.writeEndDocument()
+
+    writer.writeEndDocument()
+    outputBuffer
+  }
+
+  // serializer for CatalogTableFile
+  def toBson(objPath: String, table: CatalogTable,
+             file : CatalogTableFile) : BasicOutputBuffer = {
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+    writer.writeStartDocument()
+
+    writer.writeStartDocument("meta")
+    writer.writeStartArray("paths")
+    writer.writeString(objPath)
+    writer.writeEndArray()
+    writer.writeEndDocument()
+
+    writer.writeStartDocument("val")
+    writer.writeString("obj_type", "file")
+    writer.writeName("storage")
+    appendBson(writer, file.storage)
+    writer.writeName("partitionValues")
+    appendBson(writer, file.partitionValues)
+    writer.writeInt64("size", file.size)
+    writer.writeInt64("modificationTime", file.modificationTime)
+    if (file.stats.isDefined) {
+      writer.writeName("stats")
+      appendBson(writer, table, file.stats.get)
+    }
+    writer.writeName("tags")
+    appendBson(writer, file.tags)
+    writer.writeEndDocument()
+
+    writer.writeEndDocument()
+    outputBuffer
+  }
+
+  // serializer for CatalogStatistics
+  def toBson(objPath: String, table: CatalogTable, stats: CatalogStatistics) : BasicOutputBuffer = {
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+    writer.writeStartDocument()
+
+    writer.writeStartDocument("meta")
+    writer.writeStartArray("paths")
+    writer.writeString(objPath)
+    writer.writeEndArray()
+    writer.writeEndDocument()
+
+    writer.writeStartDocument("val")
+    writer.writeString("obj_type", "stats")
+    writer.writeInt64("sizeInBytes", stats.sizeInBytes.toLong)
+    if (stats.rowCount.isDefined) {
+      writer.writeInt64("rowCount", stats.rowCount.get.toLong)
+    }
+
+    writer.writeStartDocument("colStats")
+    table.schema.fields.foreach{ field =>
+      val colStat = stats.colStats.get(field.name)
+      if (colStat.isDefined) {
+        writer.writeName(field.name)
+        appendBson(writer, field.dataType, colStat.get)
+      }
+    }
+    writer.writeEndDocument()
+    writer.writeEndDocument()
+
+    writer.writeEndDocument()
+    outputBuffer
+  }
+
+  // 4 increment
+  // 5 decrement
+  // 6 min
+  // 7 max
+  def toMergeBson(table: CatalogTable, stats: CatalogStatistics) : BasicOutputBuffer = {
+    val outputBuffer = new BasicOutputBuffer()
+    val writer = new BsonBinaryWriter(outputBuffer)
+
+    writer.writeStartDocument()
+
+    writer.writeStartDocument("sizeInBytes")
+    writer.writeString("op", "4")
+    writer.writeInt64("", stats.sizeInBytes.toLong)
+    writer.writeEndDocument()
+
+    if (stats.rowCount.isDefined) {
+      writer.writeStartDocument("rowCount")
+      writer.writeString("op", "4")
+      writer.writeInt64("", stats.rowCount.get.toLong)
+      writer.writeEndDocument()
+    }
+
+    writer.writeStartDocument("colStats")
+    table.schema.fields.foreach{ field =>
+      val colStat = stats.colStats.get(field.name)
+      if (colStat.isDefined) {
+        writer.writeName(field.name)
+        appendMergeBson(writer, field.dataType, colStat.get)
+      }
+    }
+    writer.writeEndDocument()
+
+    writer.writeEndDocument()
+    outputBuffer
+  }
+
+  private def appendMergeBson(writer : BsonBinaryWriter, dataType: DataType,
+                              colStat : CatalogColumnStat): Unit = {
+    writer.writeStartDocument()
+    // no merge operation for distinct count
+    if (colStat.min.isDefined) {
+      writer.writeStartDocument("min")
+      writer.writeString("op", "6")
+      dataType match {
+        case ByteType => writer.writeInt32("", colStat.min.get.toInt)
+        case ShortType => writer.writeInt32("", colStat.min.get.toInt)
+        case IntegerType => writer.writeInt32("", colStat.min.get.toInt)
+        case LongType => writer.writeInt64("", colStat.min.get.toLong)
+        case BooleanType => writer.writeBoolean("", colStat.min.get.toBoolean)
+        case FloatType => writer.writeDouble("", colStat.min.get.toDouble)
+        case DoubleType => writer.writeDouble("", colStat.min.get.toDouble)
+        case DecimalType() => writer.writeDouble("", colStat.min.get.toDouble)
+        case _ => writer.writeString("", colStat.min.get)
+      }
+      writer.writeEndDocument()
+    }
+    if (colStat.max.isDefined) {
+      writer.writeStartDocument("max")
+      writer.writeString("op", "7")
+      dataType match {
+        case ByteType => writer.writeInt32("", colStat.max.get.toInt)
+        case ShortType => writer.writeInt32("", colStat.max.get.toInt)
+        case IntegerType => writer.writeInt32("", colStat.max.get.toInt)
+        case LongType => writer.writeInt64("", colStat.max.get.toLong)
+        case BooleanType => writer.writeBoolean("", colStat.max.get.toBoolean)
+        case FloatType => writer.writeDouble("", colStat.max.get.toDouble)
+        case DoubleType => writer.writeDouble("", colStat.max.get.toDouble)
+        case DecimalType() => writer.writeDouble("", colStat.max.get.toDouble)
+        case _ => writer.writeString("", colStat.max.get)
+      }
+      writer.writeEndDocument()
+    }
+    if (colStat.nullCount.isDefined) {
+      writer.writeStartDocument("nullCount")
+      writer.writeString("op", "4")
+      writer.writeInt64("", colStat.nullCount.get.toLong)
+      writer.writeEndDocument()
+    }
+
+    // no merge operation for avgLen, .maxLen, histogram, or version
+    writer.writeEndDocument()
+  }
+
+
+  def getPartId(table : CatalogTable, partitionSpec : CatalogTypes.TablePartitionSpec): String = {
+    var partId = ""
+    table.partitionSchema.foreach { partitionColumn =>
+      if (partitionSpec.contains(partitionColumn.name)) {
+        val partitionVal = getPartitionVal(partitionColumn, partitionSpec)
+        partId = partId + "/" +  partitionColumn.name + "=" + partitionVal
+      }
+    }
+
+    partId
+  }
+
+  def getFileId(table : CatalogTable, file : CatalogTableFile): String = {
+    var fileId = ""
+    table.partitionSchema.foreach { partitionColumn =>
+      val partitionVal = getPartitionVal(partitionColumn, file.partitionValues)
+      fileId = fileId + "/" +  partitionColumn.name + "=" + partitionVal
+    }
+    val filePath = file.storage.locationUri.get.toString
+    fileId + filePath.slice(filePath.lastIndexOf('/'), filePath.size)
+  }
+
+  // helper function to encode int into 12 char long string
+  def getPartitionVal(partitionColumn: StructField, partitionSpec : Map[String, String]): String = {
+    val partitionValOption = partitionSpec.get(partitionColumn.name)
+    if (partitionColumn.dataType.isInstanceOf[IntegralType]) {
+      if (partitionValOption.isDefined) {
+        "%012d".format(partitionValOption.get.toLong)
+      }
+      else {
+        "DEFAULT"
+      }
+    }
+    else {
+      partitionValOption.getOrElse("DEFAULT")
+    }
+  }
+
+  def appendBson(writer : BsonBinaryWriter, storage : CatalogStorageFormat) : Unit = {
+    writer.writeStartDocument()
+    if (storage.locationUri.isDefined) {
+      writer.writeString("locationUri", storage.locationUri.get.toString)
+    }
+    if (storage.inputFormat.isDefined) {
+      writer.writeString("inputFormat", storage.inputFormat.get)
+    }
+    if (storage.outputFormat.isDefined) {
+      writer.writeString("outputFormat", storage.outputFormat.get)
+    }
+    if (storage.serde.isDefined) {
+      writer.writeString("serde", storage.serde.get)
+    }
+    writer.writeBoolean("compressed", storage.compressed)
+    writer.writeName("properties")
+    appendBson(writer, storage.properties)
+    writer.writeEndDocument()
+  }
+
+  def appendBson(writer : BsonBinaryWriter, map : Map[String, String]) : Unit = {
+    writer.writeStartDocument()
+    map.foreach{ case (key, value) =>
+      writer.writeString(key, value)
+    }
+    writer.writeEndDocument()
+  }
+
+  // first type for statistics, which converts min and max to original data type
+  def appendBson(writer : BsonBinaryWriter, table : CatalogTable,
+                 stats : CatalogStatistics) : Unit = {
+    writer.writeStartDocument()
+    writer.writeInt64("sizeInBytes", stats.sizeInBytes.toLong)
+    if (stats.rowCount.isDefined) {
+      writer.writeInt64("rowCount", stats.rowCount.get.toLong)
+    }
+    writer.writeName("colStats")
+    writer.writeStartDocument()
+
+    table.schema.fields.foreach{ field =>
+      val colStat = stats.colStats.get(field.name)
+      if (colStat.isDefined) {
+        writer.writeName(field.name)
+        appendBson(writer, field.dataType, colStat.get)
+      }
+    }
+
+    writer.writeEndDocument()
+    writer.writeEndDocument()
+  }
+
+  def appendBson(writer : BsonBinaryWriter, dataType: DataType, colStat : CatalogColumnStat):
+      Unit = {
+    writer.writeStartDocument()
+    if (colStat.distinctCount.isDefined) {
+      writer.writeInt64("distinctCount", colStat.distinctCount.get.toLong)
+    }
+    if (colStat.min.isDefined) {
+      dataType match {
+        case ByteType => writer.writeInt32("min", colStat.min.get.toInt)
+        case ShortType => writer.writeInt32("min", colStat.min.get.toInt)
+        case IntegerType => writer.writeInt32("min", colStat.min.get.toInt)
+        case LongType => writer.writeInt64("min", colStat.min.get.toLong)
+        case BooleanType => writer.writeBoolean("min", colStat.min.get.toBoolean)
+        case FloatType => writer.writeDouble("min", colStat.min.get.toDouble)
+        case DoubleType => writer.writeDouble("min", colStat.min.get.toDouble)
+        case DecimalType() => writer.writeDouble("min", colStat.min.get.toDouble)
+        case _ => writer.writeString("min", colStat.min.get)
+      }
+    }
+    if (colStat.max.isDefined) {
+      dataType match {
+        case ByteType => writer.writeInt32("max", colStat.max.get.toInt)
+        case ShortType => writer.writeInt32("max", colStat.max.get.toInt)
+        case IntegerType => writer.writeInt32("max", colStat.max.get.toInt)
+        case LongType => writer.writeInt64("max", colStat.max.get.toLong)
+        case BooleanType => writer.writeBoolean("max", colStat.max.get.toBoolean)
+        case FloatType => writer.writeDouble("max", colStat.max.get.toDouble)
+        case DoubleType => writer.writeDouble("max", colStat.max.get.toDouble)
+        case DecimalType() => writer.writeDouble("max", colStat.max.get.toDouble)
+        case _ => writer.writeString("max", colStat.max.get)
+      }
+    }
+    if (colStat.nullCount.isDefined) {
+      writer.writeInt64("nullCount", colStat.nullCount.get.toLong)
+    }
+    if (colStat.avgLen.isDefined) {
+      writer.writeInt64("avgLen", colStat.avgLen.get)
+    }
+    if (colStat.maxLen.isDefined) {
+      writer.writeInt64("maxLen", colStat.maxLen.get)
+    }
+    // no support for histogram
+    writer.writeInt32("version", colStat.version)
+
+    writer.writeEndDocument()
+  }
+
+  def toCatalogDatabase(bsonDocument : BsonDocument) : CatalogDatabase = {
+    val name = bsonDocument.get("name").asString().getValue
+    val description = bsonDocument.get("description").asString.getValue
+    val locationUri = new URI(bsonDocument.get("locationUri").asString.getValue)
+    val properties = toMap(bsonDocument.get("properties").asDocument())
+
+    CatalogDatabase(name, description, locationUri, properties)
+  }
+
+  def toCatalogTable(bsonDocument : BsonDocument) : CatalogTable = {
+    val identifier = toTableIdentifier(bsonDocument.get("identifier").asDocument())
+    val tableType = toCatalogTableType(bsonDocument.get("tableType").asDocument())
+    val storage = toCatalogStorageFormat(bsonDocument.get("storage").asDocument())
+    val schema = toStructType(bsonDocument.get("schema").asDocument())
+    val provider = {
+      val providerBson = bsonDocument.get("provider")
+      if (providerBson != null) {
+        Some(providerBson.asString().getValue)
+      }
+      else {
+        None
+      }
+    }
+    val partitionColumnNames = toSeq(bsonDocument.get("partitionColumnNames").asArray())
+    val bucketSpec = None
+    val owner = bsonDocument.get("owner").asString().getValue
+    val createTime = bsonDocument.get("createTime").asNumber().longValue()
+    val lastAccessTime = bsonDocument.get("lastAccessTime").asNumber().longValue()
+    val createVersion = bsonDocument.get("createVersion").asString().getValue
+    val properties = toMap(bsonDocument.get("properties").asDocument())
+    val stats : Option[CatalogStatistics] = {
+      val statsBson = bsonDocument.get("stats")
+      if (statsBson != null) {
+        Some(toCatalogStatistics(statsBson.asDocument()))
+      }
+      else {
+        None
+      }
+    }
+    val viewText = {
+      val viewTextBson = bsonDocument.get("viewText")
+      if (viewTextBson != null) {
+        Some(viewTextBson.asString().getValue)
+      }
+      else {
+        None
+      }
+    }
+    val comment = {
+      val commentBson = bsonDocument.get("comment")
+      if (commentBson != null) {
+        Some(commentBson.asString().getValue)
+      }
+      else {
+        None
+      }
+    }
+    val unsupportedFeatures = toSeq(bsonDocument.get("unsupportedFeatures").asArray())
+    val tracksPartitionsInCatalog = bsonDocument.get("tracksPartitionsInCatalog").asBoolean()
+      .getValue
+    val schemaPreservesCase = bsonDocument.get("schemaPreservesCase").asBoolean().getValue
+    val ignoredProperties = toMap(bsonDocument.get("ignoredProperties").asDocument())
+    val viewOriginalText = {
+      val viewOriginalTextBson = bsonDocument.get("viewOriginalText")
+      if (viewOriginalTextBson != null) {
+        Some(viewOriginalTextBson.asString().getValue)
+      }
+      else {
+        None
+      }
+    }
+    CatalogTable(identifier, tableType, storage, schema, provider, partitionColumnNames,
+      bucketSpec, owner, createTime, lastAccessTime, createVersion, properties, stats, viewText,
+      comment, unsupportedFeatures, tracksPartitionsInCatalog, schemaPreservesCase,
+      ignoredProperties, viewOriginalText)
+  }
+
+  // deserializer for CatalogTablePartition
+  def toCatalogTablePartition(bsonDocument : BsonDocument) : CatalogTablePartition = {
+    val spec = toMap(bsonDocument.get("spec").asDocument())
+    val storage = toCatalogStorageFormat(bsonDocument.get("storage").asDocument())
+    val parameters = toMap(bsonDocument.get("parameters").asDocument())
+    val createTime = bsonDocument.get("createTime").asNumber().longValue()
+    val lastAccessTime = bsonDocument.get("lastAccessTime").asNumber().longValue()
+    val stats : Option[CatalogStatistics] = {
+      val statsBson = bsonDocument.get("stats")
+      if (statsBson != null) {
+        Some(toCatalogStatistics(statsBson.asDocument()))
+      }
+      else {
+        None
+      }
+    }
+    CatalogTablePartition(spec, storage, parameters, createTime, lastAccessTime, stats)
+  }
+
+  def toFileStatus(bsonDocument : BsonDocument) : FileStatus = {
+    // scalastyle:off pathfromuri
+    val path = new Path(new URI(bsonDocument.get("storage").asDocument()
+      .get("locationUri").asString().getValue()))
+    // scalastyle:on pathfromuri
+    val size = bsonDocument.get("size").asNumber().longValue()
+    val modificationTime = bsonDocument.get("modificationTime").asNumber().longValue()
+
+    new FileStatus(
+      /* length */ size,
+      /* isDir */ false,
+      /* blockReplication */ 0,
+      /* blockSize */ 1,
+      /* modificationTime */ modificationTime,
+      path)
+  }
+
+  // deserializer for CatalogTableFile
+  def toCatalogTableFile(bsonDocument : BsonDocument) : CatalogTableFile = {
+    val storage = toCatalogStorageFormat(bsonDocument.get("storage").asDocument())
+    val partitionValues = toMap(bsonDocument.get("partitionValues").asDocument())
+    val size = bsonDocument.get("size").asNumber().longValue()
+    val modificationTime = bsonDocument.get("modificationTime").asNumber().longValue()
+    val stats : Option[CatalogStatistics] = {
+      val statsBson = bsonDocument.get("stats")
+      if (statsBson != null) {
+        Some(toCatalogStatistics(statsBson.asDocument()))
+      }
+      else {
+        None
+      }
+    }
+    val tags = toMap(bsonDocument.get("tags").asDocument())
+
+    CatalogTableFile(storage, partitionValues, size, modificationTime, stats, tags)
+
+  }
+
+  private def toTableIdentifier(bsonDocument: BsonDocument) : TableIdentifier = {
+    val table = bsonDocument.get("table").asString().getValue
+    val database = {
+      val databaseBson = bsonDocument.get("database")
+      if (databaseBson != null) {
+        Some(databaseBson.asString().getValue)
+      }
+      else {
+        None
+      }
+    }
+    val catalog = {
+      val catalogBson = bsonDocument.get("catalog")
+      if (catalogBson != null) {
+        Some(catalogBson.asString().getValue)
+      }
+      else {
+        None
+      }
+    }
+    TableIdentifier(table, database, catalog)
+  }
+
+  private def toCatalogTableType(bsonDocument : BsonDocument) : CatalogTableType = {
+    val name = bsonDocument.get("name").asString().getValue
+    name match {
+      case "EXTERNAL" => CatalogTableType.EXTERNAL
+      case "MANAGED" => CatalogTableType.MANAGED
+      case "VIEW" => CatalogTableType.VIEW
+    }
+  }
+
+  private def toStructType(bsonDocument: BsonDocument): StructType = {
+    DataType.fromJson(bsonDocument.toJson(jsonWriterSetting)).asInstanceOf[StructType]
+  }
+
+  private def toSeq(bsonArray : BsonArray) : Seq[String] = {
+    val seq = ArrayBuffer[String]()
+    bsonArray.forEach { elem =>
+      seq.append(elem.asString().getValue)
+    }
+    seq
+  }
+
+  def toCatalogStorageFormat(bsonDocument : BsonDocument) : CatalogStorageFormat = {
+    val locationUri: Option[URI] = {
+      val locationUriBson = bsonDocument.get("locationUri")
+      if (locationUriBson != null) {
+        Some(new URI(locationUriBson.asString().getValue()))
+      }
+      else {
+        None
+      }
+    }
+
+    val inputFormat: Option[String] = {
+      val inputFormatBson = bsonDocument.get("inputFormat")
+      if (inputFormatBson != null) {
+        Some(inputFormatBson.asString().getValue())
+      }
+      else {
+        None
+      }
+    }
+
+    val outputFormat: Option[String] = {
+      val outputFormatBson = bsonDocument.get("outputFormat")
+      if (outputFormatBson != null) {
+        Some(outputFormatBson.asString().getValue())
+      }
+      else {
+        None
+      }
+    }
+
+    val serde: Option[String] = {
+      val serdeBson = bsonDocument.get("serde")
+      if (serdeBson != null) {
+        Some(serdeBson.asString().getValue())
+      }
+      else {
+        None
+      }
+    }
+
+    val compressed = bsonDocument.get("compressed").asBoolean().getValue()
+    val propertiesBson = toMap(bsonDocument.get("properties").asDocument())
+
+    CatalogStorageFormat(locationUri, inputFormat, outputFormat, serde,
+      compressed, propertiesBson)
+  }
+
+  def toMap(bsonDocument : BsonDocument) : immutable.Map[String, String] = {
+    val mutableMap : mutable.Map[String, String] = mutable.Map.empty
+    bsonDocument.forEach{ (key, value) =>
+      mutableMap.put(key, value.asString().getValue())
+    }
+    mutableMap.toMap
+  }
+
+  def toCatalogStatistics(bsonDocument : BsonDocument): CatalogStatistics = {
+    val sizeInBytes = bsonDocument.get("sizeInBytes").asNumber().longValue()
+    val rowCount = {
+      val rowCountBson = bsonDocument.get("rowCount")
+      if (rowCountBson != null) {
+        Some(BigInt(rowCountBson.asNumber().longValue()))
+      }
+      else {
+        None
+      }
+    }
+    val colStatsBson = bsonDocument.get("colStats").asDocument()
+    val colStats : mutable.Map[String, CatalogColumnStat] = mutable.Map.empty
+    colStatsBson.entrySet().forEach{ entry =>
+      colStats.put(entry.getKey, toCatalogColumnStat(entry.getValue.asDocument()))
+    }
+
+    CatalogStatistics(BigInt(sizeInBytes), rowCount, colStats.toMap)
+  }
+
+  private def bsonValToString(bsonVal : BsonValue) : Option[String] = {
+    val bsonType = bsonVal.getBsonType
+    bsonType match {
+      case BsonType.STRING => Some(bsonVal.asString().getValue)
+      case BsonType.INT32 => Some(bsonVal.asInt32().getValue.toString)
+      case BsonType.INT64 => Some(bsonVal.asInt64().getValue.toString)
+      case BsonType.BOOLEAN => Some(bsonVal.asBoolean().getValue.toString)
+      case BsonType.DOUBLE => Some(bsonVal.asDouble().getValue.toString)
+      case _ => None
+    }
+  }
+
+  def toCatalogColumnStat(bsonDocument : BsonDocument) : CatalogColumnStat = {
+    val distinctCount = {
+      val distinctCountBson = bsonDocument.get("distinctCount")
+      if (distinctCountBson != null) {
+        Some(BigInt(distinctCountBson.asNumber().longValue()))
+      }
+      else {
+        None
+      }
+    }
+    val min = {
+      val minBson = bsonDocument.get("min")
+      if (minBson != null) {
+        bsonValToString(minBson)
+      }
+      else {
+        None
+      }
+    }
+    val max = {
+      val maxBson = bsonDocument.get("max")
+      if (maxBson != null) {
+        bsonValToString(maxBson)
+      }
+      else {
+        None
+      }
+    }
+    val nullCount = {
+      val nullCountBson = bsonDocument.get("nullCount")
+      if (nullCountBson != null) {
+        Some(BigInt(nullCountBson.asNumber().longValue()))
+      }
+      else {
+        None
+      }
+    }
+    val avgLen = {
+      val avgLenBson = bsonDocument.get("avgLen")
+      if (avgLenBson != null) {
+        Some(avgLenBson.asNumber().longValue())
+      }
+      else {
+        None
+      }
+    }
+    val maxLen = {
+      val maxLenBson = bsonDocument.get("maxLen")
+      if (maxLenBson != null) {
+        Some(maxLenBson.asNumber().longValue())
+      }
+      else {
+        None
+      }
+    }
+    // we do not support histograms
+    val version = bsonDocument.get("version").asNumber().intValue()
+
+    CatalogColumnStat(distinctCount, min, max, nullCount, avgLen, maxLen, None, version)
+
+  }
+
+  // create empty statistics with default base values so it is mergeable
+  def emptyStats(table : CatalogTable) : CatalogStatistics = {
+    val sizeInBytes = BigInt(0)
+    val rowCount = Some(BigInt(0))
+    val colStats = scala.collection.mutable.Map.empty[String, CatalogColumnStat]
+    val schema = table.schema
+    // exclude partition columns
+    for (i <- 0 until schema.length - table.partitionColumnNames.length) {
+      colStats.put(schema(i).name, emptyColStat(schema(i).dataType))
+    }
+
+    CatalogStatistics(sizeInBytes, rowCount, colStats.toMap)
+
+  }
+
+  private def emptyColStat(dataType : DataType) : CatalogColumnStat = {
+    val min = {
+      dataType match {
+        case ByteType => Some(Byte.MaxValue.toString)
+        case ShortType => Some(Short.MaxValue.toString)
+        case IntegerType => Some(Int.MaxValue.toString)
+        case LongType => Some(Long.MaxValue.toString)
+        case BooleanType => Some("true")
+        case FloatType => Some(Float.MaxValue.toString)
+        case DoubleType => Some(Double.MaxValue.toString)
+        // This should work for most unicode
+        // scalastyle:off
+        case VarcharType(length) => Some("\uFFFF")
+        case StringType => Some("\uFFFF")
+        // scalastyle:on
+        case DecimalType() => Some(Double.MaxValue.toString)
+        case DateType => Some("9999-12-31")
+        // other types are currently not supported
+        case _ => None
+      }
+    }
+    val max = {
+      dataType match {
+        case ByteType => Some(Byte.MinValue.toString)
+        case ShortType => Some(Short.MinValue.toString)
+        case IntegerType => Some(Int.MinValue.toString)
+        case LongType => Some(Long.MinValue.toString)
+        case BooleanType => Some("false")
+        case FloatType => Some(Float.MinValue.toString)
+        case DoubleType => Some(Double.MinValue.toString)
+        case VarcharType(length) => Some("")
+        case StringType => Some("")
+        case DecimalType() => Some(Double.MinValue.toString)
+        case DateType => Some("0000-01-01")
+        // other types are currently not supported
+        case _ => None
+      }
+    }
+    val nullCount = Some(BigInt(0))
+    val version = 1
+
+    CatalogColumnStat(None, min, max, nullCount, None, None, None, version)
+
+  }
+}
+
+// Proxy for keeping track of txn state
+private[spark] class TreeTxn(val txnMode : TxnMode,
+                             val txnId : Option[Long] = None,
+                             val vid : Option[Long] = None,
+                             val commitRequest : Option[CommitRequest.Builder] = None) {
+  private var aborted : Boolean = false
+  private var commit_vid : Option[Long] = None
+  var data_received : Int = 0
+  var data_sent : Int = 0
+
+  def setAbort(abort : Boolean): Unit = {
+    aborted = abort
+  }
+
+  def isOK(): Boolean = {
+    !aborted
+  }
+
+  def setCommitVid(new_vid : Long): Unit = {
+    commit_vid = Some(new_vid)
+  }
+
+  def getCommitVid(): Option[Long] = {
+    commit_vid
+  }
+
+}
+
+private[spark] class TreeExternalCatalog(address : String = "localhost:9876",
+                                         channelOption : Option[ManagedChannel] = None)
+  extends Logging {
+
+  private val addressPort = address.split(":")
+  private val channel = channelOption.getOrElse(
+    ManagedChannelBuilder.forAddress(addressPort(0), addressPort(1).toInt)
+    .usePlaintext()
+    .asInstanceOf[ManagedChannelBuilder[_]].build())
+
+  private val catalogStub: GRPCCatalogGrpc.GRPCCatalogBlockingStub =
+    GRPCCatalogGrpc.newBlockingStub(channel)
+  val json_writer_setting : JsonWriterSettings = JsonWriterSettings.builder().
+    outputMode(JsonMode.RELAXED).build()
+
+  private class BufIterator(buf : Array[Byte]) {
+    private var elem_size_ = 0
+    private var data_idx_ = 0
+    private var next_ = 0
+    private var valid_ = false
+
+    if (buf.length >= Integer.BYTES) {
+      elem_size_ = ByteBuffer.wrap(buf.slice(0, Integer.BYTES)).
+        order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt
+      data_idx_ = Integer.BYTES
+      next_ = Integer.BYTES + elem_size_
+      if (next_ <= buf.size) {
+        valid_ = true
+      }
+    }
+
+    def next() : Boolean = {
+      if (!valid_) {
+        false
+      }
+      else if (next_ + Integer.BYTES >= buf.length) {
+        valid_ = false
+        false
+      }
+      else {
+        elem_size_ = ByteBuffer.wrap(buf.slice(next_, next_ + Integer.BYTES)).
+          order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt()
+        data_idx_ = next_ + Integer.BYTES
+        next_ = data_idx_ + elem_size_
+
+        if (next_ > buf.length) {
+          valid_ = false
+          false
+        }
+        else {
+          valid_ = true
+          true
+        }
+      }
+
+    }
+
+    def valid() : Boolean = {
+      valid_
+    }
+
+    def dataIdx() : Int = {
+      data_idx_
+    }
+
+  }
+
+  private class HiveURISerializer extends CustomSerializer[URI](format =>
+    (
+      {
+        case JString(s) => URI.create(s)
+        case JNull => null
+      },
+      { case x: URI =>
+        JString(x.toString)
+      }
+    )
+  )
+
+  private class HiveDataTypeSerializer extends CustomSerializer[DataType](format =>
+    (
+      {
+        case JObject(o) => DataType.parseDataType(JObject(o))
+        case JNull => null
+      },
+      { case x: DataType =>
+        x.jsonValue
+      }
+    )
+  )
+
+  private class HiveStructTypeSerializer extends CustomSerializer[StructType](format =>
+    (
+      {
+        case JObject(o) => DataType.parseDataType(JObject(o)).asInstanceOf[StructType]
+        case JNull => null
+      },
+      { case x: StructType =>
+        x.jsonValue
+      }
+    )
+  )
+
+  private class HiveMetadataSerializer extends CustomSerializer[Metadata](format =>
+    (
+      {
+        case JObject(o) => Metadata.fromJObject(JObject(o))
+        case JNull => null
+      },
+      { case x: Metadata =>
+        Metadata.toJsonValue(x)
+      }
+    )
+  )
+
+  private def constructBinaryPred(field: String, op : ExprOpType, const_str : String)
+      : Predicate = {
+    Predicate.newBuilder().setExprNode(constructBinaryExpr(field, op, const_str)).build()
+  }
+
+  private def constructBinaryExpr(field: String, op : ExprOpType, const_str : String)
+  : ExprNode = {
+    val nested_fields = field.split("\\.")
+    var expr_field_ref_builder = ExprFieldRef.newBuilder()
+    nested_fields.foreach { nested_field =>
+      expr_field_ref_builder = expr_field_ref_builder.addFieldRefs(nested_field)
+    }
+
+    ExprNode.newBuilder()
+      .setExprOp(ExprOp.newBuilder().setLeft(ExprNode.newBuilder()
+      .setExprFieldRef(expr_field_ref_builder))
+      .setOpType(op).setRight(ExprNode.newBuilder()
+      .setExprConst(ExprConst.newBuilder().setConstType(ExprConstType.EXPR_CONST_TYPE_STRING)
+      .setStringVal(const_str)))).build()
+  }
+
+  private def constructBinaryPred(field: String, op : ExprOpType, const_literal : Literal)
+  : Predicate = {
+    Predicate.newBuilder().setExprNode(constructBinaryExpr(field, op, const_literal)).build()
+  }
+
+  private def constructBinaryExpr(field: String, op : ExprOpType, const_literal : Literal)
+    : ExprNode = {
+    lazy val dateFormatter = DateFormatter()
+
+    val nested_fields = field.split("\\.")
+    var expr_field_ref_builder = ExprFieldRef.newBuilder()
+    nested_fields.foreach { nested_field =>
+      expr_field_ref_builder = expr_field_ref_builder.addFieldRefs(nested_field)
+    }
+
+    var const_builder = ExprConst.newBuilder()
+    const_literal match {
+      case Literal(value, _: IntegralType) =>
+        const_builder = const_builder.setConstType(ExprConstType.EXPR_CONST_TYPE_INT)
+          .setInt32Val(value.toString.toInt)
+      case Literal(value, _: StringType) =>
+        const_builder = const_builder.setConstType(ExprConstType.EXPR_CONST_TYPE_STRING)
+          .setStringVal(value.toString)
+      case Literal(value, _: DateType) =>
+        const_builder = const_builder.setConstType(ExprConstType.EXPR_CONST_TYPE_STRING)
+          .setStringVal(dateFormatter.format(value.asInstanceOf[Int]))
+      case _ => const_builder = const_builder
+    }
+
+    ExprNode.newBuilder()
+      .setExprOp(ExprOp.newBuilder().setLeft(ExprNode.newBuilder()
+          .setExprFieldRef(expr_field_ref_builder))
+        .setOpType(op).setRight(ExprNode.newBuilder()
+          .setExprConst(const_builder))).build()
+  }
+
+  private def quoteStringLiteral(str: String): String = {
+    if (!str.contains("\"")) {
+      s""""$str""""
+    } else if (!str.contains("'")) {
+      s"""'$str'"""
+    } else {
+      s"""'$str'"""
+    }
+  }
+
+  private def convertFilters(table: CatalogTable, filters: Seq[Expression],
+                             part_only : Boolean): PathExpr.Builder = {
+    lazy val dateFormatter = DateFormatter()
+
+    /**
+     * An extractor that matches all binary comparison operators except null-safe equality.
+     *
+     * Null-safe equality is not supported by Hive metastore partition predicate pushdown
+     */
+    object SpecialBinaryComparison {
+      def unapply(e: BinaryComparison): Option[(Expression, Expression)] = e match {
+        case _: EqualNullSafe => None
+        case _ => Some((e.left, e.right))
+      }
+    }
+
+    object ExtractableLiteral {
+      def unapply(expr: Expression): Option[String] = expr match {
+        case Literal(null, _) => None // `null`s can be cast as other types; we want to avoid NPEs.
+        case Literal(value, _: IntegralType) => Some(value.toString)
+        case Literal(value, _: StringType) => Some(value.toString)
+        case Literal(value, _: DateType) =>
+          Some(dateFormatter.format(value.asInstanceOf[Int]))
+        case _ => None
+      }
+    }
+
+    object ConstructableLiteral {
+      def unapply(expr: Expression): Option[Literal] = expr match {
+        case Literal(null, _) => None // `null`s can be cast as other types; we want to avoid NPEs.
+        case Literal(value, int_type: IntegralType) => Some(Literal(value, int_type))
+        case Literal(value, str_type: StringType) => Some(Literal(value, str_type))
+        case Literal(value, date_type: DateType) => Some(Literal(value, date_type))
+        case _ => None
+      }
+    }
+
+    object ExtractableLiterals {
+      def unapply(exprs: Seq[Expression]): Option[Seq[String]] = {
+        // SPARK-24879: The Hive metastore filter parser does not support "null", but we still want
+        // to push down as many predicates as we can while still maintaining correctness.
+        // In SQL, the `IN` expression evaluates as follows:
+        //  > `1 in (2, NULL)` -> NULL
+        //  > `1 in (1, NULL)` -> true
+        //  > `1 in (2)` -> false
+        // Since Hive metastore filters are NULL-intolerant binary operations joined only by
+        // `AND` and `OR`, we can treat `NULL` as `false` and thus rewrite `1 in (2, NULL)` as
+        // `1 in (2)`.
+        // If the Hive metastore begins supporting NULL-tolerant predicates and Spark starts
+        // pushing down these predicates, then this optimization will become incorrect and need
+        // to be changed.
+        val extractables = exprs
+          .filter {
+            case Literal(null, _) => false
+            case _ => true
+          }.map(ExtractableLiteral.unapply)
+        if (extractables.nonEmpty && extractables.forall(_.isDefined)) {
+          Some(extractables.map(_.get))
+        } else {
+          None
+        }
+      }
+    }
+
+    object ConstructableLiterals {
+      def unapply(exprs: Seq[Expression]): Option[Seq[Literal]] = {
+        val constructables = exprs
+          .filter {
+            case Literal(null, _) => false
+            case _ => true
+          }.map(ConstructableLiteral.unapply)
+        if (constructables.nonEmpty && constructables.forall(_.isDefined)) {
+          Some(constructables.map(_.get))
+        } else {
+          None
+        }
+      }
+    }
+
+
+    object ExtractableValues {
+      private lazy val valueToLiteralString: PartialFunction[Any, String] = {
+        case value: Byte => value.toString
+        case value: Short => value.toString
+        case value: Int => value.toString
+        case value: Long => value.toString
+        case value: UTF8String => quoteStringLiteral(value.toString)
+      }
+
+      def unapply(values: Set[Any]): Option[Seq[String]] = {
+        val extractables = values.filter(_ != null).toSeq.map(valueToLiteralString.lift)
+        if (extractables.nonEmpty && extractables.forall(_.isDefined)) {
+          Some(extractables.map(_.get))
+        } else {
+          None
+        }
+      }
+    }
+
+    object ConstructableValues {
+      private lazy val valueToLiteral: PartialFunction[Any, Literal] = {
+        case value: Byte => Literal(value, ByteType)
+        case value: Short => Literal(value, ShortType)
+        case value: Int => Literal(value, IntegerType)
+        case value: Long => Literal(value, LongType)
+        case value: UTF8String => Literal(value.toString, StringType)
+      }
+
+      def unapply(values: Set[Any]): Option[Seq[Literal]] = {
+        val constructables = values.filter(_ != null).toSeq.map(valueToLiteral.lift)
+        if (constructables.nonEmpty && constructables.forall(_.isDefined)) {
+          Some(constructables.map(_.get))
+        } else {
+          None
+        }
+      }
+    }
+
+//    object ExtractableDateValues {
+//      private lazy val valueToLiteralString: PartialFunction[Any, String] = {
+//        case value: Int => dateFormatter.format(value)
+//      }
+//
+//      def unapply(values: Set[Any]): Option[Seq[String]] = {
+//        val extractables = values.filter(_ != null).toSeq.map(valueToLiteralString.lift)
+//        if (extractables.nonEmpty && extractables.forall(_.isDefined)) {
+//          Some(extractables.map(_.get))
+//        } else {
+//          None
+//        }
+//      }
+//    }
+//
+//    object SupportedAttribute {
+//      def unapply(attr: Attribute): Option[String] = {
+//        if (attr.dataType.isInstanceOf[IntegralType] ||
+//          attr.dataType == StringType || attr.dataType == DateType) {
+//          Some(attr.name)
+//        } else {
+//          None
+//        }
+//      }
+//    }
+//
+    def convertInToOr(attr: Attribute, values: Seq[Literal]): Expression = {
+      val false_literal = Literal(false, BooleanType)
+      values.foldLeft(Or(false_literal, false_literal))((or_expr, value)
+          => Or(or_expr, EqualTo(attr, value)))
+    }
+
+    def convertNotInToAnd(attr: Attribute, values: Seq[Literal]): Expression = {
+      val true_literal = Literal(true, BooleanType)
+      values.foldLeft(And(true_literal, true_literal))((and_expr, value)
+          => And(and_expr, Not(EqualTo(attr, value))))
+    }
+
+    def hasNullLiteral(list: Seq[Expression]): Boolean = list.exists {
+      case Literal(null, _) => true
+      case _ => false
+    }
+
+
+    object ExtractAttribute {
+      @scala.annotation.tailrec
+      def unapply(expr: Expression): Option[Attribute] = {
+        expr match {
+          case attr: Attribute => Some(attr)
+          case Cast(child @ IntegralType(), dt: IntegralType, _, _)
+            if Cast.canUpCast(child.dataType.asInstanceOf[AtomicType], dt) => unapply(child)
+          case _ => None
+        }
+      }
+    }
+
+    def convert(col_name: String, is_part_col : Boolean, expr: Expression):
+      Option[ExprNode] = expr match {
+      case Not(In(_, list)) if hasNullLiteral(list) => None
+
+      case Not(InSet(_, list)) if list.contains(null) => None
+
+      case In(ExtractAttribute(attr), ConstructableLiterals(values)) =>
+        convert(col_name, is_part_col, convertInToOr(attr, values))
+
+
+      case Not(In(ExtractAttribute(attr), ConstructableLiterals(values))) =>
+        convert(col_name, is_part_col, convertNotInToAnd(attr, values))
+
+      case InSet(ExtractAttribute(attr), ConstructableValues(values)) =>
+        convert(col_name, is_part_col, convertInToOr(attr, values))
+
+      case Not(InSet(ExtractAttribute(attr), ConstructableValues(values))) =>
+        convert(col_name, is_part_col, convertNotInToAnd(attr, values))
+
+      case UnresolvedFunction(Seq("endswith"), Seq(ExtractAttribute(attr),
+      ConstructableLiteral(value)), _, _, _) =>
+        if (attr.name == col_name && is_part_col) {
+            Some(constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_ENDSWITH,
+              value.value.toString))
+        }
+        else {
+          None
+        }
+
+      case op @ SpecialBinaryComparison(ExtractAttribute(attr), ConstructableLiteral(value)) =>
+        if (attr.name == col_name) {
+          if (is_part_col) {
+            val expr_op_type = op match {
+              case EqualTo(_, _) => ExprOpType.EXPR_OP_TYPE_EQUALS
+              case EqualNullSafe(_, _) => ExprOpType.EXPR_OP_TYPE_EQUALS
+              case LessThan(_, _) => ExprOpType.EXPR_OP_TYPE_LESS
+              case LessThanOrEqual(_, _) => ExprOpType.EXPR_OP_TYPE_LESS_EQUALS
+              case GreaterThan(_, _) => ExprOpType.EXPR_OP_TYPE_GREATER
+              case GreaterThanOrEqual(_, _) => ExprOpType.EXPR_OP_TYPE_GREATER_EQUALS
+            }
+            Some(constructBinaryExpr("obj_id", expr_op_type, value.value.toString))
+          }
+          else {
+            op match {
+              case LessThan(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".min",
+                  ExprOpType.EXPR_OP_TYPE_LESS, value))
+              case LessThanOrEqual(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".min",
+                  ExprOpType.EXPR_OP_TYPE_LESS_EQUALS, value))
+              case GreaterThan(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".max",
+                  ExprOpType.EXPR_OP_TYPE_GREATER, value))
+              case GreaterThanOrEqual(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".max",
+                  ExprOpType.EXPR_OP_TYPE_GREATER_EQUALS, value))
+              case _ => None
+            }
+          }
+        }
+        else {
+          None
+        }
+
+      case op @ SpecialBinaryComparison(ConstructableLiteral(value), ExtractAttribute(attr)) =>
+        // flip the operators as attribute always goes to the left in ExprNode
+        if (attr.name == col_name) {
+          if (is_part_col) {
+            val expr_op_type = op match {
+              case EqualTo(_, _) => ExprOpType.EXPR_OP_TYPE_EQUALS
+              case EqualNullSafe(_, _) => ExprOpType.EXPR_OP_TYPE_EQUALS
+              case LessThan(_, _) => ExprOpType.EXPR_OP_TYPE_GREATER
+              case LessThanOrEqual(_, _) => ExprOpType.EXPR_OP_TYPE_GREATER_EQUALS
+              case GreaterThan(_, _) => ExprOpType.EXPR_OP_TYPE_LESS
+              case GreaterThanOrEqual(_, _) => ExprOpType.EXPR_OP_TYPE_LESS_EQUALS
+            }
+            Some(constructBinaryExpr("obj_id", expr_op_type, value.value.toString))
+          }
+          else {
+            op match {
+              case LessThan(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".max",
+                  ExprOpType.EXPR_OP_TYPE_GREATER, value))
+              case LessThanOrEqual(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".max",
+                  ExprOpType.EXPR_OP_TYPE_GREATER_EQUALS, value))
+              case GreaterThan(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".min",
+                  ExprOpType.EXPR_OP_TYPE_LESS, value))
+              case GreaterThanOrEqual(_, _) =>
+                Some(constructBinaryExpr("stats.colStats." + col_name + ".min",
+                  ExprOpType.EXPR_OP_TYPE_LESS_EQUALS, value))
+              case _ => None
+            }
+          }
+        }
+        else {
+          None
+        }
+
+      case And(expr1, expr2) =>
+        val converted_expr1 = convert(col_name, is_part_col, expr1)
+        val converted_expr2 = convert(col_name, is_part_col, expr2)
+        if (converted_expr1.isEmpty && converted_expr2.isEmpty) {
+          None
+        } else {
+          val and_builder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+          if (!converted_expr1.isEmpty) {
+            and_builder.addArgs(converted_expr1.get)
+          }
+          if (!converted_expr2.isEmpty) {
+            and_builder.addArgs(converted_expr2.get)
+          }
+
+          Some(ExprNode.newBuilder().setExprBool(and_builder).build())
+        }
+
+      case Or(expr1, expr2) =>
+        val converted_expr1 = convert(col_name, is_part_col, expr1)
+        val converted_expr2 = convert(col_name, is_part_col, expr2)
+        if (converted_expr1.isEmpty && converted_expr2.isEmpty) {
+          None
+        } else {
+          val or_builder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_OR)
+          if (converted_expr1.isDefined) {
+            or_builder.addArgs(converted_expr1.get)
+          }
+          if (converted_expr2.isDefined) {
+            or_builder.addArgs(converted_expr2.get)
+          }
+
+          Some(ExprNode.newBuilder().setExprBool(or_builder).build())
+        }
+
+      case Not(EqualTo(
+      ExtractAttribute(attr), ExtractableLiteral(value))) =>
+        Some(constructBinaryExpr(attr.name, ExprOpType.EXPR_OP_TYPE_NOT_EQUALS, value))
+
+      case Not(EqualTo(
+      ExtractableLiteral(value), ExtractAttribute(attr))) =>
+        Some(constructBinaryExpr(attr.name, ExprOpType.EXPR_OP_TYPE_NOT_EQUALS, value))
+
+      case _ => None
+    }
+    val pathExprBuilder = PathExpr.newBuilder()
+
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+
+    pathExprBuilder.addPreds(dbPred).addPreds(tablePred)
+
+    val partTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    table.partitionColumnNames.foreach{ col_name =>
+      val andBuilder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+      filters.map(convert(col_name, true, _)).filter(_.isDefined)
+        .foreach(expr => andBuilder.addArgs(expr.get))
+      if (andBuilder.getArgsCount == 0) {
+        pathExprBuilder.addPreds(Predicate.newBuilder().setExprNode(partTypeExpr))
+      }
+      else {
+        pathExprBuilder.addPreds(Predicate.newBuilder()
+            .setExprNode(ExprNode.newBuilder().setExprBool(andBuilder.addArgs(partTypeExpr))))
+      }
+    }
+    // if the filters are also applied to files and not just partitions
+    if (!part_only) {
+      val andBuilder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+      table.dataSchema.fieldNames.foreach { col_name =>
+        filters.map(convert(col_name, false, _)).filter(_.isDefined)
+          .foreach(expr => andBuilder.addArgs(expr.get))
+      }
+      if (andBuilder.getArgsCount == 0) {
+        pathExprBuilder.addPreds(Predicate.newBuilder().setWildcard(Wildcard.WILDCARD_ANY))
+      }
+      else {
+        pathExprBuilder.addPreds(Predicate.newBuilder()
+          .setExprNode(ExprNode.newBuilder().setExprBool(andBuilder)))
+      }
+    }
+
+    pathExprBuilder
+  }
+
+  private def constructDbPred(db: String) : Predicate = {
+    val dbOidExpr = constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS, db)
+    val dbTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "database")
+    Predicate.newBuilder().setExprNode(ExprNode.newBuilder()
+      .setExprBool(ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+        .addArgs(dbOidExpr).addArgs(dbTypeExpr))).build()
+  }
+
+  private def constructTablePred(table : String) : Predicate = {
+    val tableOidExpr = constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS, table)
+    val tableTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "table")
+    Predicate.newBuilder().setExprNode(ExprNode.newBuilder()
+      .setExprBool(ExprBool.newBuilder().addArgs(tableOidExpr).addArgs(tableTypeExpr)
+        .setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND))).build()
+  }
+
+  private def constructStatsPred() : Predicate = {
+    val tableOidExpr = constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS, "stats")
+    val tableTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "stats")
+    Predicate.newBuilder().setExprNode(ExprNode.newBuilder()
+      .setExprBool(ExprBool.newBuilder().addArgs(tableOidExpr).addArgs(tableTypeExpr)
+        .setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND))).build()
+  }
+
+  private def setTxnId(queryRequest : ExecuteQueryRequest.Builder, txn : Option[TreeTxn]) = {
+    if (txn.isDefined) {
+      if (txn.get.txnMode == TxnMode.TXN_MODE_READ_ONLY)  {
+        queryRequest.setVid(txn.get.vid.get)
+      }
+      else if (txn.get.txnMode == TxnMode.TXN_MODE_READ_WRITE) {
+        queryRequest.setTxnId(txn.get.txnId.get)
+      }
+    }
+  }
+
+  private def toCatalogTablePartitions(queryResponses: java.util.Iterator[ExecuteQueryResponse],
+                                       txn : Option[TreeTxn])
+      : Seq[CatalogTablePartition] = {
+    val partitions = ArrayBuffer[CatalogTablePartition]()
+    var lastResponse : Option[ExecuteQueryResponse] = None
+    queryResponses.forEachRemaining(response => {
+      lastResponse = Some(response)
+      val responseBuf = response.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          response.getObjList().toByteArray())
+        case _ => response.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+      while (bufIter.valid()) {
+        val partBson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        partitions += TreeSerde.toCatalogTablePartition(partBson)
+        bufIter.next()
+      }
+      if (txn.isDefined) {
+        txn.get.data_received += responseBuf.size
+      }
+    })
+    if (txn.isDefined && lastResponse.isDefined && lastResponse.get.hasAbort) {
+      txn.get.setAbort(lastResponse.get.getAbort)
+    }
+    partitions
+  }
+
+  private def toCatalogTableFiles(queryResponses: java.util.Iterator[ExecuteQueryResponse],
+                                  txn : Option[TreeTxn])
+  : Seq[CatalogTableFile] = {
+    val files = ArrayBuffer[CatalogTableFile]()
+    var lastResponse : Option[ExecuteQueryResponse] = None
+    queryResponses.forEachRemaining(response => {
+      lastResponse = Some(response)
+      val responseBuf = response.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          response.getObjList().toByteArray())
+        case _ => response.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+      while (bufIter.valid()) {
+        val fileBson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        files += TreeSerde.toCatalogTableFile(fileBson)
+        bufIter.next()
+      }
+      if (txn.isDefined) {
+        txn.get.data_received += responseBuf.size
+      }
+    })
+    if (txn.isDefined && lastResponse.isDefined && lastResponse.get.hasAbort) {
+      txn.get.setAbort(lastResponse.get.getAbort)
+    }
+    files
+  }
+
+  private def toFileStatuses(queryResponses: java.util.Iterator[ExecuteQueryResponse],
+                                  txn : Option[TreeTxn])
+  : Seq[FileStatus] = {
+    val files = ArrayBuffer[FileStatus]()
+    var lastResponse : Option[ExecuteQueryResponse] = None
+    queryResponses.forEachRemaining(response => {
+      lastResponse = Some(response)
+      val responseBuf = response.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          response.getObjList().toByteArray())
+        case _ => response.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+
+      while (bufIter.valid()) {
+        val fileBson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        files += TreeSerde.toFileStatus(fileBson)
+        bufIter.next()
+      }
+
+      if (txn.isDefined) {
+        txn.get.data_received += responseBuf.size
+      }
+    })
+    if (txn.isDefined && lastResponse.isDefined && lastResponse.get.hasAbort) {
+      txn.get.setAbort(lastResponse.get.getAbort)
+    }
+    files
+  }
+
+  // start a new txn. returns Some(Txn) if successful
+  def startTransaction(txnMode : TxnMode, vid : Option[Long] = None) : Option[TreeTxn] = {
+    val startTxnRequest = StartTxnRequest.newBuilder().setTxnMode(txnMode)
+    if (vid.isDefined && txnMode == TxnMode.TXN_MODE_READ_ONLY) {
+      startTxnRequest.setReadVid(vid.get)
+    }
+
+    val startTxnResponse = catalogStub.startTxn(startTxnRequest.build)
+    if (startTxnResponse.getSuccess && txnMode == TxnMode.TXN_MODE_READ_ONLY) {
+      Some(new TreeTxn(txnMode, None, Some(startTxnResponse.getVid), None))
+    }
+    else if (startTxnResponse.getSuccess && txnMode == TxnMode.TXN_MODE_READ_WRITE) {
+      val txnId = startTxnResponse.getTxnId
+      Some(new TreeTxn(txnMode, Some(txnId), None, Some(CommitRequest.newBuilder()
+        .setTxnId(txnId))))
+    }
+    else {
+      None
+    }
+
+
+  }
+
+  // commits the given txn and returns true if successful
+  def commit(txn: TreeTxn) : Boolean = {
+    if (txn.txnMode == TxnMode.TXN_MODE_READ_ONLY && txn.isOK()) {
+      true
+    }
+    else if (txn.txnMode == TxnMode.TXN_MODE_READ_WRITE && txn.commitRequest.isDefined) {
+      // abort if txn is not ok
+      if (!txn.isOK()) {
+        txn.commitRequest.get.setAbort(true)
+      }
+
+      val commitResponse = catalogStub.commit(txn.commitRequest.get.build)
+      if (commitResponse.getSuccess) {
+        txn.setCommitVid(commitResponse.getCommitVid)
+      }
+      commitResponse.getSuccess
+    }
+    else {
+      false
+    }
+
+  }
+
+  def getDatabase(db: String, txn : Option[TreeTxn] = None): CatalogDatabase = {
+    val dbPred = constructDbPred(db)
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(
+        PathExpr.newBuilder().addPreds(dbPred))
+        .setBaseOnly(true).setReturnType(1)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    if (queryResponses.hasNext) {
+      val firstResponse = queryResponses.next()
+      var lastResponse = firstResponse
+      while (queryResponses.hasNext) {
+        lastResponse = queryResponses.next()
+      }
+      if (txn.isDefined && lastResponse.hasAbort) {
+        txn.get.setAbort(lastResponse.getAbort)
+      }
+
+      val responseBuf = firstResponse.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          firstResponse.getObjList().toByteArray())
+        case _ => firstResponse.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+      if (bufIter.valid()) {
+        val DBBson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        TreeSerde.toCatalogDatabase(DBBson)
+      }
+      else {
+        null
+      }
+    }
+    else {
+      null
+    }
+  }
+
+  // if lock modes are defined, there should be at least 3 lock modes starting from the root object
+  def getTable(db: String, table: String, txn : Option[TreeTxn] = None,
+               lock_mode : Option[LockMode] = None): CatalogTable = {
+    val dbPred = constructDbPred(db)
+    val tablePred = constructTablePred(table)
+
+    val path_expr = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+    if (lock_mode.isDefined) {
+      val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+        case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+        case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+        case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+        case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+        case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+        case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+        case _ => LockMode.LOCK_MODE_NL
+      }
+
+      path_expr.addLockModes(intention_lock).addLockModes(intention_lock)
+        .addLockModes(lock_mode.getOrElse(LockMode.LOCK_MODE_NL))
+    }
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(path_expr.build())
+      .setBaseOnly(true).setReturnType(1)
+
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    if (queryResponses.hasNext) {
+      val firstResponse = queryResponses.next()
+      var lastResponse = firstResponse
+      while (queryResponses.hasNext) {
+        lastResponse = queryResponses.next()
+      }
+      // if part of a txn session, check if txn has been aborted
+      if (txn.isDefined && lastResponse.hasAbort) {
+        txn.get.setAbort(lastResponse.getAbort)
+        // commit to deallocate resources on the server side
+      }
+
+      val responseBuf = firstResponse.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          firstResponse.getObjList().toByteArray())
+        case _ => firstResponse.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+      if (bufIter.valid()) {
+        val tableBson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        if (txn.isDefined) {
+          txn.get.data_received += responseBuf.length
+        }
+        TreeSerde.toCatalogTable(tableBson)
+      }
+      else {
+        null
+      }
+    }
+    else {
+      null
+    }
+  }
+
+  // if lock modes are defined, there should be at least 3 lock modes starting from the root object
+  def getTableStats(db: String, table: String, txn: Option[TreeTxn] = None,
+                    lock_mode: Option[LockMode] = None): CatalogStatistics = {
+    val dbPred = constructDbPred(db)
+    val tablePred = constructTablePred(table)
+    val statsPred = constructStatsPred()
+
+    val path_expr = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred).addPreds(statsPred)
+    if (lock_mode.isDefined) {
+      val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+        case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+        case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+        case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+        case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+        case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+        case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+        case _ => LockMode.LOCK_MODE_NL
+      }
+
+      path_expr.addLockModes(intention_lock).addLockModes(intention_lock)
+        .addLockModes(lock_mode.getOrElse(LockMode.LOCK_MODE_NL))
+    }
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(path_expr.build())
+      .setBaseOnly(true).setReturnType(1)
+
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    if (queryResponses.hasNext) {
+      val firstResponse = queryResponses.next()
+      var lastResponse = firstResponse
+      while (queryResponses.hasNext) {
+        lastResponse = queryResponses.next()
+      }
+      // if part of a txn session, check if txn has been aborted
+      if (txn.isDefined && lastResponse.hasAbort) {
+        txn.get.setAbort(lastResponse.getAbort)
+        // commit to deallocate resources on the server side
+      }
+
+      val responseBuf = firstResponse.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          firstResponse.getObjList().toByteArray())
+        case _ => firstResponse.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+      if (bufIter.valid()) {
+        val tableBson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        TreeSerde.toCatalogStatistics(tableBson)
+      }
+      else {
+        null
+      }
+    }
+    else {
+      null
+    }
+  }
+
+  def listTables(db: String, txn : Option[TreeTxn] = None): Seq[String] = {
+    val dbPred = constructDbPred(db)
+    val tablesPred = constructBinaryPred("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "table")
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(PathExpr.newBuilder()
+        .addPreds(dbPred).addPreds(tablesPred).build()).setBaseOnly(true)
+        .setReturnType(1)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    val tables = ArrayBuffer[String]()
+    var lastResponse : Option[ExecuteQueryResponse] = None
+    queryResponses.forEachRemaining { response =>
+      lastResponse = Some(response)
+      val responseBuf = response.getCompression() match {
+        case BufCompression.BUF_SNAPPY_COMPRESSION => Snappy.uncompress(
+          response.getObjList().toByteArray())
+        case _ => response.getObjList().toByteArray()
+      }
+      val bufIter = new BufIterator(responseBuf)
+      while (bufIter.valid()) {
+        val table_bson = new RawBsonDocument(responseBuf, bufIter.dataIdx(),
+          responseBuf.size - bufIter.dataIdx())
+        tables += table_bson.get("identifier").asInstanceOf[RawBsonDocument].get("table").
+          asString().getValue()
+        bufIter.next()
+      }
+    }
+    if (txn.isDefined && lastResponse.isDefined && lastResponse.get.hasAbort) {
+      txn.get.setAbort(lastResponse.get.getAbort)
+    }
+    tables
+  }
+
+  def listPartitions(db: String, table: String, txn : Option[TreeTxn]):
+      Seq[CatalogTablePartition] = {
+    val tableObj = getTable(db, table, txn)
+    if (tableObj != null) {
+      listPartitions(tableObj, txn)
+    }
+    else {
+      ArrayBuffer[CatalogTablePartition]()
+    }
+  }
+
+  def listPartitions(table: CatalogTable, txn : Option[TreeTxn]):
+      Seq[CatalogTablePartition] = {
+    if (table.partitionColumnNames.isEmpty) {
+      ArrayBuffer[CatalogTablePartition]()
+    }
+    else {
+      val dbPred = constructDbPred(table.identifier.database.get)
+      val tablePred = constructTablePred(table.identifier.table)
+
+      val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+      val partPred = constructBinaryPred("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+
+      table.partitionColumnNames.foreach { _ =>
+        pathExprBuilder.addPreds(partPred)
+      }
+
+      val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(
+        pathExprBuilder.build()).setBaseOnly(true).setReturnType(1)
+      setTxnId(queryRequest, txn)
+
+      val queryResponses = catalogStub.executeQuery(queryRequest.build())
+      toCatalogTablePartitions(queryResponses, txn)
+    }
+  }
+
+  def listPartitionsByFilter(db: String, table: String, predicates: Seq[Expression],
+                             txn : Option[TreeTxn]):
+      Seq[CatalogTablePartition] = {
+    val tableObj = getTable(db, table, txn)
+    if (tableObj != null) {
+      listPartitionsByFilter(tableObj, predicates, txn)
+    }
+    else {
+      ArrayBuffer[CatalogTablePartition]()
+    }
+  }
+
+  def listPartitionsByFilter(table: CatalogTable, predicates: Seq[Expression],
+                             txn : Option[TreeTxn]):
+      Seq[CatalogTablePartition] = {
+    val pathExprBuilder = convertFilters(table, predicates, true)
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(
+      pathExprBuilder.build()).setBaseOnly(true).setReturnType(1)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    toCatalogTablePartitions(queryResponses, txn)
+  }
+
+  def getPartition(table: CatalogTable, spec: Map[String, String], txn : Option[TreeTxn] = None,
+                   lock_mode : Option[LockMode] = None):
+      Seq[CatalogTablePartition] = {
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+    val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+    val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+      case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+      case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+      case _ => LockMode.LOCK_MODE_NL
+    }
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+
+    val partTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    table.partitionSchema.foreach { partitionColumn =>
+      val partitionVal = TreeSerde.getPartitionVal(partitionColumn, spec)
+
+      val andBuilder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+      andBuilder.addArgs(constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS,
+        partitionColumn.name + "=" + partitionVal))
+      andBuilder.addArgs(partTypeExpr)
+
+      pathExprBuilder.addPreds(Predicate.newBuilder()
+        .setExprNode(ExprNode.newBuilder().setExprBool(andBuilder)))
+
+      if (lock_mode.isDefined) {
+        pathExprBuilder.addLockModes(intention_lock)
+      }
+    }
+
+    if (lock_mode.isDefined) {
+      pathExprBuilder.addLockModes(lock_mode.getOrElse(LockMode.LOCK_MODE_NL))
+    }
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder.build())
+        .setBaseOnly(true).setReturnType(1)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build)
+    toCatalogTablePartitions(queryResponses, txn)
+  }
+
+  def listFilesByFilter(db: String, table: String, predicates: Seq[Expression],
+                        txn : Option[TreeTxn]):
+                        Seq[FileStatus] = {
+
+    val tableObj = getTable(db, table, txn, Some(LockMode.LOCK_MODE_NL))
+
+    if (tableObj != null) {
+      listFilesByFilter(tableObj, predicates, txn, Some(LockMode.LOCK_MODE_NL))
+    }
+    else {
+      ArrayBuffer[FileStatus]()
+    }
+  }
+
+  def listFilesWithStatsByFilter(db: String, table: String, predicates: Seq[Expression],
+                                txn : Option[TreeTxn]): Seq[CatalogTableFile] = {
+
+    val tableObj = getTable(db, table, txn, Some(LockMode.LOCK_MODE_NL))
+
+    if (tableObj != null) {
+      listFilesWithStatsByFilter(tableObj, predicates, txn, Some(LockMode.LOCK_MODE_NL))
+    }
+    else {
+      ArrayBuffer[CatalogTableFile]()
+    }
+  }
+
+  def listFilesByFilter(table: CatalogTable, predicates: Seq[Expression],
+                        txn : Option[TreeTxn], lock_mode : Option[LockMode] = None):
+                        Seq[FileStatus] = {
+    val pathExprBuilder = convertFilters(table, predicates, false)
+
+    val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+      case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+      case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+      case _ => LockMode.LOCK_MODE_NL
+    }
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+
+    table.partitionSchema.foreach { _ =>
+      pathExprBuilder.addLockModes(intention_lock)
+    }
+
+    // the actual file objects are implicitly locked for less overhead
+    pathExprBuilder.addLockModes(LockMode.LOCK_MODE_NL)
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(
+      pathExprBuilder.build()).setBaseOnly(true).setReturnType(2)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    toFileStatuses(queryResponses, txn)
+  }
+
+  def listFilesWithStatsByFilter(table: CatalogTable, predicates: Seq[Expression],
+                        txn : Option[TreeTxn], lock_mode : Option[LockMode] = None):
+                        Seq[CatalogTableFile] = {
+    val pathExprBuilder = convertFilters(table, predicates, false)
+
+    val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+      case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+      case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+      case _ => LockMode.LOCK_MODE_NL
+    }
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+
+    table.partitionSchema.foreach { _ =>
+      pathExprBuilder.addLockModes(intention_lock)
+    }
+
+    // the actual file objects are implicitly locked for less overhead
+    pathExprBuilder.addLockModes(LockMode.LOCK_MODE_NL)
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(
+      pathExprBuilder.build()).setBaseOnly(true).setReturnType(2)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    toCatalogTableFiles(queryResponses, txn)
+  }
+
+  def listFiles(db: String, table: String, txn : Option[TreeTxn]): Seq[FileStatus] = {
+    val tableObj = getTable(db, table, txn)
+    if (tableObj != null) {
+      listFiles(tableObj, txn)
+    }
+    else {
+      ArrayBuffer[FileStatus]()
+    }
+  }
+
+  def listFilesWithStats(db: String, table: String, txn: Option[TreeTxn]): Seq[CatalogTableFile] = {
+    val tableObj = getTable(db, table, txn)
+    if (tableObj != null) {
+      listFilesWithStats(tableObj, txn)
+    }
+    else {
+      ArrayBuffer[CatalogTableFile]()
+    }
+  }
+
+  def listFiles(table : CatalogTable, txn : Option[TreeTxn],
+                lock_mode : Option[LockMode] = None) : Seq[FileStatus] = {
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+    val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+    val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+      case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+      case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+      case _ => LockMode.LOCK_MODE_NL
+    }
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+
+    val partPred = constructBinaryPred("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    table.partitionColumnNames.foreach({ column_name =>
+      pathExprBuilder.addPreds(partPred)
+      pathExprBuilder.addLockModes(intention_lock)
+    })
+
+    // the actual file objects are implicitly locked for less overhead
+    pathExprBuilder.addLockModes(LockMode.LOCK_MODE_NL)
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder.
+      addPreds(Predicate.newBuilder().setWildcard(Grpccatalog.Wildcard.WILDCARD_ANY).build()).
+        build()).setBaseOnly(true).setReturnType(2)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    toFileStatuses(queryResponses, txn)
+  }
+
+  def listFilesWithStats(table : CatalogTable, txn : Option[TreeTxn],
+                         lock_mode : Option[LockMode] = None) : Seq[CatalogTableFile] = {
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+    val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+    val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+      case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+      case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+      case _ => LockMode.LOCK_MODE_NL
+    }
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+
+    val partPred = constructBinaryPred("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    table.partitionColumnNames.foreach({ column_name =>
+      pathExprBuilder.addPreds(partPred)
+      pathExprBuilder.addLockModes(intention_lock)
+    })
+
+    // the actual file objects are implicitly locked for less overhead
+    pathExprBuilder.addLockModes(LockMode.LOCK_MODE_NL)
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder.
+      addPreds(Predicate.newBuilder().setWildcard(Grpccatalog.Wildcard.WILDCARD_ANY).build()).
+      build()).setBaseOnly(true).setReturnType(2)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    toCatalogTableFiles(queryResponses, txn)
+  }
+
+  def listFilesToCompact(table : CatalogTable, threshold: Long, txn : Option[TreeTxn])
+    : Seq[CatalogTableFile] = {
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+    val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+    val partPred = constructBinaryPred("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    table.partitionColumnNames.foreach({ column_name =>
+      pathExprBuilder.addPreds(partPred)
+    })
+
+    val filePred = constructBinaryPred("size", ExprOpType.EXPR_OP_TYPE_LESS, Literal(threshold))
+    pathExprBuilder.addPreds(filePred)
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder.build())
+      .setBaseOnly(true).setReturnType(2)
+
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build())
+    toCatalogTableFiles(queryResponses, txn)
+  }
+
+
+  def listFilesInPartition(table : CatalogTable, partition : CatalogTablePartition,
+                txn : Option[TreeTxn], lock_mode : Option[LockMode] = None) : Seq[FileStatus] = {
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+    val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+    val intention_lock = lock_mode.getOrElse(LockMode.LOCK_MODE_NL) match {
+      case LockMode.LOCK_MODE_NL => LockMode.LOCK_MODE_NL
+      case LockMode.LOCK_MODE_IS => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_S => LockMode.LOCK_MODE_IS
+      case LockMode.LOCK_MODE_IX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_SIX => LockMode.LOCK_MODE_IX
+      case LockMode.LOCK_MODE_X => LockMode.LOCK_MODE_IX
+      case _ => LockMode.LOCK_MODE_NL
+    }
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+    pathExprBuilder.addLockModes(intention_lock)
+
+    val partTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    val partTypePred = Predicate.newBuilder().setExprNode(partTypeExpr).build
+    table.partitionSchema.foreach { partitionColumn =>
+      val partitionValOption = partition.spec.get(partitionColumn.name)
+      if (partitionValOption.isDefined) {
+        val partitionVal = {
+          if (partitionColumn.dataType.isInstanceOf[IntegralType]) {
+            "%012d".format(partitionValOption.get.toLong)
+          }
+          else {
+            partitionValOption.get
+          }
+        }
+        val andBuilder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+        andBuilder.addArgs(constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS,
+          partitionColumn.name + "=" + partitionVal))
+        andBuilder.addArgs(partTypeExpr)
+
+        pathExprBuilder.addPreds(Predicate.newBuilder()
+          .setExprNode(ExprNode.newBuilder().setExprBool(andBuilder)))
+
+      }
+      else {
+        pathExprBuilder.addPreds(partTypePred)
+      }
+
+      pathExprBuilder.addLockModes(intention_lock)
+    }
+
+    // the actual file objects are implicitly locked for less overhead
+    pathExprBuilder.addLockModes(LockMode.LOCK_MODE_NL)
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder.
+        addPreds(Predicate.newBuilder().setWildcard(Grpccatalog.Wildcard.WILDCARD_ANY).build()).
+        build()).setBaseOnly(true).setReturnType(2)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build)
+    toFileStatuses(queryResponses, txn)
+  }
+
+  def listFilesWithStats(table : CatalogTable, partition : CatalogTablePartition,
+                txn : Option[TreeTxn]) : Seq[CatalogTableFile] = {
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+    val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+
+    val partTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+    val partTypePred = Predicate.newBuilder().setExprNode(partTypeExpr).build
+    table.partitionSchema.foreach { partitionColumn =>
+      val partitionValOption = partition.spec.get(partitionColumn.name)
+      if (partitionValOption.isDefined) {
+        val partitionVal = {
+          if (partitionColumn.dataType.isInstanceOf[IntegralType]) {
+            "%012d".format(partitionValOption.get.toLong)
+          }
+          else {
+            partitionValOption.get
+          }
+        }
+        val andBuilder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+        andBuilder.addArgs(constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS,
+          partitionColumn.name + "=" + partitionVal))
+        andBuilder.addArgs(partTypeExpr)
+
+        pathExprBuilder.addPreds(Predicate.newBuilder()
+          .setExprNode(ExprNode.newBuilder().setExprBool(andBuilder)))
+
+      }
+      else {
+        pathExprBuilder.addPreds(partTypePred)
+      }
+    }
+
+    val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder.
+      addPreds(Predicate.newBuilder().setWildcard(Grpccatalog.Wildcard.WILDCARD_ANY).build()).
+      build()).setBaseOnly(true).setReturnType(2)
+    setTxnId(queryRequest, txn)
+
+    val queryResponses = catalogStub.executeQuery(queryRequest.build)
+    toCatalogTableFiles(queryResponses, txn)
+  }
+
+  def createPartition(table : CatalogTable, partition : CatalogTablePartition,
+                      txn : Option[TreeTxn]) : Option[Boolean] = {
+    val newTxn = {
+      if (txn.isDefined) {
+        txn
+      }
+      else {
+        startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      }
+    }
+
+    val dbPred = constructDbPred(table.identifier.database.get)
+    val tablePred = constructTablePred(table.identifier.table)
+
+    val partTypeExpr = constructBinaryExpr("obj_type", ExprOpType.EXPR_OP_TYPE_EQUALS, "partition")
+
+    var partExists = false
+    val partitionColumnNames = table.partitionColumnNames.to[mutable.ArrayBuffer]
+    val partitionSchema = table.partitionSchema
+    // check if the partition exists at each level from bottom to top
+    while (!partExists && !partitionColumnNames.isEmpty) {
+      val pathExprBuilder = PathExpr.newBuilder().addPreds(dbPred).addPreds(tablePred)
+      for (i <- 0 until partitionColumnNames.size) {
+        val partitionColumn = partitionSchema(i)
+        val partitionVal = TreeSerde.getPartitionVal(partitionColumn, partition.spec)
+        val andBuilder = ExprBool.newBuilder().setOpType(ExprBoolType.EXPR_BOOL_TYPE_AND)
+        andBuilder.addArgs(constructBinaryExpr("obj_id", ExprOpType.EXPR_OP_TYPE_EQUALS,
+          partitionColumn.name + "=" + partitionVal))
+        andBuilder.addArgs(partTypeExpr)
+        pathExprBuilder.addPreds(Predicate.newBuilder()
+          .setExprNode(ExprNode.newBuilder().setExprBool(andBuilder)))
+      }
+
+      val queryRequest = ExecuteQueryRequest.newBuilder().setParseTree(pathExprBuilder)
+          .setBaseOnly(true).setReturnType(1)
+      setTxnId(queryRequest, newTxn)
+      val queryResponses = catalogStub.executeQuery(queryRequest.build)
+      partExists = queryResponses.hasNext
+      if (partExists) {
+        var lastResponse : Option[ExecuteQueryResponse] = None
+        while (queryResponses.hasNext) {
+          lastResponse = Some(queryResponses.next())
+        }
+        // if aborted, commit to deallocate resource on the server side
+        if (lastResponse.get.hasAbort) {
+          newTxn.get.setAbort(lastResponse.get.getAbort)
+          return Some(false)
+        }
+      }
+      else {
+        partitionColumnNames.trimEnd(1)
+      }
+    }
+
+    val partitionVals : mutable.Map[String, String] = mutable.Map.empty
+    partitionColumnNames.foreach{ columnName =>
+      partitionVals.put(columnName, partition.spec.get(columnName).getOrElse("DEFAULT"))
+    }
+
+    val commitRequest = newTxn.get.commitRequest.get
+    val emptyStorage = CatalogStorageFormat(None, None, None, None, false,
+      Map.empty[String, String])
+
+    val emptyStats = TreeSerde.emptyStats(table)
+    for ( i <- partitionColumnNames.length until table.partitionColumnNames.length - 1) {
+      val columnName = table.partitionColumnNames(i)
+      partitionVals.put(columnName, partition.spec.get(columnName).getOrElse("DEFAULT"))
+      // create appropriate ancestor partition
+      val parentPartition = CatalogTablePartition(partitionVals.toMap, emptyStorage,
+          Map.empty, System.currentTimeMillis, -1, None)
+      val objPath = "/" + table.identifier.database.get + "/" + table.identifier.table +
+          TreeSerde.getPartId(table, parentPartition.spec)
+      val partitionBson = TreeSerde.toBson(objPath, table, parentPartition)
+      // add parent partition
+      commitRequest.addWriteSet(Write.newBuilder()
+        .setType(WriteType.WRITE_TYPE_ADD)
+        .setIsLeaf(false)
+        .setWriteValue(ByteString.copyFrom(partitionBson.getInternalBuffer, 0,
+          partitionBson.getPosition))
+        .setPathStr(objPath))
+
+      // create empty base statistics
+      val statsPath = objPath + "/stats"
+      val statsBson = TreeSerde.toBson(statsPath, table, emptyStats)
+      commitRequest.addWriteSet(Write.newBuilder()
+        .setType(WriteType.WRITE_TYPE_ADD)
+        .setIsLeaf(false)
+        .setWriteValue(ByteString.copyFrom(statsBson.getInternalBuffer, 0,
+          statsBson.getPosition))
+        .setPathStr(statsPath))
+
+    }
+
+    // create leaf partition
+    val objPath = "/" + table.identifier.database.get + "/" + table.identifier.table +
+      TreeSerde.getPartId(table, partition.spec)
+    val partitionBson = TreeSerde.toBson(objPath, table, partition)
+    commitRequest.addWriteSet(Write.newBuilder()
+      .setType(WriteType.WRITE_TYPE_ADD)
+      .setIsLeaf(false)
+      .setWriteValue(ByteString.copyFrom(partitionBson.getInternalBuffer, 0,
+        partitionBson.getPosition))
+      .setPathStr(objPath))
+
+    // create empty base statistics
+    val statsPath = objPath + "/stats"
+    val statsBson = TreeSerde.toBson(statsPath, table, emptyStats)
+    commitRequest.addWriteSet(Write.newBuilder()
+      .setType(WriteType.WRITE_TYPE_ADD)
+      .setIsLeaf(false)
+      .setWriteValue(ByteString.copyFrom(statsBson.getInternalBuffer, 0,
+        statsBson.getPosition))
+      .setPathStr(statsPath))
+
+    // if not part of the existing transaction, commit
+    if (txn.isEmpty) {
+      Some(commit(newTxn.get))
+    }
+    else {
+      None
+    }
+
+  }
+
+  // add given files to the table, returns true if successful
+  def addFiles(table : CatalogTable, files : Seq[CatalogTableFile],
+               txn : Option[TreeTxn] = None): Option[Boolean] = {
+    val newTxn = {
+      if (txn.isDefined) {
+        txn
+      }
+      else {
+        startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      }
+    }
+
+    val commitRequest = newTxn.get.commitRequest.get
+    val tablePartitionSchema = table.partitionSchema
+    files.foreach{ file =>
+      val objPath = "/" + table.identifier.database.get + "/" + table.identifier.table +
+        TreeSerde.getFileId(table, file)
+      val fileBson = TreeSerde.toBson(objPath, table, file)
+
+      commitRequest.addWriteSet(Write.newBuilder()
+        .setType(WriteType.WRITE_TYPE_ADD)
+        .setIsLeaf(true)
+        .setWriteValue(ByteString.copyFrom(fileBson.getInternalBuffer, 0,
+          fileBson.getPosition))
+        .setPathStr(objPath))
+      if (txn.isDefined) {
+        txn.get.data_sent += fileBson.getPosition
+      }
+      // TODO: Uncomment the following to test out the commit time update feature on statistics.
+      // Because this forces taking exclusive lock instead of intention locks on the whole table
+      // (if intention lock is taken, txn will likely aborted during lock upgrade), even if it is
+      // partitioned, it may be extremely unfair for testing multiple-granularity locking.
+      // So we comment this part out for the experimental purposes.
+      // if file has statistics, merge delta to table and partition at every level
+//      if (file.stats.isDefined) {
+//        val mergeBson = TreeSerde.toMergeBson(table, file.stats.get)
+//        val mergeByteString = ByteString.copyFrom(mergeBson.getInternalBuffer, 0,
+//          mergeBson.getPosition)
+//        val partitionVals = scala.collection.mutable.Map.empty[String, String]
+//        val tablePath = "/" + table.identifier.database.get + "/" + table.identifier.table
+//        // update table statistics
+//        commitRequest.addWriteSet(Write.newBuilder()
+//          .setType(WriteType.WRITE_TYPE_MERGE)
+//          .setIsLeaf(false)
+//          .setWriteValue(mergeByteString)
+//          .setPathStr(tablePath + "/stats"))
+//        // update partition statistics
+//        tablePartitionSchema.foreach { partitionColumn =>
+//          partitionVals.put(partitionColumn.name, file.partitionValues.get(partitionColumn.name)
+//            .getOrElse("DEFAULT"))
+//          val statsPath = tablePath + TreeSerde.getPartId(table, partitionVals.toMap) + "/stats"
+//
+//          commitRequest.addWriteSet(Write.newBuilder()
+//            .setType(WriteType.WRITE_TYPE_MERGE)
+//            .setIsLeaf(false)
+//            .setWriteValue(mergeByteString)
+//            .setPathStr(statsPath))
+//        }
+//      }
+    }
+
+    // if not part of the existing transaction, commit
+    if (txn.isEmpty) {
+      Some(commit(newTxn.get))
+    }
+    else {
+      None
+    }
+  }
+
+  // add given files to the table, returns true if successful
+  def removeFiles(table : CatalogTable, files : Seq[CatalogTableFile],
+               txn : Option[TreeTxn] = None): Option[Boolean] = {
+    val newTxn = {
+      if (txn.isDefined) {
+        txn
+      }
+      else {
+        startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      }
+    }
+
+    val commitRequest = newTxn.get.commitRequest.get
+    val tablePartitionSchema = table.partitionSchema
+    files.foreach{ file =>
+      val objPath = "/" + table.identifier.database.get + "/" + table.identifier.table +
+        TreeSerde.getFileId(table, file)
+
+      commitRequest.addWriteSet(Write.newBuilder()
+        .setType(WriteType.WRITE_TYPE_REMOVE)
+        .setIsLeaf(true)
+        .setPathStr(objPath))
+    }
+
+    // if not part of the existing transaction, commit
+    if (txn.isEmpty) {
+      Some(commit(newTxn.get))
+    }
+    else {
+      None
+    }
+  }
+
+  // this is rather add hoc as we use max field of stats object for auto increment column.
+  // Note that the auto increment field can be defined as another child object of the table
+  def fetchAddAttr(db: String, table: String, attr_name : String, arg : Long) : Option[Long] = {
+    var success = false
+    var commit_vid : Option[Long] = None
+    // fuel to limit number of retries
+    var fuel = 0
+    while (fuel < 10 && !success) {
+      fuel += 1
+
+      val txn = startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      val table_obj = getTable(db, table, txn, Some(LockMode.LOCK_MODE_X))
+      if (table_obj != null && table_obj.schema.fields.exists(_.name == attr_name)) {
+        // construct merge bson for the stats object
+        val outputBuffer = new BasicOutputBuffer()
+        val writer = new BsonBinaryWriter(outputBuffer)
+        writer.writeStartDocument()
+        writer.writeStartDocument("colStats")
+        writer.writeStartDocument(attr_name)
+        writer.writeStartDocument("max")
+
+        writer.writeString("op", "4")
+        writer.writeInt64("", arg)
+
+        writer.writeEndDocument()
+        writer.writeEndDocument()
+        writer.writeEndDocument()
+        writer.writeEndDocument()
+
+        val mergeByteString = ByteString.copyFrom(outputBuffer.getInternalBuffer, 0,
+          outputBuffer.getPosition)
+
+        // add the constructed merge value to the write set.
+        txn.get.commitRequest.get.addWriteSet(Write.newBuilder()
+          .setType(WriteType.WRITE_TYPE_MERGE)
+          .setIsLeaf(false)
+          .setWriteValue(mergeByteString)
+          .setPathStr("/" + db + "/" + table + "/stats")
+        )
+
+        success = commit(txn.get)
+        commit_vid = txn.get.getCommitVid()
+      }
+      else {
+        // break out of while loop
+        fuel = 10
+        // to clear out the read and write set.
+        if (txn.isDefined) {
+          commit(txn.get)
+        }
+      }
+
+    }
+
+    // now get the previous stat.
+    if (commit_vid.isDefined) {
+      val read_txn = startTransaction(TxnMode.TXN_MODE_READ_ONLY, Some(commit_vid.get - 1))
+      val prev_stats = getTableStats(db, table, read_txn)
+      Some(prev_stats.colStats(attr_name).max.get.toLong)
+    }
+    else {
+      None
+    }
+
+  }
+
+  def alterTable(table : CatalogTable, txn : Option[TreeTxn] = None): Option[Boolean] = {
+    val newTxn = {
+      if (txn.isDefined) {
+        txn
+      }
+      else {
+        startTransaction(TxnMode.TXN_MODE_READ_WRITE)
+      }
+    }
+
+    val commitRequest = newTxn.get.commitRequest.get
+    val objPath = "/" + table.identifier.database.get + "/" + table.identifier.table
+    val raw_bson = TreeSerde.toBson(table)
+    val byte_array = raw_bson.getByteBuffer.array()
+
+    commitRequest.addWriteSet(Write.newBuilder()
+      .setType(WriteType.WRITE_TYPE_UPDATE)
+      .setIsLeaf(false)
+      .setWriteValue(ByteString.copyFrom(byte_array, 0, byte_array.size))
+      .setPathStr(objPath))
+    if (txn.isDefined) {
+      txn.get.data_sent += byte_array.size
+    }
+
+    // if not part of the existing transaction, commit
+    if (txn.isEmpty) {
+      Some(commit(newTxn.get))
+    }
+    else {
+      None
+    }
+  }
+}
\ No newline at end of file
diff --git a/tree/src/main/scala/org/apache/spark/tree/TreeExternalCatalogTester.scala b/tree/src/main/scala/org/apache/spark/tree/TreeExternalCatalogTester.scala
new file mode 100644
index 00000000000..0d39d65c34d
--- /dev/null
+++ b/tree/src/main/scala/org/apache/spark/tree/TreeExternalCatalogTester.scala
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.spark.tree
+
+import org.apache.spark.sql.execution.SparkSqlParser
+
+private[spark] object TreeExternalCatalogTester {
+
+  def main(args: Array[String]): Unit = {
+
+    val sqlParser = new SparkSqlParser
+
+    val db_name = args(0)
+    val external_catalog = new TreeExternalCatalog()
+    val db = external_catalog.getDatabase(db_name)
+    printf(db.toString + "\n")
+    val tables = external_catalog.listTables(db_name)
+    printf(tables.toString() + "\n")
+    val table = external_catalog.getTable(db_name, tables(0))
+//    val expr = sqlParser.parseExpression("part_field1 > 'part_field1=950'")
+//    print(expr.toJSON + "\n")
+    val partitions = external_catalog.listPartitions(db_name, tables(0), None)
+    partitions.foreach{ partition => printf(partition.toString + "\n")}
+    val files = external_catalog.listFiles(table, None)
+    files.foreach{ file => printf(file.toString + "\n")}
+//    printf(table.toString() + "\n")
+//    val partitions = external_catalog.listPartitions(db_name, tables(0))
+//    partitions.foreach{ partition => printf(partition.toString + "\n")}
+//    val files = external_catalog.listFiles(table)
+//    printf(files.toString() + "\n")
+  }
+
+}
